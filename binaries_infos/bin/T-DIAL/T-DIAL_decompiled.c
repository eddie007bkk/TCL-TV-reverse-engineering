//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2018 Retargetable Decompiler <info@retdec.com>
//

#include <arpa/inet.h>
#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <netinet/in.h>
#include <pthread.h>
#include <regex.h>
#include <signal.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stropts.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <time.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct DIALAppCallbacks {
    int32_t (*e0)(struct DIALServer_ *, char *, char *, int32_t, char **, char *);
    void (*e1)(struct DIALServer_ *, char *, char *, char *);
    int32_t (*e2)(struct DIALServer_ *, char *, char *, int32_t *, char *);
};

struct DIALAppCallbacks_1 {
    int32_t (*e0)(struct DIALServer__1 *, char *, char *, int32_t, char **, char *);
    void (*e1)(struct DIALServer__1 *, char *, char *, char *);
    int32_t (*e2)(struct DIALServer__1 *, char *, char *, int32_t *, char *);
};

struct DIALApp_ {
    struct DIALApp_ * e0;
    struct DIALAppCallbacks_1 e1;
    struct DIALData_ * e2;
    char * e3;
    char * e4;
    int32_t e5;
    int32_t e6;
    char * e7;
    char e8[4096];
    int32_t e9;
    char e10[256];
};

struct DIALData_ {
    struct DIALData_ * e0;
    char * e1;
    char * e2;
};

struct DIALData__2 {
    struct DIALData__2 * e0;
    char * e1;
    char * e2;
};

struct DIALServer_ {
    int32_t e0;
};

struct _IO_FILE {
    int32_t e0;
    char * e1;
    char * e2;
    char * e3;
    char * e4;
    char * e5;
    char * e6;
    char * e7;
    char * e8;
    char * e9;
    char * e10;
    char * e11;
    struct _IO_marker * e12;
    struct _IO_FILE * e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int16_t e17;
    char e18;
    char e19[1];
    char * e20;
    int64_t e21;
    char * e22;
    char * e23;
    char * e24;
    char * e25;
    int32_t e26;
    int32_t e27;
    char e28[40];
};

struct _IO_FILE_1 {
    int32_t e0;
    char * e1;
    char * e2;
    char * e3;
    char * e4;
    char * e5;
    char * e6;
    char * e7;
    char * e8;
    char * e9;
    char * e10;
    char * e11;
    struct _IO_marker_1 * e12;
    struct _IO_FILE_1 * e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int16_t e17;
    char e18;
    char e19[1];
    char * e20;
    int64_t e21;
    char * e22;
    char * e23;
    char * e24;
    char * e25;
    int32_t e26;
    int32_t e27;
    char e28[40];
};

struct _IO_FILE_2 {
    int32_t e0;
    char * e1;
    char * e2;
    char * e3;
    char * e4;
    char * e5;
    char * e6;
    char * e7;
    char * e8;
    char * e9;
    char * e10;
    char * e11;
    struct _IO_marker_2 * e12;
    struct _IO_FILE_2 * e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int16_t e17;
    char e18;
    char e19[1];
    char * e20;
    int64_t e21;
    char * e22;
    char * e23;
    char * e24;
    char * e25;
    int32_t e26;
    int32_t e27;
    char e28[40];
};

struct _IO_marker {
    struct _IO_marker * e0;
    struct _IO_FILE * e1;
    int32_t e2;
};

struct _IO_marker_1 {
    struct _IO_marker_1 * e0;
    struct _IO_FILE_1 * e1;
    int32_t e2;
};

struct _IO_marker_2 {
    struct _IO_marker_2 * e0;
    struct _IO_FILE_2 * e1;
    int32_t e2;
};

struct _TYPEDEF_regmatch_t {
    int32_t e0;
    int32_t e1;
};

struct __dirstream {
    int32_t e0;
};

struct __pthread_internal_slist_1 {
    struct __pthread_internal_slist_1 * e0;
};

struct __pthread_internal_slist_2 {
    struct __pthread_internal_slist_2 * e0;
};

struct __va_list {
    char * e0;
};

struct anon_struct_12 {
    int32_t e0;
    struct __pthread_internal_slist_1 e1;
};

struct __pthread_mutex_s_1 {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    struct anon_struct_12 e5;
};

struct anon_struct_13 {
    struct __pthread_mutex_s_1 e0;
    char e1[24];
    int32_t e2;
};

struct DIALServer__1 {
    struct mg_context * e0;
    struct DIALApp_ * e1;
    struct anon_struct_13 e2;
};

struct anon_struct_14 {
    char e0[36];
    int32_t e1;
};

struct anon_struct_15 {
    int32_t e0;
    struct __pthread_internal_slist_2 e1;
};

struct __pthread_mutex_s_2 {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    struct anon_struct_15 e5;
};

struct anon_struct_16 {
    struct __pthread_mutex_s_2 e0;
    char e1[24];
    int32_t e2;
};

struct anon_struct_17 {
    int32_t e0;
    int32_t e1;
    int64_t e2;
    int64_t e3;
    int64_t e4;
    char * e5;
    int32_t e6;
    int32_t e7;
};

struct anon_struct_18 {
    struct anon_struct_17 e0;
    char e1[48];
    int64_t e2;
};

struct anon_struct_19 {
    char e0[36];
    int32_t e1;
};

struct anon_struct_20 {
    char e0[16];
};

struct anon_struct_22 {
    char * e0;
    struct ifreq * e1;
};

struct anon_struct_4 {
    int32_t e0;
    int32_t e1;
};

struct ifconf {
    int32_t e0;
    struct anon_struct_22 e1;
};

struct ifmap {
    int32_t e0;
    int32_t e1;
    int16_t e2;
    char e3;
    char e4;
    char e5;
};

struct in_addr_1 {
    int32_t e0;
};

struct in_addr_2 {
    int32_t e0;
};

struct ip_mreq {
    struct in_addr_2 e0;
    struct in_addr_2 e1;
};

struct mg_context {
    int32_t e0;
};

struct mg_header_1 {
    char * e0;
    char * e1;
};

struct re_pattern_buffer {
    char * e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    char * e4;
    char * e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int32_t e12;
    int32_t e13;
};

struct sockaddr {
    int16_t e0;
    char e1[14];
};

struct sockaddr_1 {
    int16_t e0;
    char e1[14];
};

struct sockaddr_2 {
    int16_t e0;
    char e1[14];
};

struct anon_struct_21 {
    struct sockaddr_2 e0;
    struct sockaddr_2 e1;
    struct sockaddr_2 e2;
    struct sockaddr_2 e3;
    struct sockaddr_2 e4;
    int16_t e5;
    int32_t e6;
    int32_t e7;
    struct ifmap e8;
    char e9[16];
    char e10[16];
    char * e11;
};

struct ifreq {
    struct anon_struct_20 e0;
    struct anon_struct_21 e1;
};

struct sockaddr_in_1 {
    int16_t e0;
    int16_t e1;
    struct in_addr_1 e2;
    char e3[8];
};

struct mg_request_info_1 {
    char * e0;
    char * e1;
    char * e2;
    char * e3;
    char * e4;
    char * e5;
    char * e6;
    struct sockaddr_in_1 e7;
    struct sockaddr_in_1 e8;
    int32_t e9;
    int32_t e10;
    struct mg_header_1 e11[16];
};

struct sockaddr_in_2 {
    int16_t e0;
    int16_t e1;
    struct in_addr_2 e2;
    char e3[8];
};

struct socket {
    int32_t e0;
    struct sockaddr_in_1 e1;
    struct sockaddr_in_1 e2;
};

struct mg_connection_1 {
    struct mg_request_info_1 e0;
    struct mg_context_1 * e1;
    struct socket e2;
    int32_t e3;
    int64_t e4;
    int64_t e5;
    int64_t e6;
    char * e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
};

struct mg_context_1 {
    int32_t e0;
    char * (*e1)(int32_t, struct mg_connection_1 *, struct mg_request_info_1 *);
    char * e2;
    int32_t e3;
    struct sockaddr_in_1 e4;
    int32_t e5;
    struct anon_struct_16 e6;
    struct anon_struct_18 e7;
    struct socket e8[20];
    int32_t e9;
    int32_t e10;
    struct anon_struct_18 e11;
    struct anon_struct_18 e12;
};

struct timespec {
    int32_t e0;
    int32_t e1;
};

struct timeval {
    int32_t e0;
    int32_t e1;
};

struct timeval_1 {
    int32_t e0;
    int32_t e1;
};

// ------------------- Function Prototypes --------------------

int32_t __do_global_dtors_aux(int32_t result);
int32_t __libc_csu_init(int32_t result, int32_t a2, int32_t a3);
void _init(void);
void call_gmon_start(void);
char * call_user(struct mg_connection_1 * conn, int32_t event);
void close_all_listening_sockets(struct mg_context_1 * ctx2);
void createIGMPTask(void);
void cry(struct mg_connection_1 * conn, char * fmt, ...);
int32_t deregister_tm_clones(void);
struct DIALServer__1 * DIAL_create(void);
int16_t DIAL_get_port(struct DIALServer__1 * ds);
int32_t DIAL_register_app(struct DIALServer__1 * ds, char * app_name, struct DIALAppCallbacks_1 * callbacks, char * user_data, int32_t useAdditionalData, char * corsAllowedOrigin);
void DIAL_start(struct DIALServer__1 * ds);
void DIAL_stop(struct DIALServer__1 * ds);
int32_t doesMatch(char * pzExp, char * pzStr);
void ds_lock(struct DIALServer__1 * ds);
void ds_unlock(struct DIALServer__1 * ds);
struct mg_connection_1 * fc(struct mg_context_1 * ctx2);
struct DIALApp_ ** find_app(struct DIALServer__1 * ds, char * app_name);
int32_t frame_dummy(int32_t a1, int32_t a2);
void free_context(struct mg_context_1 * ctx2);
int32_t function_9d5a(int32_t result);
int32_t function_aeae(int32_t result);
void get_local_address(void);
char * getAppPath(char * app_name);
void handle_mcast(void);
void ipc_create_pipe(char * pipe_name);
int32_t ipc_initialize_pipe(char * fifo_name, int32_t * is_pipe_name_set);
void ipc_set_pipe_name(char * pipeName, int32_t * is_pipe_name_set);
int32_t isAppRunning(char * pzName, char * pzCommandPattern);
int32_t mg_get_listen_addr(struct mg_context_1 * ctx2, struct sockaddr_1 * addr, int32_t * addrlen);
int32_t mg_printf(struct mg_connection_1 * conn, char * fmt, ...);
int32_t mg_snprintf(struct mg_connection_1 * conn, char * buf, int32_t buflen, char * fmt, ...);
struct mg_context_1 * mg_start(char * (*user_callback)(int32_t, struct mg_connection_1 *, struct mg_request_info_1 *), char * user_data, int32_t port);
void mg_stop(struct mg_context_1 * ctx2);
int32_t mg_vsnprintf(struct mg_connection_1 * conn, char * buf, uint32_t buflen, char * fmt, struct __va_list ap);
int32_t mg_write(struct mg_connection_1 * conn, char * buf, int32_t len);
void printUsage(void);
void processOption(int32_t index, char * pOption);
int64_t push(struct _IO_FILE_1 * fp, int32_t sock, char * buf, int64_t len);
int32_t register_tm_clones(void);
struct DIALData__2 * retrieve_dial_data(char * app_name);
void run_ssdp(int32_t port, char * pFriendlyName, char * pModelName, char * pUuid);
void runDial(void);
int32_t set_non_blocking_mode(int32_t sock);
int32_t set_ports_option(struct mg_context_1 * ctx2, int32_t port);
void setDataDir(char * pData);
void setValue(char * pSource, char * dest);
int32_t start_thread(struct mg_context_1 * ctx2, char * (*func)(char *), char * param);
int32_t unknown_99cc(void);

// --------------------- Global Variables ---------------------

int32_t _mIGMPThread = 0;
int32_t ctx = 0;
int32_t dial_port = 0;
char friendly_name[256];
char gBuf[4096];
int32_t gDialPort = 0;
int32_t lock_message = 0;
char m_uuid[256];
char model_name[256];
int32_t my_port = 0;
int32_t netflix_state = 0;
char spModelName[256];
char spUuid[256];

// ------------------------ Functions -------------------------

// Address range: 0x9748 - 0x9751
void _init(void) {
    int32_t v1 = 0x9d41; // 0x19000
    int32_t v2 = 0x9d29; // 0x19004
    int32_t v3 = 0; // 0x19008
    int32_t v4 = 0; // 0x192dc
    int32_t v5 = 0; // 0x193b8
    char * v6; // 0x193bc
    struct mg_connection_1 * v7 = NULL; // 0x1a9e8
    int32_t v8 = 0; // 0x1aaac
    char * v9; // 0x1bb0c
    int32_t v10 = 0; // 0x1bc07
    char * v11; // 0x1bc0c
    char * v12; // 0x1bc10
    char * v13; // 0x1bc14
    int32_t v14 = 0; // 0x1bc18
    char * v15; // 0x1bc1c
    char * v16; // 0x1bc20
    char * v17; // 0x1bc24
    int32_t v18 = 0; // 0x1bc28
    char * v19; // 0x1bc2c
    int32_t v20 = 0; // 0x1bd07
    char * v21; // 0x1bd0c
    char * v22; // 0x1bd10
    char * v23; // 0x1bd14
    int16_t * v24 = NULL; // 0x1bd18
    char * v25; // 0x1bd1a
    int32_t v26 = 0; // 0x1be18
    int32_t v27 = 0; // 0x1be30
    int32_t v28 = 0x120000; // 0x8912
    int32_t v29 = 0x30002; // 0x92e8
    int32_t v30 = 0x30003; // 0x9340
    int32_t v31 = 3; // 0x9348
    int32_t v32 = 0x30003; // 0x934c
    int32_t v33 = 0x30003; // 0x9350
    int32_t v34 = 3; // 0x9358
    int32_t v35 = 3; // 0x935c
    int32_t v36 = 0x30003; // 0x9360
    int32_t v37 = 0x30002; // 0x9364
    int32_t v38 = 0x30002; // 0x9368
    int32_t v39 = 0x30000; // 0x93a4
    int32_t v40 = 428; // 0x93b4
    int32_t v41 = 0xd696914; // 0x93c0
    int32_t v42 = 0x2516; // 0x94cc
    int32_t v43 = 0x4516; // 0x95cc
    int32_t v44 = 0x6c16; // 0x96cc
    int32_t v45 = 0xab89; // 0xab74
    struct mg_context_1 * v46 = (struct mg_context_1 *)0x2b0cfb5; // 0xbc49
    int32_t v47 = 0xe00046; // 0xc2a3
    int32_t v48 = 0xb086b5; // 0xd8b1
    int32_t v49 = 0xb08cb5; // 0xdab9
    struct mg_context_1 * v50 = (struct mg_context_1 *)0x2b086b5; // 0xdcd9
    int32_t v51 = -0x7e0af8ad; // 0xddd5
    int32_t v52 = 0x5c81f507; // 0xddd6
    int32_t v53 = 0x2b08cb5; // 0xe491
    int16_t v54 = 0x3120; // 0xffff
    // 0x9748
    call_gmon_start();
}

// Address range: 0x9cc0 - 0x9cd7
void call_gmon_start(void) {
    int32_t v1; // 0x19000
    int32_t v2; // 0x19004
    int32_t v3; // 0x19008
    int32_t v4; // 0x193b8
    char * v5; // 0x193bc
    struct mg_connection_1 * v6; // 0x1a9e8
    int32_t v7; // 0x1aaac
    char * v8; // 0x1bb0c
    int32_t v9; // 0x1bc07
    char * v10; // 0x1bc0c
    char * v11; // 0x1bc10
    char * v12; // 0x1bc14
    int32_t v13; // 0x1bc18
    char * v14; // 0x1bc1c
    char * v15; // 0x1bc20
    char * v16; // 0x1bc24
    int32_t v17; // 0x1bc28
    char * v18; // 0x1bc2c
    int32_t v19; // 0x1bd07
    char * v20; // 0x1bd0c
    char * v21; // 0x1bd10
    char * v22; // 0x1bd14
    int16_t * v23; // 0x1bd18
    char * v24; // 0x1bd1a
    int32_t v25; // 0x1be18
    int32_t v26; // 0x1be30
    int32_t v27; // 0x8912
    int32_t v28; // 0x92e8
    int32_t v29; // 0x9340
    int32_t v30; // 0x9348
    int32_t v31; // 0x934c
    int32_t v32; // 0x9350
    int32_t v33; // 0x9358
    int32_t v34; // 0x935c
    int32_t v35; // 0x9360
    int32_t v36; // 0x9364
    int32_t v37; // 0x9368
    int32_t v38; // 0x93a4
    int32_t v39; // 0x93b4
    int32_t v40; // 0x93c0
    int32_t v41; // 0x94cc
    int32_t v42; // 0x95cc
    int32_t v43; // 0x96cc
    int32_t v44; // 0xab74
    struct mg_context_1 * v45; // 0xbc49
    int32_t v46; // 0xc2a3
    int32_t v47; // 0xd8b1
    int32_t v48; // 0xdab9
    struct mg_context_1 * v49; // 0xdcd9
    int32_t v50; // 0xddd5
    int32_t v51; // 0xddd6
    int32_t v52; // 0xe491
    int16_t v53; // 0xffff
    // 0x9cc0
    int32_t v54; // 0x192dc
    if (v54 == 0) {
        // 0x9cce
        return;
    }
    // 0x9cca
    unknown_99cc();
    unknown_99cc();
}

// Address range: 0x9cd8 - 0x9cfb
int32_t deregister_tm_clones(void) {
    int32_t v1; // 0x19000
    int32_t v2; // 0x19004
    int32_t v3; // 0x19008
    int32_t v4; // 0x192dc
    char * v5; // 0x193bc
    struct mg_connection_1 * v6; // 0x1a9e8
    int32_t v7; // 0x1aaac
    char * v8; // 0x1bb0c
    int32_t v9; // 0x1bc07
    char * v10; // 0x1bc0c
    char * v11; // 0x1bc10
    char * v12; // 0x1bc14
    int32_t v13; // 0x1bc18
    char * v14; // 0x1bc1c
    char * v15; // 0x1bc20
    char * v16; // 0x1bc24
    int32_t v17; // 0x1bc28
    char * v18; // 0x1bc2c
    int32_t v19; // 0x1bd07
    char * v20; // 0x1bd0c
    char * v21; // 0x1bd10
    char * v22; // 0x1bd14
    int16_t * v23; // 0x1bd18
    char * v24; // 0x1bd1a
    int32_t v25; // 0x1be18
    int32_t v26; // 0x1be30
    int32_t v27; // 0x8912
    int32_t v28; // 0x92e8
    int32_t v29; // 0x9340
    int32_t v30; // 0x9348
    int32_t v31; // 0x934c
    int32_t v32; // 0x9350
    int32_t v33; // 0x9358
    int32_t v34; // 0x935c
    int32_t v35; // 0x9360
    int32_t v36; // 0x9364
    int32_t v37; // 0x9368
    int32_t v38; // 0x93a4
    int32_t v39; // 0x93b4
    int32_t v40; // 0x93c0
    int32_t v41; // 0x94cc
    int32_t v42; // 0x95cc
    int32_t v43; // 0x96cc
    int32_t v44; // 0xab74
    struct mg_context_1 * v45; // 0xbc49
    int32_t v46; // 0xc2a3
    int32_t v47; // 0xd8b1
    int32_t v48; // 0xdab9
    struct mg_context_1 * v49; // 0xdcd9
    int32_t v50; // 0xddd5
    int32_t v51; // 0xddd6
    int32_t v52; // 0xe491
    int16_t v53; // 0xffff
    // 0x9cd8
    int32_t v54; // 0x193b8
    return &v54;
}

// Address range: 0x9cfc - 0x9d27
int32_t register_tm_clones(void) {
    int32_t v1; // 0x19000
    int32_t v2; // 0x19004
    int32_t v3; // 0x19008
    int32_t v4; // 0x192dc
    char * v5; // 0x193bc
    struct mg_connection_1 * v6; // 0x1a9e8
    int32_t v7; // 0x1aaac
    char * v8; // 0x1bb0c
    int32_t v9; // 0x1bc07
    char * v10; // 0x1bc0c
    char * v11; // 0x1bc10
    char * v12; // 0x1bc14
    int32_t v13; // 0x1bc18
    char * v14; // 0x1bc1c
    char * v15; // 0x1bc20
    char * v16; // 0x1bc24
    int32_t v17; // 0x1bc28
    char * v18; // 0x1bc2c
    int32_t v19; // 0x1bd07
    char * v20; // 0x1bd0c
    char * v21; // 0x1bd10
    char * v22; // 0x1bd14
    int16_t * v23; // 0x1bd18
    char * v24; // 0x1bd1a
    int32_t v25; // 0x1be18
    int32_t v26; // 0x1be30
    int32_t v27; // 0x8912
    int32_t v28; // 0x92e8
    int32_t v29; // 0x9340
    int32_t v30; // 0x9348
    int32_t v31; // 0x934c
    int32_t v32; // 0x9350
    int32_t v33; // 0x9358
    int32_t v34; // 0x935c
    int32_t v35; // 0x9360
    int32_t v36; // 0x9364
    int32_t v37; // 0x9368
    int32_t v38; // 0x93a4
    int32_t v39; // 0x93b4
    int32_t v40; // 0x93c0
    int32_t v41; // 0x94cc
    int32_t v42; // 0x95cc
    int32_t v43; // 0x96cc
    int32_t v44; // 0xab74
    struct mg_context_1 * v45; // 0xbc49
    int32_t v46; // 0xc2a3
    int32_t v47; // 0xd8b1
    int32_t v48; // 0xdab9
    struct mg_context_1 * v49; // 0xdcd9
    int32_t v50; // 0xddd5
    int32_t v51; // 0xddd6
    int32_t v52; // 0xe491
    int16_t v53; // 0xffff
    // 0x9cfc
    int32_t v54; // 0x193b8
    return &v54;
}

// Address range: 0x9d28 - 0x9d3f
int32_t __do_global_dtors_aux(int32_t result) {
    int32_t v1; // 0x19000
    int32_t v2; // 0x19004
    int32_t v3; // 0x19008
    int32_t v4; // 0x192dc
    struct mg_connection_1 * v5; // 0x1a9e8
    int32_t v6; // 0x1aaac
    char * v7; // 0x1bb0c
    int32_t v8; // 0x1bc07
    char * v9; // 0x1bc0c
    char * v10; // 0x1bc10
    char * v11; // 0x1bc14
    int32_t v12; // 0x1bc18
    char * v13; // 0x1bc1c
    char * v14; // 0x1bc20
    char * v15; // 0x1bc24
    int32_t v16; // 0x1bc28
    char * v17; // 0x1bc2c
    int32_t v18; // 0x1bd07
    char * v19; // 0x1bd0c
    char * v20; // 0x1bd10
    char * v21; // 0x1bd14
    int16_t * v22; // 0x1bd18
    char * v23; // 0x1bd1a
    int32_t v24; // 0x1be18
    int32_t v25; // 0x1be30
    int32_t v26; // 0x8912
    int32_t v27; // 0x92e8
    int32_t v28; // 0x9340
    int32_t v29; // 0x9348
    int32_t v30; // 0x934c
    int32_t v31; // 0x9350
    int32_t v32; // 0x9358
    int32_t v33; // 0x935c
    int32_t v34; // 0x9360
    int32_t v35; // 0x9364
    int32_t v36; // 0x9368
    int32_t v37; // 0x93a4
    int32_t v38; // 0x93b4
    int32_t v39; // 0x93c0
    int32_t v40; // 0x94cc
    int32_t v41; // 0x95cc
    int32_t v42; // 0x96cc
    int32_t v43; // 0xab74
    struct mg_context_1 * v44; // 0xbc49
    int32_t v45; // 0xc2a3
    int32_t v46; // 0xd8b1
    int32_t v47; // 0xdab9
    struct mg_context_1 * v48; // 0xdcd9
    int32_t v49; // 0xddd5
    int32_t v50; // 0xddd6
    int32_t v51; // 0xe491
    int16_t v52; // 0xffff
    char * v53; // 0x193bc
    if (*(char *)&v53 == 0) {
        // 0x9d30
        deregister_tm_clones();
        int32_t v54; // 0x193b8
        result = &v54;
        // branch -> 0x9d38
    }
    // 0x9d38
    return result;
}

// Address range: 0x9d40 - 0x9d59
int32_t frame_dummy(int32_t a1, int32_t a2) {
    int32_t v1; // 0x19000
    int32_t v2; // 0x19004
    int32_t v3; // 0x19008
    int32_t v4; // 0x192dc
    char * v5; // 0x193bc
    struct mg_connection_1 * v6; // 0x1a9e8
    int32_t v7; // 0x1aaac
    char * v8; // 0x1bb0c
    int32_t v9; // 0x1bc07
    char * v10; // 0x1bc0c
    char * v11; // 0x1bc10
    char * v12; // 0x1bc14
    int32_t v13; // 0x1bc18
    char * v14; // 0x1bc1c
    char * v15; // 0x1bc20
    char * v16; // 0x1bc24
    int32_t v17; // 0x1bc28
    char * v18; // 0x1bc2c
    int32_t v19; // 0x1bd07
    char * v20; // 0x1bd0c
    char * v21; // 0x1bd10
    char * v22; // 0x1bd14
    int16_t * v23; // 0x1bd18
    char * v24; // 0x1bd1a
    int32_t v25; // 0x1be18
    int32_t v26; // 0x1be30
    int32_t v27; // 0x8912
    int32_t v28; // 0x92e8
    int32_t v29; // 0x9340
    int32_t v30; // 0x9348
    int32_t v31; // 0x934c
    int32_t v32; // 0x9350
    int32_t v33; // 0x9358
    int32_t v34; // 0x935c
    int32_t v35; // 0x9360
    int32_t v36; // 0x9364
    int32_t v37; // 0x9368
    int32_t v38; // 0x93a4
    int32_t v39; // 0x93b4
    int32_t v40; // 0x93c0
    int32_t v41; // 0x94cc
    int32_t v42; // 0x95cc
    int32_t v43; // 0x96cc
    int32_t v44; // 0xab74
    struct mg_context_1 * v45; // 0xbc49
    int32_t v46; // 0xc2a3
    int32_t v47; // 0xd8b1
    int32_t v48; // 0xdab9
    struct mg_context_1 * v49; // 0xdcd9
    int32_t v50; // 0xddd5
    int32_t v51; // 0xddd6
    int32_t v52; // 0xe491
    int16_t v53; // 0xffff
    // 0x9d40
    register_tm_clones();
    int32_t v54; // 0x193b8
    return &v54;
}

// Address range: 0x9d5a - 0x9d5f
int32_t function_9d5a(int32_t result) {
    int32_t v1; // 0x19000
    int32_t v2; // 0x19004
    int32_t v3; // 0x19008
    int32_t v4; // 0x192dc
    int32_t v5; // 0x193b8
    char * v6; // 0x193bc
    struct mg_connection_1 * v7; // 0x1a9e8
    int32_t v8; // 0x1aaac
    char * v9; // 0x1bb0c
    int32_t v10; // 0x1bc07
    char * v11; // 0x1bc0c
    char * v12; // 0x1bc10
    char * v13; // 0x1bc14
    int32_t v14; // 0x1bc18
    char * v15; // 0x1bc1c
    char * v16; // 0x1bc20
    char * v17; // 0x1bc24
    int32_t v18; // 0x1bc28
    char * v19; // 0x1bc2c
    int32_t v20; // 0x1bd07
    char * v21; // 0x1bd0c
    char * v22; // 0x1bd10
    char * v23; // 0x1bd14
    int16_t * v24; // 0x1bd18
    char * v25; // 0x1bd1a
    int32_t v26; // 0x1be18
    int32_t v27; // 0x1be30
    int32_t v28; // 0x8912
    int32_t v29; // 0x92e8
    int32_t v30; // 0x9340
    int32_t v31; // 0x9348
    int32_t v32; // 0x934c
    int32_t v33; // 0x9350
    int32_t v34; // 0x9358
    int32_t v35; // 0x935c
    int32_t v36; // 0x9360
    int32_t v37; // 0x9364
    int32_t v38; // 0x9368
    int32_t v39; // 0x93a4
    int32_t v40; // 0x93b4
    int32_t v41; // 0x93c0
    int32_t v42; // 0x94cc
    int32_t v43; // 0x95cc
    int32_t v44; // 0x96cc
    int32_t v45; // 0xab74
    struct mg_context_1 * v46; // 0xbc49
    int32_t v47; // 0xc2a3
    int32_t v48; // 0xd8b1
    int32_t v49; // 0xdab9
    struct mg_context_1 * v50; // 0xdcd9
    int32_t v51; // 0xddd5
    int32_t v52; // 0xddd6
    int32_t v53; // 0xe491
    int16_t v54; // 0xffff
    // 0x9d5a
    return result;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/dial/src/server/main.c
// Address range: 0x9d60 - 0x9dff
// Line range:    112 - 129
int32_t doesMatch(char * pzExp, char * pzStr) {
    struct _TYPEDEF_regmatch_t pmatch[1]; // 0x9dd4_8
    char errbuf[1024];
    struct re_pattern_buffer preg;
    int32_t v1; // 0x19000
    int32_t v2; // 0x19004
    int32_t v3; // 0x19008
    int32_t v4; // 0x192dc
    int32_t v5; // 0x193b8
    char * v6; // 0x193bc
    struct mg_connection_1 * v7; // 0x1a9e8
    int32_t v8; // 0x1aaac
    char * v9; // 0x1bb0c
    int32_t v10; // 0x1bc07
    char * v11; // 0x1bc0c
    char * v12; // 0x1bc10
    char * v13; // 0x1bc14
    int32_t v14; // 0x1bc18
    char * v15; // 0x1bc1c
    char * v16; // 0x1bc20
    char * v17; // 0x1bc24
    int32_t v18; // 0x1bc28
    char * v19; // 0x1bc2c
    int32_t v20; // 0x1bd07
    char * v21; // 0x1bd0c
    char * v22; // 0x1bd10
    char * v23; // 0x1bd14
    int16_t * v24; // 0x1bd18
    char * v25; // 0x1bd1a
    int32_t v26; // 0x1be18
    int32_t v27; // 0x1be30
    int32_t v28; // 0x8912
    int32_t v29; // 0x92e8
    int32_t v30; // 0x9340
    int32_t v31; // 0x9348
    int32_t v32; // 0x934c
    int32_t v33; // 0x9350
    int32_t v34; // 0x9358
    int32_t v35; // 0x935c
    int32_t v36; // 0x9360
    int32_t v37; // 0x9364
    int32_t v38; // 0x9368
    int32_t v39; // 0x93a4
    int32_t v40; // 0x93b4
    int32_t v41; // 0x93c0
    int32_t v42; // 0x94cc
    int32_t v43; // 0x95cc
    int32_t v44; // 0x96cc
    int32_t v45; // 0xab74
    struct mg_context_1 * v46; // 0xbc49
    int32_t v47; // 0xc2a3
    int32_t v48; // 0xd8b1
    int32_t v49; // 0xdab9
    struct mg_context_1 * v50; // 0xdcd9
    int32_t v51; // 0xddd5
    int32_t v52; // 0xddd6
    int32_t v53; // 0xe491
    int16_t v54; // 0xffff
    struct anon_struct_4 v55[1];
    if (regcomp(&preg, pzExp, 1) == 0) {
        // 0x9dc0
        pmatch[0].e0 = (int32_t)&v55;
        if (regexec(&preg, pzStr, 1, pmatch, 0) == 0) {
            // 0x9dde
            // branch -> 0x9de4
        }
    } else {
        // 0x9d92
        memset(errbuf, 0, 1024);
        int32_t errcode; // 0x9dae
        regerror(errcode, &preg, errbuf, 1024);
        // branch -> 0x9de4
    }
    // 0x9de4
    regfree(&preg);
    int32_t result; // 0x9dee
    return result;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/dial/src/server/main.c
// Address range: 0x9f64 - 0xa243
// Line range:    181 - 279
int32_t isAppRunning(char * pzName, char * pzCommandPattern) {
    int32_t v1; // 0x19000
    int32_t v2; // 0x19004
    int32_t v3; // 0x19008
    int32_t v4; // 0x192dc
    int32_t v5; // 0x193b8
    char * v6; // 0x193bc
    struct mg_connection_1 * v7; // 0x1a9e8
    int32_t v8; // 0x1aaac
    char * v9; // 0x1bb0c
    int32_t v10; // 0x1bc07
    char * v11; // 0x1bc0c
    char * v12; // 0x1bc10
    char * v13; // 0x1bc14
    int32_t v14; // 0x1bc18
    char * v15; // 0x1bc1c
    char * v16; // 0x1bc20
    char * v17; // 0x1bc24
    int32_t v18; // 0x1bc28
    char * v19; // 0x1bc2c
    int32_t v20; // 0x1bd07
    char * v21; // 0x1bd0c
    char * v22; // 0x1bd10
    char * v23; // 0x1bd14
    int16_t * v24; // 0x1bd18
    char * v25; // 0x1bd1a
    int32_t v26; // 0x8912
    int32_t v27; // 0x92e8
    int32_t v28; // 0x9340
    int32_t v29; // 0x9348
    int32_t v30; // 0x934c
    int32_t v31; // 0x9350
    int32_t v32; // 0x9358
    int32_t v33; // 0x935c
    int32_t v34; // 0x9360
    int32_t v35; // 0x9364
    int32_t v36; // 0x9368
    int32_t v37; // 0x93a4
    int32_t v38; // 0x93b4
    int32_t v39; // 0x93c0
    int32_t v40; // 0x94cc
    int32_t v41; // 0x95cc
    int32_t v42; // 0x96cc
    int32_t v43; // 0xab74
    struct mg_context_1 * v44; // 0xbc49
    int32_t v45; // 0xc2a3
    int32_t v46; // 0xd8b1
    int32_t v47; // 0xdab9
    struct mg_context_1 * v48; // 0xdcd9
    int32_t v49; // 0xddd5
    int32_t v50; // 0xddd6
    int32_t v51; // 0xe491
    int16_t v52; // 0xffff
    struct timeval tp;
    struct timespec abstime;
    char * v53;
    char * pzNameZ = v53; // bp-12
    if (strcmp(pzName, "netflix") != 0) {
        // 0xa01c
        pzNameZ = pzName;
        opendir("/proc");
        opendir("/proc");
        puts("/proc failed to open");
        printf("app[name=%s] is not running...\n", pzNameZ);
        // branch -> 0xa230
        // 0xa230
        return 0;
    }
    // 0x9f8a
    int32_t v54; // 0x9f92
    api_send_message_to_application(v54, (int32_t)"eventmanager", (int32_t)"o Netflix application");
    int32_t mutex; // 0x1be18
    pthread_mutex_lock(&mutex);
    gettimeofday(&tp, NULL);
    int32_t cond; // 0x1be30
    int32_t v55 = pthread_cond_timedwait(&cond, &mutex, &abstime); // 0x9fd2
    pthread_mutex_unlock(&mutex);
    int32_t result; // 0xa230
    if (v55 == 110) {
        // 0x9fdc
        printf("\n [dial] - get status timeout !");
        result = 0;
        // branch -> 0xa230
    } else {
        // 0x9ff2
        printf("\n [dial] - get pid[%d]", netflix_state);
        result = netflix_state;
        // branch -> 0xa230
    }
    // 0xa230
    return result;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/dial/src/server/main.c
// Address range: 0xa2d4 - 0xa303
// Line range:    300 - 305
void setValue(char * pSource, char * dest) {
    int32_t v1; // 0x19000
    int32_t v2; // 0x19004
    int32_t v3; // 0x19008
    int32_t v4; // 0x192dc
    int32_t v5; // 0x193b8
    char * v6; // 0x193bc
    struct mg_connection_1 * v7; // 0x1a9e8
    int32_t v8; // 0x1aaac
    char * v9; // 0x1bb0c
    int32_t v10; // 0x1bc07
    char * v11; // 0x1bc0c
    char * v12; // 0x1bc10
    char * v13; // 0x1bc14
    int32_t v14; // 0x1bc18
    char * v15; // 0x1bc1c
    char * v16; // 0x1bc20
    char * v17; // 0x1bc24
    int32_t v18; // 0x1bc28
    char * v19; // 0x1bc2c
    int32_t v20; // 0x1bd07
    char * v21; // 0x1bd0c
    char * v22; // 0x1bd10
    char * v23; // 0x1bd14
    int16_t * v24; // 0x1bd18
    char * v25; // 0x1bd1a
    int32_t v26; // 0x1be18
    int32_t v27; // 0x1be30
    int32_t v28; // 0x8912
    int32_t v29; // 0x92e8
    int32_t v30; // 0x9340
    int32_t v31; // 0x9348
    int32_t v32; // 0x934c
    int32_t v33; // 0x9350
    int32_t v34; // 0x9358
    int32_t v35; // 0x935c
    int32_t v36; // 0x9360
    int32_t v37; // 0x9364
    int32_t v38; // 0x9368
    int32_t v39; // 0x93a4
    int32_t v40; // 0x93b4
    int32_t v41; // 0x93c0
    int32_t v42; // 0x94cc
    int32_t v43; // 0x95cc
    int32_t v44; // 0x96cc
    int32_t v45; // 0xab74
    struct mg_context_1 * v46; // 0xbc49
    int32_t v47; // 0xc2a3
    int32_t v48; // 0xd8b1
    int32_t v49; // 0xdab9
    struct mg_context_1 * v50; // 0xdcd9
    int32_t v51; // 0xddd5
    int32_t v52; // 0xddd6
    int32_t v53; // 0xe491
    int16_t v54; // 0xffff
    // 0xa2d4
    memset(dest, 0, 256);
    memcpy(dest, pSource, strlen(pSource));
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/dial/src/server/main.c
// Address range: 0xa304 - 0xa33b
// Line range:    307 - 311
void setDataDir(char * pData) {
    int32_t v1; // 0x19000
    int32_t v2; // 0x19004
    int32_t v3; // 0x19008
    int32_t v4; // 0x192dc
    int32_t v5; // 0x193b8
    char * v6; // 0x193bc
    struct mg_connection_1 * v7; // 0x1a9e8
    int32_t v8; // 0x1aaac
    char * v9; // 0x1bb0c
    int32_t v10; // 0x1bc07
    char * v11; // 0x1bc0c
    char * v12; // 0x1bc10
    char * v13; // 0x1bc14
    int32_t v14; // 0x1bc18
    char * v15; // 0x1bc1c
    char * v16; // 0x1bc20
    char * v17; // 0x1bc24
    int32_t v18; // 0x1bc28
    char * v19; // 0x1bc2c
    int32_t v20; // 0x1bd07
    char * v21; // 0x1bd0c
    char * v22; // 0x1bd10
    char * v23; // 0x1bd14
    int16_t * v24; // 0x1bd18
    char * v25; // 0x1bd1a
    int32_t v26; // 0x1be18
    int32_t v27; // 0x1be30
    int32_t v28; // 0x8912
    int32_t v29; // 0x92e8
    int32_t v30; // 0x9340
    int32_t v31; // 0x9348
    int32_t v32; // 0x934c
    int32_t v33; // 0x9350
    int32_t v34; // 0x9358
    int32_t v35; // 0x935c
    int32_t v36; // 0x9360
    int32_t v37; // 0x9364
    int32_t v38; // 0x9368
    int32_t v39; // 0x93a4
    int32_t v40; // 0x93b4
    int32_t v41; // 0x93c0
    int32_t v42; // 0x95cc
    int32_t v43; // 0x96cc
    int32_t v44; // 0xab74
    struct mg_context_1 * v45; // 0xbc49
    int32_t v46; // 0xc2a3
    int32_t v47; // 0xd8b1
    int32_t v48; // 0xdab9
    struct mg_context_1 * v49; // 0xdcd9
    int32_t v50; // 0xddd5
    int32_t v51; // 0xddd6
    int32_t v52; // 0xe491
    int16_t v53; // 0xffff
    int32_t v54; // 0x94cc
    int32_t v55; // 0xa314
    setValue((char *)v55, (char *)((int32_t)&v54 | (int32_t)"1\r\nSERVER: Linux/2.6 UPnP/1.0 quick_ssdp/1.0\r\nST: urn:dial-multiscreen-org:service:dial:1\r\nUSN: uuid:%s::urn:dial-multiscreen-org:service:dial:1\r\n\r\n"));
    strcat((char *)((int32_t)&v54 | (int32_t)"1\r\nSERVER: Linux/2.6 UPnP/1.0 quick_ssdp/1.0\r\nST: urn:dial-multiscreen-org:service:dial:1\r\nUSN: uuid:%s::urn:dial-multiscreen-org:service:dial:1\r\n\r\n"), pData);
    strcat((char *)((int32_t)&v54 | (int32_t)"1\r\nSERVER: Linux/2.6 UPnP/1.0 quick_ssdp/1.0\r\nST: urn:dial-multiscreen-org:service:dial:1\r\nUSN: uuid:%s::urn:dial-multiscreen-org:service:dial:1\r\n\r\n"), pData);
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/dial/src/server/main.c
// Address range: 0xa9b0 - 0xaa43
// Line range:    687 - 699
void printUsage(void) {
    int32_t v1; // 0x19000
    int32_t v2; // 0x19004
    int32_t v3; // 0x19008
    int32_t v4; // 0x192dc
    int32_t v5; // 0x193b8
    char * v6; // 0x193bc
    struct mg_connection_1 * v7; // 0x1a9e8
    int32_t v8; // 0x1aaac
    char * v9; // 0x1bb0c
    int32_t v10; // 0x1bc07
    char * v11; // 0x1bc0c
    char * v12; // 0x1bc10
    char * v13; // 0x1bc14
    int32_t v14; // 0x1bc18
    char * v15; // 0x1bc1c
    char * v16; // 0x1bc20
    char * v17; // 0x1bc24
    int32_t v18; // 0x1bc28
    char * v19; // 0x1bc2c
    int32_t v20; // 0x1bd07
    char * v21; // 0x1bd0c
    char * v22; // 0x1bd10
    char * v23; // 0x1bd14
    int16_t * v24; // 0x1bd18
    char * v25; // 0x1bd1a
    int32_t v26; // 0x1be18
    int32_t v27; // 0x1be30
    int32_t v28; // 0x8912
    int32_t v29; // 0x92e8
    int32_t v30; // 0x9340
    int32_t v31; // 0x9348
    int32_t v32; // 0x934c
    int32_t v33; // 0x9350
    int32_t v34; // 0x9358
    int32_t v35; // 0x935c
    int32_t v36; // 0x9360
    int32_t v37; // 0x9364
    int32_t v38; // 0x9368
    int32_t v39; // 0x93a4
    int32_t v40; // 0x93b4
    int32_t v41; // 0x93c0
    int32_t v42; // 0x94cc
    int32_t v43; // 0x95cc
    int32_t v44; // 0x96cc
    int32_t v45; // 0xab74
    struct mg_context_1 * v46; // 0xbc49
    int32_t v47; // 0xc2a3
    int32_t v48; // 0xd8b1
    int32_t v49; // 0xdab9
    struct mg_context_1 * v50; // 0xdcd9
    int32_t v51; // 0xddd5
    int32_t v52; // 0xddd6
    int32_t v53; // 0xe491
    int16_t v54; // 0xffff
    // 0xa9b0
    int32_t v55;
    int32_t numberOfOptions = v55; // bp-24
    int32_t v56;
    int32_t i = v56; // bp-20
    numberOfOptions = 5;
    puts("usage: dialserver <options>");
    puts("options:");
    if (numberOfOptions <= 0) {
        // 0xaa3c
        return;
    }
    i = 0;
    int32_t v57; // 0xa9ec
    int32_t v58; // 0xaa04
    int32_t v59; // 0xaa1c
    printf("        %s|%s [value]: %s\n", (char *)v57, (char *)v58, (char *)v59);
    int32_t v60 = i + 1; // 0xaa30
    i = v60;
    while (v60 < numberOfOptions) {
        // 0xa9d8
        printf("        %s|%s [value]: %s\n", (char *)v57, (char *)v58, (char *)v59);
        v60 = i + 1;
        i = v60;
        // continue -> 0xa9d8
    }
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/dial/src/server/main.c
// Address range: 0xaa44 - 0xab5b
// Line range:    716 - 739
void runDial(void) {
    struct DIALAppCallbacks v1;
    struct DIALAppCallbacks v2;
    struct DIALAppCallbacks v3;
    int32_t v4; // 0x19000
    int32_t v5; // 0x19004
    int32_t v6; // 0x19008
    int32_t v7; // 0x192dc
    int32_t v8; // 0x193b8
    char * v9; // 0x193bc
    struct mg_connection_1 * v10; // 0x1a9e8
    int32_t v11; // 0x1aaac
    char * v12; // 0x1bb0c
    int32_t v13; // 0x1bc07
    char * v14; // 0x1bc0c
    char * v15; // 0x1bc10
    char * v16; // 0x1bc14
    int32_t v17; // 0x1bc18
    char * v18; // 0x1bc1c
    char * v19; // 0x1bc20
    char * v20; // 0x1bc24
    int32_t v21; // 0x1bc28
    char * v22; // 0x1bc2c
    int32_t v23; // 0x1bd07
    char * v24; // 0x1bd0c
    char * v25; // 0x1bd10
    char * v26; // 0x1bd14
    int16_t * v27; // 0x1bd18
    char * v28; // 0x1bd1a
    int32_t v29; // 0x1be18
    int32_t v30; // 0x1be30
    int32_t v31; // 0x8912
    int32_t v32; // 0x92e8
    int32_t v33; // 0x9340
    int32_t v34; // 0x9348
    int32_t v35; // 0x934c
    int32_t v36; // 0x9350
    int32_t v37; // 0x9358
    int32_t v38; // 0x935c
    int32_t v39; // 0x9360
    int32_t v40; // 0x9364
    int32_t v41; // 0x9368
    int32_t v42; // 0x93a4
    int32_t v43; // 0x93b4
    int32_t v44; // 0x93c0
    int32_t v45; // 0x94cc
    int32_t v46; // 0x95cc
    int32_t v47; // 0xab74
    struct mg_context_1 * v48; // 0xbc49
    int32_t v49; // 0xc2a3
    int32_t v50; // 0xd8b1
    int32_t v51; // 0xdab9
    struct mg_context_1 * v52; // 0xdcd9
    int32_t v53; // 0xddd5
    int32_t v54; // 0xddd6
    int32_t v55; // 0xe491
    int16_t v56; // 0xffff
    struct DIALServer_ * v57;
    struct DIALServer_ * ds = v57; // bp-20
    struct DIALServer__1 * v58 = DIAL_create(); // 0xaa4a
    ds = (struct DIALServer_ *)v58;
    v2.e0 = (int32_t (*)(struct DIALServer_ *, char *, char *, int32_t, char **, char *))0xa7d5;
    v2.e1 = (void (*)(struct DIALServer_ *, char *, char *, char *))0xa951;
    v2.e2 = (int32_t (*)(struct DIALServer_ *, char *, char *, int32_t *, char *))0xa915;
    v3.e0 = (int32_t (*)(struct DIALServer_ *, char *, char *, int32_t, char **, char *))0xa531;
    v3.e1 = (void (*)(struct DIALServer_ *, char *, char *, char *))0xa72d;
    v3.e2 = (int32_t (*)(struct DIALServer_ *, char *, char *, int32_t *, char *))0xa6e5;
    v1.e0 = (int32_t (*)(struct DIALServer_ *, char *, char *, int32_t, char **, char *))0xa531;
    v1.e1 = (void (*)(struct DIALServer_ *, char *, char *, char *))0xa72d;
    v1.e2 = (int32_t (*)(struct DIALServer_ *, char *, char *, int32_t *, char *))0xa6e5;
    DIAL_register_app(v58, "Netflix", (struct DIALAppCallbacks_1 *)&v2, NULL, 1, "netflix.com");
    DIAL_register_app((struct DIALServer__1 *)ds, "YouTube", (struct DIALAppCallbacks_1 *)&v3, NULL, 1, "youtube.com");
    DIAL_start((struct DIALServer__1 *)ds);
    DIAL_register_app((struct DIALServer__1 *)ds, "gogiopera-tv-store", (struct DIALAppCallbacks_1 *)&v1, NULL, 1, "youtube.com");
    int32_t v59 = DIAL_get_port((struct DIALServer__1 *)ds); // 0xaaf6_3
    gDialPort = v59;
    printf("launcher listening on gDialPort %d\n", v59);
    int32_t v60; // 0x96cc
    run_ssdp(gDialPort, (char *)((int32_t)&v60 | (int32_t)"1\r\nSERVER: Linux/2.6 UPnP/1.0 quick_ssdp/1.0\r\nST: urn:dial-multiscreen-org:service:dial:1\r\nUSN: uuid:%s::urn:dial-multiscreen-org:service:dial:1\r\n\r\n"), spModelName, spUuid);
    DIAL_stop((struct DIALServer__1 *)ds);
    free((char *)ds);
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/dial/src/server/main.c
// Address range: 0xab5c - 0xabf3
// Line range:    741 - 766
void processOption(int32_t index, char * pOption) {
    int32_t v1; // 0x19000
    int32_t v2; // 0x19004
    int32_t v3; // 0x19008
    int32_t v4; // 0x192dc
    int32_t v5; // 0x193b8
    char * v6; // 0x193bc
    struct mg_connection_1 * v7; // 0x1a9e8
    int32_t v8; // 0x1aaac
    char * v9; // 0x1bb0c
    int32_t v10; // 0x1bc07
    char * v11; // 0x1bc0c
    char * v12; // 0x1bc10
    char * v13; // 0x1bc14
    int32_t v14; // 0x1bc18
    char * v15; // 0x1bc1c
    char * v16; // 0x1bc20
    char * v17; // 0x1bc24
    int32_t v18; // 0x1bc28
    char * v19; // 0x1bc2c
    int32_t v20; // 0x1bd07
    char * v21; // 0x1bd0c
    char * v22; // 0x1bd10
    char * v23; // 0x1bd14
    int16_t * v24; // 0x1bd18
    char * v25; // 0x1bd1a
    int32_t v26; // 0x1be18
    int32_t v27; // 0x1be30
    int32_t v28; // 0x8912
    int32_t v29; // 0x92e8
    int32_t v30; // 0x9340
    int32_t v31; // 0x9348
    int32_t v32; // 0x934c
    int32_t v33; // 0x9350
    int32_t v34; // 0x9358
    int32_t v35; // 0x935c
    int32_t v36; // 0x9360
    int32_t v37; // 0x9364
    int32_t v38; // 0x9368
    int32_t v39; // 0x93a4
    int32_t v40; // 0x93b4
    int32_t v41; // 0x93c0
    int32_t v42; // 0x95cc
    int32_t v43; // 0x96cc
    struct mg_context_1 * v44; // 0xbc49
    int32_t v45; // 0xc2a3
    int32_t v46; // 0xd8b1
    int32_t v47; // 0xdab9
    struct mg_context_1 * v48; // 0xdcd9
    int32_t v49; // 0xddd5
    int32_t v50; // 0xddd6
    int32_t v51; // 0xe491
    int16_t v52; // 0xffff
    // 0xab5c
    if (index > 4) {
        // 0xabe4
        exit(1);
        // UNREACHABLE
    }
    // 0xab6c
    int32_t v53; // 0xab74
    int32_t v54; // 0xab6e
    ((int32_t (*)(int32_t))v54)((int32_t)&v53);
    int32_t v55; // 0x94cc
    memset((char *)((int32_t)&v55 | (int32_t)"1\r\nSERVER: Linux/2.6 UPnP/1.0 quick_ssdp/1.0\r\nST: urn:dial-multiscreen-org:service:dial:1\r\nUSN: uuid:%s::urn:dial-multiscreen-org:service:dial:1\r\n\r\n"), 0, 256);
    int32_t v56; // 0xab9a
    setDataDir((char *)v56);
    int32_t v57; // 0xabf0
    ((int32_t (*)())v57)();
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/dial/src/server/main.c
// Address range: 0xabf4 - 0xaead
// Line range:    768 - 841
int main(int argc, char ** argv) {
    int32_t v1; // 0x19000
    int32_t v2; // 0x19004
    int32_t v3; // 0x19008
    int32_t v4; // 0x192dc
    int32_t v5; // 0x193b8
    char * v6; // 0x193bc
    struct mg_connection_1 * v7; // 0x1a9e8
    int32_t v8; // 0x1aaac
    char * v9; // 0x1bb0c
    int32_t v10; // 0x1bc07
    char * v11; // 0x1bc0c
    char * v12; // 0x1bc10
    char * v13; // 0x1bc14
    int32_t v14; // 0x1bc18
    char * v15; // 0x1bc1c
    char * v16; // 0x1bc20
    char * v17; // 0x1bc24
    int32_t v18; // 0x1bc28
    char * v19; // 0x1bc2c
    int32_t v20; // 0x1bd07
    char * v21; // 0x1bd0c
    char * v22; // 0x1bd10
    char * v23; // 0x1bd14
    int16_t * v24; // 0x1bd18
    char * v25; // 0x1bd1a
    int32_t v26; // 0x8912
    int32_t v27; // 0x92e8
    int32_t v28; // 0x9340
    int32_t v29; // 0x9348
    int32_t v30; // 0x934c
    int32_t v31; // 0x9350
    int32_t v32; // 0x9358
    int32_t v33; // 0x935c
    int32_t v34; // 0x9360
    int32_t v35; // 0x9364
    int32_t v36; // 0x9368
    int32_t v37; // 0x93a4
    int32_t v38; // 0x93b4
    int32_t v39; // 0x93c0
    int32_t v40; // 0x94cc
    int32_t v41; // 0xab74
    struct mg_context_1 * v42; // 0xbc49
    int32_t v43; // 0xc2a3
    int32_t v44; // 0xd8b1
    int32_t v45; // 0xdab9
    struct mg_context_1 * v46; // 0xdcd9
    int32_t v47; // 0xddd5
    int32_t v48; // 0xddd6
    int32_t v49; // 0xe491
    int16_t v50; // 0xffff
    // 0xabf4
    int32_t v51;
    int32_t longLen = v51; // bp-24
    int32_t v52;
    int32_t shortLen = v52; // bp-20
    int32_t v53;
    int32_t numberOfOptions = v53; // bp-16
    int32_t v54;
    int32_t i = v54; // bp-12
    srand(time(NULL));
    int32_t mutex; // 0x1be18
    pthread_mutex_init(&mutex, NULL);
    int32_t cond; // 0x1be30
    pthread_cond_init(&cond, NULL);
    pthread_mutex_init(&lock_message, NULL);
    int32_t v55; // 0xac36
    i = isAppRunning((char *)v55, NULL);
    int32_t v56; // 0xac4c
    int32_t v57; // 0xac56
    i = isAppRunning((char *)v56, (char *)v57);
    int32_t v58; // 0x96cc
    int32_t v59; // 0xac6c
    setValue((char *)v59, (char *)((int32_t)&v58 | (int32_t)"1\r\nSERVER: Linux/2.6 UPnP/1.0 quick_ssdp/1.0\r\nST: urn:dial-multiscreen-org:service:dial:1\r\nUSN: uuid:%s::urn:dial-multiscreen-org:service:dial:1\r\n\r\n"));
    int32_t v60; // 0xac84
    setValue((char *)v60, spModelName);
    int32_t v61; // 0xac9c
    setValue((char *)v61, spUuid);
    int32_t v62; // 0x95cc
    int32_t v63; // 0xacb4
    setValue((char *)v63, (char *)((int32_t)&v62 | (int32_t)"1\r\nSERVER: Linux/2.6 UPnP/1.0 quick_ssdp/1.0\r\nST: urn:dial-multiscreen-org:service:dial:1\r\nUSN: uuid:%s::urn:dial-multiscreen-org:service:dial:1\r\n\r\n"));
    int32_t v64; // 0xaccc
    setDataDir((char *)v64);
    api_sockIPC_get_channel(0, 0, (int32_t)"T-DIAL", 1);
    int32_t v65; // 0xacfa
    if (v65 != 0) {
        // 0xad00
        int32_t v66; // 0xad2e
        api_sockIPC_event_send(v66, 1, 1, 0);
        int32_t v67; // 0xad44
        api_sockIPC_start_channel(v67);
        // branch -> 0xad5c
    }
    while (true) {
        // 0xad5c
        i = 1;
        numberOfOptions = 4;
        // branch -> 0xad5c
        while (true) {
            // 0xad5c
            int32_t str; // 0xad72
            shortLen = strlen((char *)str);
            int32_t str2; // 0xad98
            longLen = strlen((char *)str2);
            int32_t str3; // 0xadb2
            int32_t str4; // 0xadca
            if (strncmp((char *)str3, (char *)str4, shortLen) != 0) {
                // 0xadde
                int32_t str5; // 0xadea
                int32_t str6; // 0xae04
                if (strncmp((char *)str5, (char *)str6, longLen) != 0) {
                  lab_0xae42_2:;
                    int32_t v68 = numberOfOptions - 1; // 0xae46
                    numberOfOptions = v68;
                    if (v68 <= 0xffffffff) {
                        // break -> 0xae54
                        break;
                    }
                    // continue -> 0xad5c
                    continue;
                }
                // 0xae18
                if (i + 1 >= argc) {
                    goto lab_0xae42_2;
                }
              lab_0xae54:;
                // 0xae54
                int32_t v69; // 0xae34
                processOption(numberOfOptions, (char *)v69);
                if (numberOfOptions <= -1) {
                    // 0xae5c
                    printUsage();
                    exit(1);
                    // UNREACHABLE
                }
                // 0xae66
                // branch -> 0xad5c
                break;
            }
            // 0xae18
            if (i + 1 < argc) {
                goto lab_0xae54;
            }
            goto lab_0xae42_2;
        }
        // 0xae54
        // branch -> 0xae5c
        // 0xae5c
        printUsage();
        exit(1);
        // UNREACHABLE
    }
}

// Address range: 0xaeae - 0xaeb3
int32_t function_aeae(int32_t result) {
    int32_t v1; // 0x19000
    int32_t v2; // 0x19004
    int32_t v3; // 0x19008
    int32_t v4; // 0x192dc
    int32_t v5; // 0x193b8
    char * v6; // 0x193bc
    struct mg_connection_1 * v7; // 0x1a9e8
    int32_t v8; // 0x1aaac
    char * v9; // 0x1bb0c
    int32_t v10; // 0x1bc07
    char * v11; // 0x1bc0c
    char * v12; // 0x1bc10
    char * v13; // 0x1bc14
    int32_t v14; // 0x1bc18
    char * v15; // 0x1bc1c
    char * v16; // 0x1bc20
    char * v17; // 0x1bc24
    int32_t v18; // 0x1bc28
    char * v19; // 0x1bc2c
    int32_t v20; // 0x1bd07
    char * v21; // 0x1bd0c
    char * v22; // 0x1bd10
    char * v23; // 0x1bd14
    int16_t * v24; // 0x1bd18
    char * v25; // 0x1bd1a
    int32_t v26; // 0x1be18
    int32_t v27; // 0x1be30
    int32_t v28; // 0x8912
    int32_t v29; // 0x92e8
    int32_t v30; // 0x9340
    int32_t v31; // 0x9348
    int32_t v32; // 0x934c
    int32_t v33; // 0x9350
    int32_t v34; // 0x9358
    int32_t v35; // 0x935c
    int32_t v36; // 0x9360
    int32_t v37; // 0x9364
    int32_t v38; // 0x9368
    int32_t v39; // 0x93a4
    int32_t v40; // 0x93b4
    int32_t v41; // 0x93c0
    int32_t v42; // 0x94cc
    int32_t v43; // 0x95cc
    int32_t v44; // 0x96cc
    int32_t v45; // 0xab74
    struct mg_context_1 * v46; // 0xbc49
    int32_t v47; // 0xc2a3
    int32_t v48; // 0xd8b1
    int32_t v49; // 0xdab9
    struct mg_context_1 * v50; // 0xdcd9
    int32_t v51; // 0xddd5
    int32_t v52; // 0xddd6
    int32_t v53; // 0xe491
    int16_t v54; // 0xffff
    // 0xaeae
    return result;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/dial/src/server/dial_server.c
// Address range: 0xaeb4 - 0xaecf
// Line range:    71 - 73
void ds_lock(struct DIALServer__1 * ds) {
    int32_t v1; // 0x19000
    int32_t v2; // 0x19004
    int32_t v3; // 0x19008
    int32_t v4; // 0x192dc
    int32_t v5; // 0x193b8
    char * v6; // 0x193bc
    struct mg_connection_1 * v7; // 0x1a9e8
    int32_t v8; // 0x1aaac
    char * v9; // 0x1bb0c
    int32_t v10; // 0x1bc07
    char * v11; // 0x1bc0c
    char * v12; // 0x1bc10
    char * v13; // 0x1bc14
    int32_t v14; // 0x1bc18
    char * v15; // 0x1bc1c
    char * v16; // 0x1bc20
    char * v17; // 0x1bc24
    int32_t v18; // 0x1bc28
    char * v19; // 0x1bc2c
    int32_t v20; // 0x1bd07
    char * v21; // 0x1bd0c
    char * v22; // 0x1bd10
    char * v23; // 0x1bd14
    int16_t * v24; // 0x1bd18
    char * v25; // 0x1bd1a
    int32_t v26; // 0x1be18
    int32_t v27; // 0x1be30
    int32_t v28; // 0x8912
    int32_t v29; // 0x92e8
    int32_t v30; // 0x9340
    int32_t v31; // 0x9348
    int32_t v32; // 0x934c
    int32_t v33; // 0x9350
    int32_t v34; // 0x9358
    int32_t v35; // 0x935c
    int32_t v36; // 0x9360
    int32_t v37; // 0x9364
    int32_t v38; // 0x9368
    int32_t v39; // 0x93a4
    int32_t v40; // 0x93b4
    int32_t v41; // 0x93c0
    int32_t v42; // 0x94cc
    int32_t v43; // 0x95cc
    int32_t v44; // 0x96cc
    int32_t v45; // 0xab74
    struct mg_context_1 * v46; // 0xbc49
    int32_t v47; // 0xc2a3
    int32_t v48; // 0xd8b1
    int32_t v49; // 0xdab9
    struct mg_context_1 * v50; // 0xdcd9
    int32_t v51; // 0xddd5
    int32_t v52; // 0xddd6
    int32_t v53; // 0xe491
    int16_t v54; // 0xffff
    // 0xaeb4
    pthread_mutex_lock((int32_t *)((int32_t)ds + 8));
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/dial/src/server/dial_server.c
// Address range: 0xaed0 - 0xaeeb
// Line range:    75 - 77
void ds_unlock(struct DIALServer__1 * ds) {
    int32_t v1; // 0x19000
    int32_t v2; // 0x19004
    int32_t v3; // 0x19008
    int32_t v4; // 0x192dc
    int32_t v5; // 0x193b8
    char * v6; // 0x193bc
    struct mg_connection_1 * v7; // 0x1a9e8
    int32_t v8; // 0x1aaac
    char * v9; // 0x1bb0c
    int32_t v10; // 0x1bc07
    char * v11; // 0x1bc0c
    char * v12; // 0x1bc10
    char * v13; // 0x1bc14
    int32_t v14; // 0x1bc18
    char * v15; // 0x1bc1c
    char * v16; // 0x1bc20
    char * v17; // 0x1bc24
    int32_t v18; // 0x1bc28
    char * v19; // 0x1bc2c
    int32_t v20; // 0x1bd07
    char * v21; // 0x1bd0c
    char * v22; // 0x1bd10
    char * v23; // 0x1bd14
    int16_t * v24; // 0x1bd18
    char * v25; // 0x1bd1a
    int32_t v26; // 0x1be18
    int32_t v27; // 0x1be30
    int32_t v28; // 0x8912
    int32_t v29; // 0x92e8
    int32_t v30; // 0x9340
    int32_t v31; // 0x9348
    int32_t v32; // 0x934c
    int32_t v33; // 0x9350
    int32_t v34; // 0x9358
    int32_t v35; // 0x935c
    int32_t v36; // 0x9360
    int32_t v37; // 0x9364
    int32_t v38; // 0x9368
    int32_t v39; // 0x93a4
    int32_t v40; // 0x93b4
    int32_t v41; // 0x93c0
    int32_t v42; // 0x94cc
    int32_t v43; // 0x95cc
    int32_t v44; // 0x96cc
    int32_t v45; // 0xab74
    struct mg_context_1 * v46; // 0xbc49
    int32_t v47; // 0xc2a3
    int32_t v48; // 0xd8b1
    int32_t v49; // 0xdab9
    struct mg_context_1 * v50; // 0xdcd9
    int32_t v51; // 0xddd5
    int32_t v52; // 0xddd6
    int32_t v53; // 0xe491
    int16_t v54; // 0xffff
    // 0xaed0
    pthread_mutex_unlock((int32_t *)((int32_t)ds + 8));
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/dial/src/server/dial_server.c
// Address range: 0xaeec - 0xaf37
// Line range:    81 - 91
struct DIALApp_ ** find_app(struct DIALServer__1 * ds, char * app_name) {
    int32_t v1; // 0x19000
    int32_t v2; // 0x19004
    int32_t v3; // 0x19008
    int32_t v4; // 0x192dc
    int32_t v5; // 0x193b8
    char * v6; // 0x193bc
    struct mg_connection_1 * v7; // 0x1a9e8
    int32_t v8; // 0x1aaac
    char * v9; // 0x1bb0c
    int32_t v10; // 0x1bc07
    char * v11; // 0x1bc0c
    char * v12; // 0x1bc10
    char * v13; // 0x1bc14
    int32_t v14; // 0x1bc18
    char * v15; // 0x1bc1c
    char * v16; // 0x1bc20
    char * v17; // 0x1bc24
    int32_t v18; // 0x1bc28
    char * v19; // 0x1bc2c
    int32_t v20; // 0x1bd07
    char * v21; // 0x1bd0c
    char * v22; // 0x1bd10
    char * v23; // 0x1bd14
    int16_t * v24; // 0x1bd18
    char * v25; // 0x1bd1a
    int32_t v26; // 0x1be18
    int32_t v27; // 0x1be30
    int32_t v28; // 0x8912
    int32_t v29; // 0x92e8
    int32_t v30; // 0x9340
    int32_t v31; // 0x9348
    int32_t v32; // 0x934c
    int32_t v33; // 0x9350
    int32_t v34; // 0x9358
    int32_t v35; // 0x935c
    int32_t v36; // 0x9360
    int32_t v37; // 0x9364
    int32_t v38; // 0x9368
    int32_t v39; // 0x93a4
    int32_t v40; // 0x93b4
    int32_t v41; // 0x93c0
    int32_t v42; // 0x94cc
    int32_t v43; // 0x95cc
    int32_t v44; // 0x96cc
    int32_t v45; // 0xab74
    struct mg_context_1 * v46; // 0xbc49
    int32_t v47; // 0xc2a3
    int32_t v48; // 0xd8b1
    int32_t v49; // 0xdab9
    struct mg_context_1 * v50; // 0xdcd9
    int32_t v51; // 0xddd5
    int32_t v52; // 0xddd6
    int32_t v53; // 0xe491
    int16_t v54; // 0xffff
    // 0xaeec
    struct DIALApp_ ** v55;
    struct DIALApp_ ** ret = v55; // bp-16
    struct DIALApp_ * v56;
    struct DIALApp_ * app = v56; // bp-12
    struct DIALApp_ ** result = (struct DIALApp_ **)((int32_t)ds + 4);
    ret = result;
    int32_t v57;
    app = (struct DIALApp_ *)v57;
    if (v57 == 0) {
        // 0xaf2a
        return result;
    }
    // 0xaf04
    int32_t str; // 0xaf0617
    if (strcmp(app_name, (char *)str) == 0) {
        // 0xaf04
        // branch -> 0xaf2a
    } else {
        while (true) {
            struct DIALApp_ * v58 = app; // 0xaf16
            ret = &v58->e0;
            int32_t v59 = *(int32_t *)v58;
            app = (struct DIALApp_ *)v59;
            if (v59 != 0) {
                // 0xaf16
                int32_t str2; // 0xaf06
                if (strcmp(app_name, (char *)str2) == 0) {
                    // break -> 0xaf04
                    break;
                }
                // continue -> 0xaf16
                continue;
            }
            // 0xaf2a
            return &v58->e0;
        }
        // 0xaf04
        // branch -> 0xaf2a
    }
    // 0xaf2a
    return ret;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/dial/src/server/dial_server.c
// Address range: 0xc048 - 0xc073
// Line range:    481 - 485
struct DIALServer__1 * DIAL_create(void) {
    int32_t v1; // 0x19000
    int32_t v2; // 0x19004
    int32_t v3; // 0x19008
    int32_t v4; // 0x192dc
    int32_t v5; // 0x193b8
    char * v6; // 0x193bc
    struct mg_connection_1 * v7; // 0x1a9e8
    int32_t v8; // 0x1aaac
    char * v9; // 0x1bb0c
    int32_t v10; // 0x1bc07
    char * v11; // 0x1bc0c
    char * v12; // 0x1bc10
    char * v13; // 0x1bc14
    int32_t v14; // 0x1bc18
    char * v15; // 0x1bc1c
    char * v16; // 0x1bc20
    char * v17; // 0x1bc24
    int32_t v18; // 0x1bc28
    char * v19; // 0x1bc2c
    int32_t v20; // 0x1bd07
    char * v21; // 0x1bd0c
    char * v22; // 0x1bd10
    char * v23; // 0x1bd14
    int16_t * v24; // 0x1bd18
    char * v25; // 0x1bd1a
    int32_t v26; // 0x1be18
    int32_t v27; // 0x1be30
    int32_t v28; // 0x8912
    int32_t v29; // 0x92e8
    int32_t v30; // 0x9340
    int32_t v31; // 0x9348
    int32_t v32; // 0x934c
    int32_t v33; // 0x9350
    int32_t v34; // 0x9358
    int32_t v35; // 0x935c
    int32_t v36; // 0x9360
    int32_t v37; // 0x9364
    int32_t v38; // 0x9368
    int32_t v39; // 0x93a4
    int32_t v40; // 0x93b4
    int32_t v41; // 0x93c0
    int32_t v42; // 0x94cc
    int32_t v43; // 0x95cc
    int32_t v44; // 0x96cc
    int32_t v45; // 0xab74
    struct mg_context_1 * v46; // 0xbc49
    int32_t v47; // 0xc2a3
    int32_t v48; // 0xd8b1
    int32_t v49; // 0xdab9
    struct mg_context_1 * v50; // 0xdcd9
    int32_t v51; // 0xddd5
    int32_t v52; // 0xddd6
    int32_t v53; // 0xe491
    int16_t v54; // 0xffff
    // 0xc048
    struct DIALServer__1 * v55;
    struct DIALServer__1 * ds = v55; // bp-12
    char * mem = calloc(1, 32); // 0xc052
    ds = (struct DIALServer__1 *)mem;
    pthread_mutex_init((int32_t *)((int32_t)mem + 8), NULL);
    return ds;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/dial/src/server/dial_server.c
// Address range: 0xc074 - 0xc09b
// Line range:    487 - 489
void DIAL_start(struct DIALServer__1 * ds) {
    int32_t v1; // 0x19000
    int32_t v2; // 0x19004
    int32_t v3; // 0x19008
    int32_t v4; // 0x192dc
    int32_t v5; // 0x193b8
    char * v6; // 0x193bc
    struct mg_connection_1 * v7; // 0x1a9e8
    int32_t v8; // 0x1aaac
    char * v9; // 0x1bb0c
    int32_t v10; // 0x1bc07
    char * v11; // 0x1bc0c
    char * v12; // 0x1bc10
    char * v13; // 0x1bc14
    int32_t v14; // 0x1bc18
    char * v15; // 0x1bc1c
    char * v16; // 0x1bc20
    char * v17; // 0x1bc24
    int32_t v18; // 0x1bc28
    char * v19; // 0x1bc2c
    int32_t v20; // 0x1bd07
    char * v21; // 0x1bd0c
    char * v22; // 0x1bd10
    char * v23; // 0x1bd14
    int16_t * v24; // 0x1bd18
    char * v25; // 0x1bd1a
    int32_t v26; // 0x1be18
    int32_t v27; // 0x1be30
    int32_t v28; // 0x8912
    int32_t v29; // 0x92e8
    int32_t v30; // 0x9340
    int32_t v31; // 0x9348
    int32_t v32; // 0x934c
    int32_t v33; // 0x9350
    int32_t v34; // 0x9358
    int32_t v35; // 0x935c
    int32_t v36; // 0x9360
    int32_t v37; // 0x9364
    int32_t v38; // 0x9368
    int32_t v39; // 0x93a4
    int32_t v40; // 0x93b4
    int32_t v41; // 0x93c0
    int32_t v42; // 0x94cc
    int32_t v43; // 0x95cc
    int32_t v44; // 0x96cc
    int32_t v45; // 0xab74
    int32_t v46; // 0xc2a3
    int32_t v47; // 0xd8b1
    int32_t v48; // 0xdab9
    struct mg_context_1 * v49; // 0xdcd9
    int32_t v50; // 0xddd6
    int32_t v51; // 0xe491
    int16_t v52; // 0xffff
    struct mg_context_1 * v53; // 0xbc49
    int32_t v54; // 0xddd5
    struct mg_context_1 * v55 = mg_start((char * (*)(int32_t, struct mg_connection_1 *, struct mg_request_info_1 *))&v53, (char *)ds, (int32_t)&v54); // 0xc08a
    *(int32_t *)ds = (int32_t)v55;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/dial/src/server/dial_server.c
// Address range: 0xc09c - 0xc0bf
// Line range:    491 - 494
void DIAL_stop(struct DIALServer__1 * ds) {
    int32_t v1; // 0x19000
    int32_t v2; // 0x19004
    int32_t v3; // 0x19008
    int32_t v4; // 0x192dc
    int32_t v5; // 0x193b8
    char * v6; // 0x193bc
    struct mg_connection_1 * v7; // 0x1a9e8
    int32_t v8; // 0x1aaac
    char * v9; // 0x1bb0c
    int32_t v10; // 0x1bc07
    char * v11; // 0x1bc0c
    char * v12; // 0x1bc10
    char * v13; // 0x1bc14
    int32_t v14; // 0x1bc18
    char * v15; // 0x1bc1c
    char * v16; // 0x1bc20
    char * v17; // 0x1bc24
    int32_t v18; // 0x1bc28
    char * v19; // 0x1bc2c
    int32_t v20; // 0x1bd07
    char * v21; // 0x1bd0c
    char * v22; // 0x1bd10
    char * v23; // 0x1bd14
    int16_t * v24; // 0x1bd18
    char * v25; // 0x1bd1a
    int32_t v26; // 0x1be18
    int32_t v27; // 0x1be30
    int32_t v28; // 0x8912
    int32_t v29; // 0x92e8
    int32_t v30; // 0x9340
    int32_t v31; // 0x9348
    int32_t v32; // 0x934c
    int32_t v33; // 0x9350
    int32_t v34; // 0x9358
    int32_t v35; // 0x935c
    int32_t v36; // 0x9360
    int32_t v37; // 0x9364
    int32_t v38; // 0x9368
    int32_t v39; // 0x93a4
    int32_t v40; // 0x93b4
    int32_t v41; // 0x93c0
    int32_t v42; // 0x94cc
    int32_t v43; // 0x95cc
    int32_t v44; // 0x96cc
    int32_t v45; // 0xab74
    struct mg_context_1 * v46; // 0xbc49
    int32_t v47; // 0xc2a3
    int32_t v48; // 0xd8b1
    int32_t v49; // 0xdab9
    struct mg_context_1 * v50; // 0xdcd9
    int32_t v51; // 0xddd5
    int32_t v52; // 0xddd6
    int32_t v53; // 0xe491
    int16_t v54; // 0xffff
    // 0xc09c
    mg_stop((struct mg_context_1 *)*(int32_t *)ds);
    pthread_mutex_destroy((int32_t *)((int32_t)ds + 8));
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/dial/src/server/dial_server.c
// Address range: 0xc0c0 - 0xc103
// Line range:    496 - 503
int16_t DIAL_get_port(struct DIALServer__1 * ds) {
    int32_t v1; // 0x19000
    int32_t v2; // 0x19004
    int32_t v3; // 0x19008
    int32_t v4; // 0x192dc
    int32_t v5; // 0x193b8
    char * v6; // 0x193bc
    struct mg_connection_1 * v7; // 0x1a9e8
    int32_t v8; // 0x1aaac
    char * v9; // 0x1bb0c
    int32_t v10; // 0x1bc07
    char * v11; // 0x1bc0c
    char * v12; // 0x1bc10
    char * v13; // 0x1bc14
    int32_t v14; // 0x1bc18
    char * v15; // 0x1bc1c
    char * v16; // 0x1bc20
    char * v17; // 0x1bc24
    int32_t v18; // 0x1bc28
    char * v19; // 0x1bc2c
    int32_t v20; // 0x1bd07
    char * v21; // 0x1bd0c
    char * v22; // 0x1bd10
    char * v23; // 0x1bd14
    int16_t * v24; // 0x1bd18
    char * v25; // 0x1bd1a
    int32_t v26; // 0x1be18
    int32_t v27; // 0x1be30
    int32_t v28; // 0x8912
    int32_t v29; // 0x92e8
    int32_t v30; // 0x9340
    int32_t v31; // 0x9348
    int32_t v32; // 0x934c
    int32_t v33; // 0x9350
    int32_t v34; // 0x9358
    int32_t v35; // 0x935c
    int32_t v36; // 0x9360
    int32_t v37; // 0x9364
    int32_t v38; // 0x9368
    int32_t v39; // 0x93a4
    int32_t v40; // 0x93b4
    int32_t v41; // 0x93c0
    int32_t v42; // 0x94cc
    int32_t v43; // 0x95cc
    int32_t v44; // 0x96cc
    int32_t v45; // 0xab74
    struct mg_context_1 * v46; // 0xbc49
    int32_t v47; // 0xc2a3
    int32_t v48; // 0xd8b1
    int32_t v49; // 0xdab9
    struct mg_context_1 * v50; // 0xdcd9
    int32_t v51; // 0xddd5
    int32_t v52; // 0xddd6
    int32_t v53; // 0xe491
    int16_t v54; // 0xffff
    struct sockaddr v55;
    int32_t v56;
    int32_t len = v56; // bp-28
    len = 16;
    int32_t v57 = *(int32_t *)ds; // 0xc0ce
    int32_t result;
    if (mg_get_listen_addr((struct mg_context_1 *)v57, (struct sockaddr_1 *)&v55, &len) != 0) {
        // 0xc0ec
        int16_t net_short; // 0xc0f0
        result = ntohs(net_short);
        // branch -> 0xc0fa
    } else {
        result = 0;
    }
    // 0xc0fa
    return result;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/dial/src/server/dial_server.c
// Address range: 0xc104 - 0xc1db
// Line range:    505 - 537
int32_t DIAL_register_app(struct DIALServer__1 * ds, char * app_name, struct DIALAppCallbacks_1 * callbacks, char * user_data, int32_t useAdditionalData, char * corsAllowedOrigin) {
    int32_t v1; // 0x19000
    int32_t v2; // 0x19004
    int32_t v3; // 0x19008
    int32_t v4; // 0x192dc
    int32_t v5; // 0x193b8
    char * v6; // 0x193bc
    struct mg_connection_1 * v7; // 0x1a9e8
    int32_t v8; // 0x1aaac
    char * v9; // 0x1bb0c
    int32_t v10; // 0x1bc07
    char * v11; // 0x1bc0c
    char * v12; // 0x1bc10
    char * v13; // 0x1bc14
    int32_t v14; // 0x1bc18
    char * v15; // 0x1bc1c
    char * v16; // 0x1bc20
    char * v17; // 0x1bc24
    int32_t v18; // 0x1bc28
    char * v19; // 0x1bc2c
    int32_t v20; // 0x1bd07
    char * v21; // 0x1bd0c
    char * v22; // 0x1bd10
    char * v23; // 0x1bd14
    int16_t * v24; // 0x1bd18
    char * v25; // 0x1bd1a
    int32_t v26; // 0x1be18
    int32_t v27; // 0x1be30
    int32_t v28; // 0x8912
    int32_t v29; // 0x92e8
    int32_t v30; // 0x9340
    int32_t v31; // 0x9348
    int32_t v32; // 0x934c
    int32_t v33; // 0x9350
    int32_t v34; // 0x9358
    int32_t v35; // 0x935c
    int32_t v36; // 0x9360
    int32_t v37; // 0x9364
    int32_t v38; // 0x9368
    int32_t v39; // 0x93a4
    int32_t v40; // 0x93b4
    int32_t v41; // 0x93c0
    int32_t v42; // 0x94cc
    int32_t v43; // 0x95cc
    int32_t v44; // 0x96cc
    int32_t v45; // 0xab74
    struct mg_context_1 * v46; // 0xbc49
    int32_t v47; // 0xc2a3
    int32_t v48; // 0xd8b1
    int32_t v49; // 0xdab9
    struct mg_context_1 * v50; // 0xdcd9
    int32_t v51; // 0xddd5
    int32_t v52; // 0xddd6
    int32_t v53; // 0xe491
    int16_t v54; // 0xffff
    // 0xc104
    struct DIALApp_ * v55;
    struct DIALApp_ * app = v55; // bp-20
    struct DIALApp_ ** v56;
    struct DIALApp_ ** ptr = v56; // bp-16
    int32_t v57;
    int32_t ret = v57; // bp-12
    ds_lock(ds);
    struct DIALApp_ ** v58 = find_app(ds, app_name); // 0xc11c
    ptr = v58;
    int32_t v59;
    if (*(int32_t *)v58 == 0) {
        // 0xc136
        app = (struct DIALApp_ *)malloc(0x112c);
        strdup(app_name);
        strdup(app_name);
        *(int32_t *)app = *(int32_t *)ptr;
        int32_t v60; // 0xc178
        retrieve_dial_data((char *)v60);
        retrieve_dial_data((char *)v60);
        if (corsAllowedOrigin != NULL) {
            // 0xc1a4
            if (strlen(corsAllowedOrigin) <= 255) {
                // 0xc1b0
                strcpy((char *)((int32_t)app + 0x102c), corsAllowedOrigin);
                // branch -> 0xc1c0
            }
        }
        // 0xc1c0
        *(int32_t *)ptr = (int32_t)app;
        v59 = 1;
        // branch -> 0xc1ca
    } else {
        // 0xc12a
        ds_unlock(ds);
        v59 = 0;
        // branch -> 0xc1ca
    }
    // 0xc1ca
    ret = v59;
    ds_unlock(ds);
    return ret;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/dial/src/server/mongoose.c
// Address range: 0xc270 - 0xc2b3
// Line range:    125 - 129
char * call_user(struct mg_connection_1 * conn, int32_t event) {
    int32_t v1; // 0x19000
    int32_t v2; // 0x19004
    int32_t v3; // 0x19008
    int32_t v4; // 0x192dc
    int32_t v5; // 0x193b8
    char * v6; // 0x193bc
    struct mg_connection_1 * v7; // 0x1a9e8
    int32_t v8; // 0x1aaac
    char * v9; // 0x1bb0c
    int32_t v10; // 0x1bc07
    char * v11; // 0x1bc0c
    char * v12; // 0x1bc10
    char * v13; // 0x1bc14
    int32_t v14; // 0x1bc18
    char * v15; // 0x1bc1c
    char * v16; // 0x1bc20
    char * v17; // 0x1bc24
    int32_t v18; // 0x1bc28
    char * v19; // 0x1bc2c
    int32_t v20; // 0x1bd07
    char * v21; // 0x1bd0c
    char * v22; // 0x1bd10
    char * v23; // 0x1bd14
    int16_t * v24; // 0x1bd18
    char * v25; // 0x1bd1a
    int32_t v26; // 0x1be18
    int32_t v27; // 0x1be30
    int32_t v28; // 0x8912
    int32_t v29; // 0x92e8
    int32_t v30; // 0x9340
    int32_t v31; // 0x9348
    int32_t v32; // 0x934c
    int32_t v33; // 0x9350
    int32_t v34; // 0x9358
    int32_t v35; // 0x935c
    int32_t v36; // 0x9360
    int32_t v37; // 0x9364
    int32_t v38; // 0x9368
    int32_t v39; // 0x93a4
    int32_t v40; // 0x93b4
    int32_t v41; // 0x93c0
    int32_t v42; // 0x94cc
    int32_t v43; // 0x95cc
    int32_t v44; // 0x96cc
    int32_t v45; // 0xab74
    struct mg_context_1 * v46; // 0xbc49
    int32_t v47; // 0xc2a3
    int32_t v48; // 0xd8b1
    int32_t v49; // 0xdab9
    struct mg_context_1 * v50; // 0xdcd9
    int32_t v51; // 0xddd5
    int32_t v52; // 0xddd6
    int32_t v53; // 0xe491
    int16_t v54; // 0xffff
    int32_t v55 = (int32_t)conn; // 0xc270_0
    int32_t v56; // 0xc280
    *(int32_t *)conn = v56;
    int32_t v57; // 0xc28c
    if (v57 != 0) {
        // 0xc292
        int32_t v58; // 0xc298
        ((int32_t (*)(int32_t, int32_t, int32_t, int32_t))(v58 & -2))(event, v55, v55, v58);
        // branch -> 0xc2a8
    } else {
        event = 0;
    }
    // 0xc2a8
    return (char *)event;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/dial/src/server/mongoose.c
// Address range: 0xc2b4 - 0xc333
// Line range:    132 - 148
void cry(struct mg_connection_1 * conn, char * fmt, ...) {
    struct __va_list v1;
    char str[8192];
    int32_t v2; // 0x19000
    int32_t v3; // 0x19004
    int32_t v4; // 0x19008
    int32_t v5; // 0x192dc
    int32_t v6; // 0x193b8
    char * v7; // 0x193bc
    struct mg_connection_1 * v8; // 0x1a9e8
    int32_t v9; // 0x1aaac
    char * v10; // 0x1bb0c
    int32_t v11; // 0x1bc07
    char * v12; // 0x1bc0c
    char * v13; // 0x1bc10
    char * v14; // 0x1bc14
    int32_t v15; // 0x1bc18
    char * v16; // 0x1bc1c
    char * v17; // 0x1bc20
    char * v18; // 0x1bc24
    int32_t v19; // 0x1bc28
    char * v20; // 0x1bc2c
    int32_t v21; // 0x1bd07
    char * v22; // 0x1bd0c
    char * v23; // 0x1bd10
    char * v24; // 0x1bd14
    int16_t * v25; // 0x1bd18
    char * v26; // 0x1bd1a
    int32_t v27; // 0x1be18
    int32_t v28; // 0x1be30
    int32_t v29; // 0x8912
    int32_t v30; // 0x92e8
    int32_t v31; // 0x9340
    int32_t v32; // 0x9348
    int32_t v33; // 0x934c
    int32_t v34; // 0x9350
    int32_t v35; // 0x9358
    int32_t v36; // 0x935c
    int32_t v37; // 0x9360
    int32_t v38; // 0x9364
    int32_t v39; // 0x9368
    int32_t v40; // 0x93a4
    int32_t v41; // 0x93b4
    int32_t v42; // 0x93c0
    int32_t v43; // 0x94cc
    int32_t v44; // 0x95cc
    int32_t v45; // 0x96cc
    int32_t v46; // 0xab74
    struct mg_context_1 * v47; // 0xbc49
    int32_t v48; // 0xc2a3
    int32_t v49; // 0xd8b1
    int32_t v50; // 0xdab9
    struct mg_context_1 * v51; // 0xdcd9
    int32_t v52; // 0xddd5
    int32_t v53; // 0xddd6
    int32_t v54; // 0xe491
    int16_t v55; // 0xffff
    int32_t v56;
    v1.e0 = (char *)&v56;
    vsnprintf(str, 0x2000, fmt, (int32_t)&v56);
    int32_t v57 = (int32_t)call_user(conn, 2); // 0xc312_4
    int32_t v58; // 0xc32c
    ((int32_t (*)(int32_t, int32_t, int32_t))(v58 & -2))(v57, 0, (int32_t)conn);
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/dial/src/server/mongoose.c
// Address range: 0xc334 - 0xc35f
// Line range:    152 - 156
struct mg_connection_1 * fc(struct mg_context_1 * ctx2) {
    int32_t v1; // 0x19000
    int32_t v2; // 0x19004
    int32_t v3; // 0x19008
    int32_t v4; // 0x192dc
    int32_t v5; // 0x193b8
    char * v6; // 0x193bc
    char * v7; // 0x1bb0c
    int32_t v8; // 0x1bc07
    char * v9; // 0x1bc0c
    char * v10; // 0x1bc10
    char * v11; // 0x1bc14
    int32_t v12; // 0x1bc18
    char * v13; // 0x1bc1c
    char * v14; // 0x1bc20
    char * v15; // 0x1bc24
    int32_t v16; // 0x1bc28
    char * v17; // 0x1bc2c
    int32_t v18; // 0x1bd07
    char * v19; // 0x1bd0c
    char * v20; // 0x1bd10
    char * v21; // 0x1bd14
    int16_t * v22; // 0x1bd18
    char * v23; // 0x1bd1a
    int32_t v24; // 0x1be18
    int32_t v25; // 0x1be30
    int32_t v26; // 0x8912
    int32_t v27; // 0x92e8
    int32_t v28; // 0x9340
    int32_t v29; // 0x9348
    int32_t v30; // 0x934c
    int32_t v31; // 0x9350
    int32_t v32; // 0x9358
    int32_t v33; // 0x935c
    int32_t v34; // 0x9360
    int32_t v35; // 0x9364
    int32_t v36; // 0x9368
    int32_t v37; // 0x93a4
    int32_t v38; // 0x93b4
    int32_t v39; // 0x93c0
    int32_t v40; // 0x94cc
    int32_t v41; // 0x95cc
    int32_t v42; // 0x96cc
    int32_t v43; // 0xab74
    struct mg_context_1 * v44; // 0xbc49
    int32_t v45; // 0xc2a3
    int32_t v46; // 0xd8b1
    int32_t v47; // 0xdab9
    struct mg_context_1 * v48; // 0xdcd9
    int32_t v49; // 0xddd5
    int32_t v50; // 0xddd6
    int32_t v51; // 0xe491
    int16_t v52; // 0xffff
    int32_t v53 = (int32_t)ctx2; // 0x1aaac
    struct mg_connection_1 * v54; // 0x1a9e8
    return (struct mg_connection_1 *)&v54;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/dial/src/server/mongoose.c
// Address range: 0xc3e0 - 0xc45f
// Line range:    180 - 200
int32_t mg_vsnprintf(struct mg_connection_1 * conn, char * buf, uint32_t buflen, char * fmt, struct __va_list ap) {
    int32_t v1; // 0x19000
    int32_t v2; // 0x19004
    int32_t v3; // 0x19008
    int32_t v4; // 0x192dc
    int32_t v5; // 0x193b8
    char * v6; // 0x193bc
    struct mg_connection_1 * v7; // 0x1a9e8
    int32_t v8; // 0x1aaac
    char * v9; // 0x1bb0c
    int32_t v10; // 0x1bc07
    char * v11; // 0x1bc0c
    char * v12; // 0x1bc10
    char * v13; // 0x1bc14
    int32_t v14; // 0x1bc18
    char * v15; // 0x1bc1c
    char * v16; // 0x1bc20
    char * v17; // 0x1bc24
    int32_t v18; // 0x1bc28
    char * v19; // 0x1bc2c
    int32_t v20; // 0x1bd07
    char * v21; // 0x1bd0c
    char * v22; // 0x1bd10
    char * v23; // 0x1bd14
    int16_t * v24; // 0x1bd18
    char * v25; // 0x1bd1a
    int32_t v26; // 0x1be18
    int32_t v27; // 0x1be30
    int32_t v28; // 0x8912
    int32_t v29; // 0x92e8
    int32_t v30; // 0x9340
    int32_t v31; // 0x9348
    int32_t v32; // 0x934c
    int32_t v33; // 0x9350
    int32_t v34; // 0x9358
    int32_t v35; // 0x935c
    int32_t v36; // 0x9360
    int32_t v37; // 0x9364
    int32_t v38; // 0x9368
    int32_t v39; // 0x93a4
    int32_t v40; // 0x93b4
    int32_t v41; // 0x93c0
    int32_t v42; // 0x94cc
    int32_t v43; // 0x95cc
    int32_t v44; // 0x96cc
    int32_t v45; // 0xab74
    struct mg_context_1 * v46; // 0xbc49
    int32_t v47; // 0xc2a3
    int32_t v48; // 0xd8b1
    int32_t v49; // 0xdab9
    struct mg_context_1 * v50; // 0xdcd9
    int32_t v51; // 0xddd5
    int32_t v52; // 0xddd6
    int32_t v53; // 0xe491
    int16_t v54; // 0xffff
    // 0xc3e0
    int32_t v55;
    int32_t n = v55; // bp-12
    if (buflen == 0) {
        // 0xc454
        return 0;
    }
    int32_t chars_printed = vsnprintf(buf, buflen, fmt, (int32_t)ap.e0); // 0xc400
    n = chars_printed;
    if (chars_printed <= -1) {
        // 0xc40c
        cry(conn, "vsnprintf error");
        n = 0;
        // branch -> 0xc448
        // 0xc448
        // branch -> 0xc454
        // 0xc454
        return n;
    }
    // 0xc420
    if (chars_printed >= buflen) {
        // 0xc428
        cry(conn, "truncating vsnprintf buffer: [%.*s]");
        n = buflen - 1;
        // branch -> 0xc448
    }
    // 0xc448
    // branch -> 0xc454
    // 0xc454
    return n;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/dial/src/server/mongoose.c
// Address range: 0xc460 - 0xc497
// Line range:    202 - 212
int32_t mg_snprintf(struct mg_connection_1 * conn, char * buf, int32_t buflen, char * fmt, ...) {
    struct __va_list v1;
    struct __va_list v2; // 0xc480
    int32_t v3; // 0x19000
    int32_t v4; // 0x19004
    int32_t v5; // 0x19008
    int32_t v6; // 0x192dc
    int32_t v7; // 0x193b8
    char * v8; // 0x193bc
    struct mg_connection_1 * v9; // 0x1a9e8
    int32_t v10; // 0x1aaac
    char * v11; // 0x1bb0c
    int32_t v12; // 0x1bc07
    char * v13; // 0x1bc0c
    char * v14; // 0x1bc10
    char * v15; // 0x1bc14
    int32_t v16; // 0x1bc18
    char * v17; // 0x1bc1c
    char * v18; // 0x1bc20
    char * v19; // 0x1bc24
    int32_t v20; // 0x1bc28
    char * v21; // 0x1bc2c
    int32_t v22; // 0x1bd07
    char * v23; // 0x1bd0c
    char * v24; // 0x1bd10
    char * v25; // 0x1bd14
    int16_t * v26; // 0x1bd18
    char * v27; // 0x1bd1a
    int32_t v28; // 0x1be18
    int32_t v29; // 0x1be30
    int32_t v30; // 0x8912
    int32_t v31; // 0x92e8
    int32_t v32; // 0x9340
    int32_t v33; // 0x9348
    int32_t v34; // 0x934c
    int32_t v35; // 0x9350
    int32_t v36; // 0x9358
    int32_t v37; // 0x935c
    int32_t v38; // 0x9360
    int32_t v39; // 0x9364
    int32_t v40; // 0x9368
    int32_t v41; // 0x93a4
    int32_t v42; // 0x93b4
    int32_t v43; // 0x93c0
    int32_t v44; // 0x94cc
    int32_t v45; // 0x95cc
    int32_t v46; // 0x96cc
    int32_t v47; // 0xab74
    struct mg_context_1 * v48; // 0xbc49
    int32_t v49; // 0xc2a3
    int32_t v50; // 0xd8b1
    int32_t v51; // 0xdab9
    struct mg_context_1 * v52; // 0xdcd9
    int32_t v53; // 0xddd5
    int32_t v54; // 0xddd6
    int32_t v55; // 0xe491
    int16_t v56; // 0xffff
    int32_t v57;
    v1.e0 = (char *)&v57;
    v2 = (struct __va_list){
        .e0 = NULL
    };
    v2.e0 = (char *)&v57;
    return mg_vsnprintf(conn, buf, buflen, fmt, v2);
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/dial/src/server/mongoose.c
// Address range: 0xc838 - 0xc8a7
// Line range:    317 - 333
int32_t start_thread(struct mg_context_1 * ctx2, char * (*func)(char *), char * param) {
    struct anon_struct_14 attr;
    int32_t v1; // 0x19000
    int32_t v2; // 0x19004
    int32_t v3; // 0x19008
    int32_t v4; // 0x192dc
    int32_t v5; // 0x193b8
    char * v6; // 0x193bc
    int32_t v7; // 0x1aaac
    char * v8; // 0x1bb0c
    int32_t v9; // 0x1bc07
    char * v10; // 0x1bc0c
    char * v11; // 0x1bc10
    char * v12; // 0x1bc14
    int32_t v13; // 0x1bc18
    char * v14; // 0x1bc1c
    char * v15; // 0x1bc20
    char * v16; // 0x1bc24
    int32_t v17; // 0x1bc28
    char * v18; // 0x1bc2c
    int32_t v19; // 0x1bd07
    char * v20; // 0x1bd0c
    char * v21; // 0x1bd10
    char * v22; // 0x1bd14
    int16_t * v23; // 0x1bd18
    char * v24; // 0x1bd1a
    int32_t v25; // 0x1be18
    int32_t v26; // 0x1be30
    int32_t v27; // 0x8912
    int32_t v28; // 0x92e8
    int32_t v29; // 0x9340
    int32_t v30; // 0x9348
    int32_t v31; // 0x934c
    int32_t v32; // 0x9350
    int32_t v33; // 0x9358
    int32_t v34; // 0x935c
    int32_t v35; // 0x9360
    int32_t v36; // 0x9364
    int32_t v37; // 0x9368
    int32_t v38; // 0x93a4
    int32_t v39; // 0x93b4
    int32_t v40; // 0x93c0
    int32_t v41; // 0x94cc
    int32_t v42; // 0x95cc
    int32_t v43; // 0x96cc
    int32_t v44; // 0xab74
    struct mg_context_1 * v45; // 0xbc49
    int32_t v46; // 0xc2a3
    int32_t v47; // 0xd8b1
    int32_t v48; // 0xdab9
    struct mg_context_1 * v49; // 0xdcd9
    int32_t v50; // 0xddd5
    int32_t v51; // 0xddd6
    int32_t v52; // 0xe491
    int16_t v53; // 0xffff
    struct anon_struct_14 thread;
    int32_t v54;
    int32_t retval = v54; // bp-20
    pthread_attr_init((int32_t *)&attr);
    pthread_attr_setdetachstate((int32_t *)&attr, PTHREAD_CREATE_DETACHED);
    int32_t v55 = pthread_create((int32_t *)&thread, (int32_t *)&attr, (char * (**)(char *))func, param); // 0xc86a
    retval = v55;
    if (v55 != 0) {
        // 0xc876
        fc(ctx2);
        strerror(retval);
        struct mg_connection_1 * v56; // 0x1a9e8
        cry((struct mg_connection_1 *)&v56, "%s: %s");
        // branch -> 0xc89c
    } else {
        retval = 0;
    }
    // 0xc89c
    return retval;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/dial/src/server/mongoose.c
// Address range: 0xc8a8 - 0xc8d7
// Line range:    335 - 342
int32_t set_non_blocking_mode(int32_t sock) {
    int32_t v1; // 0x19000
    int32_t v2; // 0x19004
    int32_t v3; // 0x19008
    int32_t v4; // 0x192dc
    int32_t v5; // 0x193b8
    char * v6; // 0x193bc
    struct mg_connection_1 * v7; // 0x1a9e8
    int32_t v8; // 0x1aaac
    char * v9; // 0x1bb0c
    int32_t v10; // 0x1bc07
    char * v11; // 0x1bc0c
    char * v12; // 0x1bc10
    char * v13; // 0x1bc14
    int32_t v14; // 0x1bc18
    char * v15; // 0x1bc1c
    char * v16; // 0x1bc20
    char * v17; // 0x1bc24
    int32_t v18; // 0x1bc28
    char * v19; // 0x1bc2c
    int32_t v20; // 0x1bd07
    char * v21; // 0x1bd0c
    char * v22; // 0x1bd10
    char * v23; // 0x1bd14
    int16_t * v24; // 0x1bd18
    char * v25; // 0x1bd1a
    int32_t v26; // 0x1be18
    int32_t v27; // 0x1be30
    int32_t v28; // 0x8912
    int32_t v29; // 0x92e8
    int32_t v30; // 0x9340
    int32_t v31; // 0x9348
    int32_t v32; // 0x934c
    int32_t v33; // 0x9350
    int32_t v34; // 0x9358
    int32_t v35; // 0x935c
    int32_t v36; // 0x9360
    int32_t v37; // 0x9364
    int32_t v38; // 0x9368
    int32_t v39; // 0x93a4
    int32_t v40; // 0x93b4
    int32_t v41; // 0x93c0
    int32_t v42; // 0x94cc
    int32_t v43; // 0x95cc
    int32_t v44; // 0x96cc
    int32_t v45; // 0xab74
    struct mg_context_1 * v46; // 0xbc49
    int32_t v47; // 0xc2a3
    int32_t v48; // 0xd8b1
    int32_t v49; // 0xdab9
    struct mg_context_1 * v50; // 0xdcd9
    int32_t v51; // 0xddd5
    int32_t v52; // 0xddd6
    int32_t v53; // 0xe491
    int16_t v54; // 0xffff
    // 0xc8a8
    fcntl(sock, F_GETFL);
    fcntl(sock, F_GETFL);
    fcntl(sock, F_SETFL);
    return 0;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/dial/src/server/mongoose.c
// Address range: 0xc8d8 - 0xc9a3
// Line range:    346 - 371
int64_t push(struct _IO_FILE_1 * fp, int32_t sock, char * buf, int64_t len) {
    int32_t v1; // 0x19000
    int32_t v2; // 0x19004
    int32_t v3; // 0x19008
    int32_t v4; // 0x192dc
    int32_t v5; // 0x193b8
    char * v6; // 0x193bc
    struct mg_connection_1 * v7; // 0x1a9e8
    int32_t v8; // 0x1aaac
    char * v9; // 0x1bb0c
    int32_t v10; // 0x1bc07
    char * v11; // 0x1bc0c
    char * v12; // 0x1bc10
    char * v13; // 0x1bc14
    int32_t v14; // 0x1bc18
    char * v15; // 0x1bc1c
    char * v16; // 0x1bc20
    char * v17; // 0x1bc24
    int32_t v18; // 0x1bc28
    char * v19; // 0x1bc2c
    int32_t v20; // 0x1bd07
    char * v21; // 0x1bd0c
    char * v22; // 0x1bd10
    char * v23; // 0x1bd14
    int16_t * v24; // 0x1bd18
    char * v25; // 0x1bd1a
    int32_t v26; // 0x1be18
    int32_t v27; // 0x1be30
    int32_t v28; // 0x8912
    int32_t v29; // 0x92e8
    int32_t v30; // 0x9340
    int32_t v31; // 0x9348
    int32_t v32; // 0x934c
    int32_t v33; // 0x9350
    int32_t v34; // 0x9358
    int32_t v35; // 0x935c
    int32_t v36; // 0x9360
    int32_t v37; // 0x9364
    int32_t v38; // 0x9368
    int32_t v39; // 0x93a4
    int32_t v40; // 0x93b4
    int32_t v41; // 0x93c0
    int32_t v42; // 0x94cc
    int32_t v43; // 0x95cc
    int32_t v44; // 0x96cc
    int32_t v45; // 0xab74
    struct mg_context_1 * v46; // 0xbc49
    int32_t v47; // 0xc2a3
    int32_t v48; // 0xd8b1
    int32_t v49; // 0xdab9
    struct mg_context_1 * v50; // 0xdcd9
    int32_t v51; // 0xddd5
    int32_t v52; // 0xddd6
    int32_t v53; // 0xe491
    int16_t v54; // 0xffff
    int32_t v55;
    int32_t n = v55; // bp-20
    int64_t v56;
    int64_t sent = v56; // bp-16
    int32_t v57;
    int32_t v58 = &v57; // 0xc8da_0
    sent = 0;
    int32_t v59;
    int32_t v60 = (int64_t)v59 / 0x100000000; // 0xc984
    int32_t v61 = -2 - v59; // 0xc988
    int32_t v62 = 0;
    int32_t v63 = 0;
    // branch -> 0xc980
    while (true) {
        int32_t v64 = v62;
        int32_t v65 = v63;
        uint32_t v66 = v58; // 0xc8f6
        // branch -> 0xc980
        while (true) {
            // 0xc980
            int32_t v67;
            int32_t v68 = v66 % 4 == 0 ? v65 : v67;
            int32_t v69;
            int32_t v70 = v66 % 4 == 0 ? v60 : v69;
            int32_t result; // 0xc994
            if ((int32_t)(v61 + v64 <= v64) + -1 - v70 + v68 >= 0) {
                // 0xc994
                result = sent;
                if (v58 % 4 == 0) {
                    // if_c994_0_true
                    // branch -> after_if_c994_0
                    // after_if_c994_0
                    return result;
                }
                // after_if_c994_0
                return result;
            }
            int32_t v71 = v59 - v64; // 0xc8fa
            int32_t length = 0x7fffffff;
            if ((int32_t)(-v71 > -0x7ffffffe) + -1 - (v70 - v68) >= 0) {
                // 0xc910
                length = v71;
                // branch -> 0xc91c
            }
            int32_t buf2 = v64 + (int32_t)buf; // 0xc954
            int32_t v72; // 0xc960
            if (fp == NULL) {
                // 0xc950
                v72 = send(sock, (char *)buf2, length, 0);
                n = v72;
                // branch -> 0xc966
                // 0xc966
                if (v72 >= 0) {
                    goto lab_0xc96c;
                }
                // 0xc994
                result = sent;
                if (v58 % 4 == 0) {
                    // if_c994_0_true
                    // branch -> after_if_c994_0
                    // after_if_c994_0
                    return result;
                }
                // after_if_c994_0
                return result;
            }
            // 0xc924
            n = fwrite((char *)buf2, 1, length, (struct _IO_FILE *)fp);
            if (ferror((struct _IO_FILE *)fp) == 0) {
                // 0xc966
                v72 = n;
                // branch -> 0xc966
                // 0xc966
                if (v72 >= 0) {
                  lab_0xc96c:;
                    uint64_t v73 = sent; // 0xc972
                    int32_t v74 = v67;
                    if (v58 % 4 == 0) {
                        // if_c972_0_true
                        v74 = v73 / 0x100000000;
                        // branch -> after_if_c972_0
                    }
                    int32_t v75 = (int32_t)v73 + v72; // 0xc976
                    int64_t v76 = v75;
                    int32_t v77 = (int32_t)(v75 < v72) + (v72 >> 31) + v74; // 0xc978
                    if (v58 % 4 == 0) {
                        // if_c97c_0_true
                        sent = 0x100000000 * (int64_t)v77 | v76 & 0xffffffff;
                        v64 = v75;
                        v65 = v77;
                        v66 = v58;
                        // branch -> 0xc980
                        continue;
                    } else {
                        // if_c97c_0_false
                        sent = v76;
                        v62 = v75;
                        v63 = v76 / 0x100000000;
                        v67 = v77;
                        // branch -> 0xc980
                        break;
                    }
                }
            } else {
                // 0xc966
                n = -1;
                // branch -> 0xc994
            }
            // 0xc994
            result = sent;
            if (v58 % 4 == 0) {
                // if_c994_0_true
                // branch -> after_if_c994_0
                // after_if_c994_0
                return result;
            }
            // after_if_c994_0
            return result;
        }
    }
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/dial/src/server/mongoose.c
// Address range: 0xcbbc - 0xcbef
// Line range:    436 - 438
int32_t mg_write(struct mg_connection_1 * conn, char * buf, int32_t len) {
    int32_t v1; // 0x19000
    int32_t v2; // 0x19004
    int32_t v3; // 0x19008
    int32_t v4; // 0x192dc
    int32_t v5; // 0x193b8
    char * v6; // 0x193bc
    struct mg_connection_1 * v7; // 0x1a9e8
    int32_t v8; // 0x1aaac
    char * v9; // 0x1bb0c
    int32_t v10; // 0x1bc07
    char * v11; // 0x1bc0c
    char * v12; // 0x1bc10
    char * v13; // 0x1bc14
    int32_t v14; // 0x1bc18
    char * v15; // 0x1bc1c
    char * v16; // 0x1bc20
    char * v17; // 0x1bc24
    int32_t v18; // 0x1bc28
    char * v19; // 0x1bc2c
    int32_t v20; // 0x1bd07
    char * v21; // 0x1bd0c
    char * v22; // 0x1bd10
    char * v23; // 0x1bd14
    int16_t * v24; // 0x1bd18
    char * v25; // 0x1bd1a
    int32_t v26; // 0x1be18
    int32_t v27; // 0x1be30
    int32_t v28; // 0x8912
    int32_t v29; // 0x92e8
    int32_t v30; // 0x9340
    int32_t v31; // 0x9348
    int32_t v32; // 0x934c
    int32_t v33; // 0x9350
    int32_t v34; // 0x9358
    int32_t v35; // 0x935c
    int32_t v36; // 0x9360
    int32_t v37; // 0x9364
    int32_t v38; // 0x9368
    int32_t v39; // 0x93a4
    int32_t v40; // 0x93b4
    int32_t v41; // 0x93c0
    int32_t v42; // 0x94cc
    int32_t v43; // 0x95cc
    int32_t v44; // 0x96cc
    int32_t v45; // 0xab74
    struct mg_context_1 * v46; // 0xbc49
    int32_t v47; // 0xc2a3
    int32_t v48; // 0xd8b1
    int32_t v49; // 0xdab9
    struct mg_context_1 * v50; // 0xdcd9
    int32_t v51; // 0xddd5
    int32_t v52; // 0xddd6
    int32_t v53; // 0xe491
    int16_t v54; // 0xffff
    // 0xcbbc
    int32_t v55; // 0xcbca
    return push(NULL, v55, buf, 0);
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/dial/src/server/mongoose.c
// Address range: 0xcbf0 - 0xcc83
// Line range:    440 - 452
int32_t mg_printf(struct mg_connection_1 * conn, char * fmt, ...) {
    struct __va_list v1;
    struct __va_list v2; // 0xcc3e
    char v3[8192];
    int32_t v4; // 0x19000
    int32_t v5; // 0x19004
    int32_t v6; // 0x19008
    int32_t v7; // 0x192dc
    int32_t v8; // 0x193b8
    char * v9; // 0x193bc
    struct mg_connection_1 * v10; // 0x1a9e8
    int32_t v11; // 0x1aaac
    char * v12; // 0x1bb0c
    int32_t v13; // 0x1bc07
    char * v14; // 0x1bc0c
    char * v15; // 0x1bc10
    char * v16; // 0x1bc14
    int32_t v17; // 0x1bc18
    char * v18; // 0x1bc1c
    char * v19; // 0x1bc20
    char * v20; // 0x1bc24
    int32_t v21; // 0x1bc28
    char * v22; // 0x1bc2c
    int32_t v23; // 0x1bd07
    char * v24; // 0x1bd0c
    char * v25; // 0x1bd10
    char * v26; // 0x1bd14
    int16_t * v27; // 0x1bd18
    char * v28; // 0x1bd1a
    int32_t v29; // 0x1be18
    int32_t v30; // 0x1be30
    int32_t v31; // 0x8912
    int32_t v32; // 0x92e8
    int32_t v33; // 0x9340
    int32_t v34; // 0x9348
    int32_t v35; // 0x934c
    int32_t v36; // 0x9350
    int32_t v37; // 0x9358
    int32_t v38; // 0x935c
    int32_t v39; // 0x9360
    int32_t v40; // 0x9364
    int32_t v41; // 0x9368
    int32_t v42; // 0x93a4
    int32_t v43; // 0x93b4
    int32_t v44; // 0x93c0
    int32_t v45; // 0x94cc
    int32_t v46; // 0x95cc
    int32_t v47; // 0x96cc
    int32_t v48; // 0xab74
    struct mg_context_1 * v49; // 0xbc49
    int32_t v50; // 0xc2a3
    int32_t v51; // 0xd8b1
    int32_t v52; // 0xdab9
    struct mg_context_1 * v53; // 0xdcd9
    int32_t v54; // 0xddd5
    int32_t v55; // 0xddd6
    int32_t v56; // 0xe491
    int16_t v57; // 0xffff
    int32_t v58;
    v1.e0 = (char *)&v58;
    v2 = (struct __va_list){
        .e0 = NULL
    };
    v2.e0 = (char *)&v58;
    int32_t v59 = mg_vsnprintf(conn, v3, 0x2000, fmt, v2); // 0xcc3e
    int32_t result = mg_write(conn, v3, v59); // 0xcc6a
    int32_t v60; // 0xcc7c
    ((int32_t (*)(int32_t, int32_t))(v60 & -2))(result, result);
    return result;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/dial/src/server/mongoose.c
// Address range: 0xd1f0 - 0xd20b
// Line range:    618 - 620
void close_all_listening_sockets(struct mg_context_1 * ctx2) {
    int32_t v1; // 0x19000
    int32_t v2; // 0x19004
    int32_t v3; // 0x19008
    int32_t v4; // 0x192dc
    int32_t v5; // 0x193b8
    char * v6; // 0x193bc
    struct mg_connection_1 * v7; // 0x1a9e8
    int32_t v8; // 0x1aaac
    char * v9; // 0x1bb0c
    int32_t v10; // 0x1bc07
    char * v11; // 0x1bc0c
    char * v12; // 0x1bc10
    char * v13; // 0x1bc14
    int32_t v14; // 0x1bc18
    char * v15; // 0x1bc1c
    char * v16; // 0x1bc20
    char * v17; // 0x1bc24
    int32_t v18; // 0x1bc28
    char * v19; // 0x1bc2c
    int32_t v20; // 0x1bd07
    char * v21; // 0x1bd0c
    char * v22; // 0x1bd10
    char * v23; // 0x1bd14
    int16_t * v24; // 0x1bd18
    char * v25; // 0x1bd1a
    int32_t v26; // 0x1be18
    int32_t v27; // 0x1be30
    int32_t v28; // 0x8912
    int32_t v29; // 0x92e8
    int32_t v30; // 0x9340
    int32_t v31; // 0x9348
    int32_t v32; // 0x934c
    int32_t v33; // 0x9350
    int32_t v34; // 0x9358
    int32_t v35; // 0x935c
    int32_t v36; // 0x9360
    int32_t v37; // 0x9364
    int32_t v38; // 0x9368
    int32_t v39; // 0x93a4
    int32_t v40; // 0x93b4
    int32_t v41; // 0x93c0
    int32_t v42; // 0x94cc
    int32_t v43; // 0x95cc
    int32_t v44; // 0x96cc
    int32_t v45; // 0xab74
    struct mg_context_1 * v46; // 0xbc49
    int32_t v47; // 0xc2a3
    int32_t v48; // 0xd8b1
    int32_t v49; // 0xdab9
    struct mg_context_1 * v50; // 0xdcd9
    int32_t v51; // 0xddd5
    int32_t v52; // 0xddd6
    int32_t v53; // 0xe491
    int16_t v54; // 0xffff
    // 0xd1f0
    int32_t fd; // 0xd1fa
    close(fd);
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/dial/src/server/mongoose.c
// Address range: 0xd20c - 0xd24b
// Line range:    623 - 630
int32_t mg_get_listen_addr(struct mg_context_1 * ctx2, struct sockaddr_1 * addr, int32_t * addrlen) {
    int32_t v1; // 0x19000
    int32_t v2; // 0x19004
    int32_t v3; // 0x19008
    int32_t v4; // 0x192dc
    int32_t v5; // 0x193b8
    char * v6; // 0x193bc
    struct mg_connection_1 * v7; // 0x1a9e8
    int32_t v8; // 0x1aaac
    char * v9; // 0x1bb0c
    int32_t v10; // 0x1bc07
    char * v11; // 0x1bc0c
    char * v12; // 0x1bc10
    char * v13; // 0x1bc14
    int32_t v14; // 0x1bc18
    char * v15; // 0x1bc1c
    char * v16; // 0x1bc20
    char * v17; // 0x1bc24
    int32_t v18; // 0x1bc28
    char * v19; // 0x1bc2c
    int32_t v20; // 0x1bd07
    char * v21; // 0x1bd0c
    char * v22; // 0x1bd10
    char * v23; // 0x1bd14
    int16_t * v24; // 0x1bd18
    char * v25; // 0x1bd1a
    int32_t v26; // 0x1be18
    int32_t v27; // 0x1be30
    int32_t v28; // 0x8912
    int32_t v29; // 0x92e8
    int32_t v30; // 0x9340
    int32_t v31; // 0x9348
    int32_t v32; // 0x934c
    int32_t v33; // 0x9350
    int32_t v34; // 0x9358
    int32_t v35; // 0x935c
    int32_t v36; // 0x9360
    int32_t v37; // 0x9364
    int32_t v38; // 0x9368
    int32_t v39; // 0x93a4
    int32_t v40; // 0x93b4
    int32_t v41; // 0x93c0
    int32_t v42; // 0x94cc
    int32_t v43; // 0x95cc
    int32_t v44; // 0x96cc
    int32_t v45; // 0xab74
    struct mg_context_1 * v46; // 0xbc49
    int32_t v47; // 0xc2a3
    int32_t v48; // 0xd8b1
    int32_t v49; // 0xdab9
    struct mg_context_1 * v50; // 0xdcd9
    int32_t v51; // 0xddd5
    int32_t v52; // 0xddd6
    int32_t v53; // 0xe491
    int16_t v54; // 0xffff
    int32_t result = 0;
    if (*addrlen < 16) {
        // 0xd22a
        *addrlen = 16;
        memcpy((char *)addr, (char *)((int32_t)ctx2 + 16), 16);
        result = 1;
        // branch -> 0xd240
    }
    // 0xd240
    return result;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/dial/src/server/mongoose.c
// Address range: 0xd24c - 0xd3e3
// Line range:    632 - 667
int32_t set_ports_option(struct mg_context_1 * ctx2, int32_t port) {
    int32_t v1; // 0x19000
    int32_t v2; // 0x19004
    int32_t v3; // 0x19008
    int32_t v4; // 0x192dc
    int32_t v5; // 0x193b8
    char * v6; // 0x193bc
    int32_t v7; // 0x1aaac
    char * v8; // 0x1bb0c
    int32_t v9; // 0x1bc07
    char * v10; // 0x1bc0c
    char * v11; // 0x1bc10
    char * v12; // 0x1bc14
    int32_t v13; // 0x1bc18
    char * v14; // 0x1bc1c
    char * v15; // 0x1bc20
    char * v16; // 0x1bc24
    int32_t v17; // 0x1bc28
    char * v18; // 0x1bc2c
    int32_t v19; // 0x1bd07
    char * v20; // 0x1bd0c
    char * v21; // 0x1bd10
    char * v22; // 0x1bd14
    int16_t * v23; // 0x1bd18
    char * v24; // 0x1bd1a
    int32_t v25; // 0x1be18
    int32_t v26; // 0x1be30
    int32_t v27; // 0x8912
    int32_t v28; // 0x92e8
    int32_t v29; // 0x9340
    int32_t v30; // 0x9348
    int32_t v31; // 0x934c
    int32_t v32; // 0x9350
    int32_t v33; // 0x9358
    int32_t v34; // 0x935c
    int32_t v35; // 0x9360
    int32_t v36; // 0x9364
    int32_t v37; // 0x9368
    int32_t v38; // 0x93a4
    int32_t v39; // 0x93b4
    int32_t v40; // 0x93c0
    int32_t v41; // 0x94cc
    int32_t v42; // 0x95cc
    int32_t v43; // 0x96cc
    int32_t v44; // 0xab74
    struct mg_context_1 * v45; // 0xbc49
    int32_t v46; // 0xc2a3
    int32_t v47; // 0xd8b1
    int32_t v48; // 0xdab9
    struct mg_context_1 * v49; // 0xdcd9
    int32_t v50; // 0xddd5
    int32_t v51; // 0xddd6
    int32_t v52; // 0xe491
    struct timeval_1 option_value;
    int32_t v53;
    int32_t sock_len = v53; // bp-28
    int32_t v54;
    int32_t reuseaddr = v54; // bp-24
    int32_t v55;
    int32_t success = v55; // bp-20
    int32_t v56 = (int32_t)ctx2; // 0xd24c_0
    reuseaddr = 1;
    success = 1;
    sock_len = 16;
    int32_t v57 = v56 + 16; // 0xd264
    memset((char *)v57, 0, 16);
    int16_t v58; // 0xffff
    htons((int16_t)(port & (int32_t)&v58));
    htons((int16_t)(port & (int32_t)&v58));
    htonl(0);
    htonl(0);
    int32_t sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); // 0xd2ac
    int32_t * sock = (int32_t *)(v56 + 12); // 0xd2b4_0
    *sock = sock_fd;
    struct mg_connection_1 * v59; // 0x1a9e8
    if (*sock != -1) {
        // 0xd2c0
        if (setsockopt(*sock, SO_DEBUG, 2, (char *)&reuseaddr, 4) == 0) {
            // 0xd2dc
            if (setsockopt(*sock, SO_DEBUG, 20, (char *)&option_value, 8) == 0) {
                struct sockaddr * addr = (struct sockaddr *)v57;
                if (bind(*sock, addr, sock_len) == 0) {
                    // 0xd314
                    if (listen(*sock, 20) == 0) {
                        // 0xd368
                        if (getsockname(*sock, addr, &sock_len) == 0) {
                            // 0xd3c2
                            if (success != 0) {
                                // 0xd3d6
                                return success;
                            }
                        } else {
                            // 0xd386
                            close(*sock);
                            fc(ctx2);
                            int32_t err_num = *__errno_location(); // 0xd39e
                            strerror(err_num);
                            cry((struct mg_connection_1 *)&v59, "%s: %s");
                            // branch -> 0xd3c2
                            // 0xd3c2
                            success = 0;
                            // branch -> 0xd3c8
                        }
                        // 0xd3c8
                        *sock = -1;
                        close_all_listening_sockets(ctx2);
                        // branch -> 0xd3d6
                        // 0xd3d6
                        return success;
                    }
                }
            }
        }
    }
    // 0xd326
    close(*sock);
    fc(ctx2);
    int32_t err_num2 = *__errno_location(); // 0xd33e
    strerror(err_num2);
    cry((struct mg_connection_1 *)&v59, "%s: cannot bind to port %d: %s");
    // branch -> 0xd3c2
    // 0xd3c2
    success = 0;
    // branch -> 0xd3c8
    // 0xd3c8
    *sock = -1;
    close_all_listening_sockets(ctx2);
    // branch -> 0xd3d6
    // 0xd3d6
    return success;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/dial/src/server/mongoose.c
// Address range: 0xdba8 - 0xdbbf
// Line range:    909 - 912
void free_context(struct mg_context_1 * ctx2) {
    int32_t v1; // 0x19000
    int32_t v2; // 0x19004
    int32_t v3; // 0x19008
    int32_t v4; // 0x192dc
    int32_t v5; // 0x193b8
    char * v6; // 0x193bc
    struct mg_connection_1 * v7; // 0x1a9e8
    int32_t v8; // 0x1aaac
    char * v9; // 0x1bb0c
    int32_t v10; // 0x1bc07
    char * v11; // 0x1bc0c
    char * v12; // 0x1bc10
    char * v13; // 0x1bc14
    int32_t v14; // 0x1bc18
    char * v15; // 0x1bc1c
    char * v16; // 0x1bc20
    char * v17; // 0x1bc24
    int32_t v18; // 0x1bc28
    char * v19; // 0x1bc2c
    int32_t v20; // 0x1bd07
    char * v21; // 0x1bd0c
    char * v22; // 0x1bd10
    char * v23; // 0x1bd14
    int16_t * v24; // 0x1bd18
    char * v25; // 0x1bd1a
    int32_t v26; // 0x1be18
    int32_t v27; // 0x1be30
    int32_t v28; // 0x8912
    int32_t v29; // 0x92e8
    int32_t v30; // 0x9340
    int32_t v31; // 0x9348
    int32_t v32; // 0x934c
    int32_t v33; // 0x9350
    int32_t v34; // 0x9358
    int32_t v35; // 0x935c
    int32_t v36; // 0x9360
    int32_t v37; // 0x9364
    int32_t v38; // 0x9368
    int32_t v39; // 0x93a4
    int32_t v40; // 0x93b4
    int32_t v41; // 0x93c0
    int32_t v42; // 0x94cc
    int32_t v43; // 0x95cc
    int32_t v44; // 0x96cc
    int32_t v45; // 0xab74
    struct mg_context_1 * v46; // 0xbc49
    int32_t v47; // 0xc2a3
    int32_t v48; // 0xd8b1
    int32_t v49; // 0xdab9
    struct mg_context_1 * v50; // 0xdcd9
    int32_t v51; // 0xddd5
    int32_t v52; // 0xddd6
    int32_t v53; // 0xe491
    int16_t v54; // 0xffff
    // 0xdba8
    free((char *)ctx2);
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/dial/src/server/mongoose.c
// Address range: 0xdbc0 - 0xdbeb
// Line range:    914 - 923
void mg_stop(struct mg_context_1 * ctx2) {
    int32_t v1; // 0x19000
    int32_t v2; // 0x19004
    int32_t v3; // 0x19008
    int32_t v4; // 0x192dc
    int32_t v5; // 0x193b8
    char * v6; // 0x193bc
    struct mg_connection_1 * v7; // 0x1a9e8
    int32_t v8; // 0x1aaac
    char * v9; // 0x1bb0c
    int32_t v10; // 0x1bc07
    char * v11; // 0x1bc0c
    char * v12; // 0x1bc10
    char * v13; // 0x1bc14
    int32_t v14; // 0x1bc18
    char * v15; // 0x1bc1c
    char * v16; // 0x1bc20
    char * v17; // 0x1bc24
    int32_t v18; // 0x1bc28
    char * v19; // 0x1bc2c
    int32_t v20; // 0x1bd07
    char * v21; // 0x1bd0c
    char * v22; // 0x1bd10
    char * v23; // 0x1bd14
    int16_t * v24; // 0x1bd18
    char * v25; // 0x1bd1a
    int32_t v26; // 0x1be18
    int32_t v27; // 0x1be30
    int32_t v28; // 0x8912
    int32_t v29; // 0x92e8
    int32_t v30; // 0x9340
    int32_t v31; // 0x9348
    int32_t v32; // 0x934c
    int32_t v33; // 0x9350
    int32_t v34; // 0x9358
    int32_t v35; // 0x935c
    int32_t v36; // 0x9360
    int32_t v37; // 0x9364
    int32_t v38; // 0x9368
    int32_t v39; // 0x93a4
    int32_t v40; // 0x93b4
    int32_t v41; // 0x93c0
    int32_t v42; // 0x94cc
    int32_t v43; // 0x95cc
    int32_t v44; // 0x96cc
    int32_t v45; // 0xab74
    struct mg_context_1 * v46; // 0xbc49
    int32_t v47; // 0xc2a3
    int32_t v48; // 0xd8b1
    int32_t v49; // 0xdab9
    struct mg_context_1 * v50; // 0xdcd9
    int32_t v51; // 0xddd5
    int32_t v52; // 0xddd6
    int32_t v53; // 0xe491
    int16_t v54; // 0xffff
    // 0xdbc0
    int32_t v55; // 0xdbd81
    if (v55 == 2) {
        // 0xdbde
        free_context(ctx2);
        return;
    }
    sleep(0);
    int32_t v56; // 0xdbd8
    while (v56 != 2) {
        // 0xdbd0
        sleep(0);
        // continue -> 0xdbd0
    }
    // 0xdbde
    free_context(ctx2);
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/dial/src/server/mongoose.c
// Address range: 0xdbec - 0xdcd7
// Line range:    925 - 959
struct mg_context_1 * mg_start(char * (*user_callback)(int32_t, struct mg_connection_1 *, struct mg_request_info_1 *), char * user_data, int32_t port) {
    int32_t v1; // 0x19000
    int32_t v2; // 0x19004
    int32_t v3; // 0x19008
    int32_t v4; // 0x192dc
    int32_t v5; // 0x193b8
    char * v6; // 0x193bc
    int32_t v7; // 0x1aaac
    char * v8; // 0x1bb0c
    int32_t v9; // 0x1bc07
    char * v10; // 0x1bc0c
    char * v11; // 0x1bc10
    char * v12; // 0x1bc14
    int32_t v13; // 0x1bc18
    char * v14; // 0x1bc1c
    char * v15; // 0x1bc20
    char * v16; // 0x1bc24
    int32_t v17; // 0x1bc28
    char * v18; // 0x1bc2c
    int32_t v19; // 0x1bd07
    char * v20; // 0x1bd0c
    char * v21; // 0x1bd10
    char * v22; // 0x1bd14
    int16_t * v23; // 0x1bd18
    char * v24; // 0x1bd1a
    int32_t v25; // 0x1be18
    int32_t v26; // 0x1be30
    int32_t v27; // 0x8912
    int32_t v28; // 0x92e8
    int32_t v29; // 0x9340
    int32_t v30; // 0x9348
    int32_t v31; // 0x934c
    int32_t v32; // 0x9350
    int32_t v33; // 0x9358
    int32_t v34; // 0x935c
    int32_t v35; // 0x9360
    int32_t v36; // 0x9364
    int32_t v37; // 0x9368
    int32_t v38; // 0x93a4
    int32_t v39; // 0x93b4
    int32_t v40; // 0x93c0
    int32_t v41; // 0x94cc
    int32_t v42; // 0x95cc
    int32_t v43; // 0x96cc
    int32_t v44; // 0xab74
    struct mg_context_1 * v45; // 0xbc49
    int32_t v46; // 0xc2a3
    struct mg_context_1 * v47; // 0xdcd9
    int32_t v48; // 0xddd5
    int32_t v49; // 0xddd6
    int32_t v50; // 0xe491
    int16_t v51; // 0xffff
    struct mg_context_1 * v52;
    struct mg_context_1 * ctx2 = v52; // bp-24
    int32_t v53;
    int32_t i = v53; // bp-20
    ctx2 = (struct mg_context_1 *)calloc(1, 936);
    if (set_ports_option(ctx2, port) == 0) {
        // 0xdc20
        free_context(ctx2);
        // branch -> 0xdccc
        // 0xdccc
        return (struct mg_context_1 *)0;
    }
    // 0xdc2a
    signal(SIGPIPE, SIG_IGN);
    pthread_mutex_init((int32_t *)((int32_t)ctx2 + 36), NULL);
    pthread_cond_init((int32_t *)((int32_t)ctx2 + 64), NULL);
    pthread_cond_init((int32_t *)((int32_t)ctx2 + 888), NULL);
    pthread_cond_init((int32_t *)((int32_t)ctx2 + 840), NULL);
    int32_t v54; // 0xdab9
    start_thread(ctx2, (char * (*)(char *))&v54, (char *)ctx2);
    i = 0;
    struct mg_context_1 * v55 = ctx2; // 0xdc7c4
    // branch -> 0xdc7c
    while (true) {
        // 0xdc7c
        int32_t v56; // 0xd8b1
        if (start_thread(v55, (char * (*)(char *))&v56, (char *)v55) == 0) {
            int32_t * v57 = (int32_t *)((int32_t)ctx2 + 32); // 0xdcb6_0
            *v57 = *v57 + 1;
            // branch -> 0xdcbe
        } else {
            // 0xdc92
            fc(ctx2);
            __errno_location();
            __errno_location();
            struct mg_connection_1 * v58; // 0x1a9e8
            cry((struct mg_connection_1 *)&v58, "Cannot start worker thread: %d");
            // branch -> 0xdcbe
        }
        int32_t v59 = i + 1; // 0xdcc0
        i = v59;
        if (v59 >= 8) {
            // break -> 0xdccc
            break;
        }
        v55 = ctx2;
        // continue -> 0xdc7c
    }
    // 0xdccc
    return (struct mg_context_1 *)(int32_t)ctx2;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/dial/src/server/quick_ssdp.c
// Address range: 0xdd94 - 0xe0df
// Line range:    108 - 180
void get_local_address(void) {
    char v1[4096];
    int32_t v2; // 0x19000
    int32_t v3; // 0x19004
    int32_t v4; // 0x19008
    int32_t v5; // 0x192dc
    int32_t v6; // 0x193b8
    char * v7; // 0x193bc
    struct mg_connection_1 * v8; // 0x1a9e8
    int32_t v9; // 0x1aaac
    char * v10; // 0x1bb0c
    int32_t v11; // 0x1bc07
    char * v12; // 0x1bc0c
    char * v13; // 0x1bc10
    char * v14; // 0x1bc14
    int32_t v15; // 0x1bc18
    char * v16; // 0x1bc1c
    char * v17; // 0x1bc20
    char * v18; // 0x1bc24
    int32_t v19; // 0x1bc28
    char * v20; // 0x1bc2c
    int32_t v21; // 0x1bd07
    char * v22; // 0x1bd0c
    char * v23; // 0x1bd10
    char * v24; // 0x1bd14
    int16_t * v25; // 0x1bd18
    char * v26; // 0x1bd1a
    int32_t v27; // 0x1be18
    int32_t v28; // 0x1be30
    int32_t v29; // 0x92e8
    int32_t v30; // 0x9340
    int32_t v31; // 0x9348
    int32_t v32; // 0x934c
    int32_t v33; // 0x9350
    int32_t v34; // 0x9358
    int32_t v35; // 0x935c
    int32_t v36; // 0x9360
    int32_t v37; // 0x9364
    int32_t v38; // 0x9368
    int32_t v39; // 0x93a4
    int32_t v40; // 0x93b4
    int32_t v41; // 0x93c0
    int32_t v42; // 0x94cc
    int32_t v43; // 0x95cc
    int32_t v44; // 0x96cc
    int32_t v45; // 0xab74
    struct mg_context_1 * v46; // 0xbc49
    int32_t v47; // 0xc2a3
    int32_t v48; // 0xd8b1
    int32_t v49; // 0xdab9
    struct mg_context_1 * v50; // 0xdcd9
    int32_t v51; // 0xddd5
    int32_t v52; // 0xddd6
    int32_t v53; // 0xe491
    int16_t v54; // 0xffff
    struct ifconf v55;
    // 0xdd94
    int32_t v56;
    int32_t i = v56; // bp-20
    int32_t sock_fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_IP); // 0xdda2
    struct ifreq * v57 = (struct ifreq *)sock_fd;
    v55.e1.e1 = v57;
    if (v57 == (struct ifreq *)-1) {
        // 0xddc0
        perror("socket");
        exit(1);
        // UNREACHABLE
    }
    // 0xddd2
    v55.e1.e0 = &v1[0];
    int32_t request; // 0x8912
    if (ioctl(sock_fd, (int32_t)&request) <= -1) {
        // 0xde0c
        perror("SIOCGIFCONF");
        exit(1);
        // UNREACHABLE
    }
    // 0xde1e
    int32_t v58; // 0xde22
    if (v58 == 0x1000) {
        // 0xde2a
        exit(1);
        // UNREACHABLE
    }
    int32_t v59 = 0;
    // branch -> 0xe0a6
    while (true) {
        // 0xe0a6
        i = v59;
        strcmp((char *)((int32_t)v55.e1.e0 + 32 * v59), "lo");
        v59 = i + 1;
        // branch -> 0xe0a6
    }
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/dial/src/server/quick_ssdp.c
// Address range: 0xe0e0 - 0xe377
// Line range:    182 - 264
void handle_mcast(void) {
    int32_t v1; // 0x19000
    int32_t v2; // 0x19004
    int32_t v3; // 0x19008
    int32_t v4; // 0x192dc
    int32_t v5; // 0x193b8
    char * v6; // 0x193bc
    struct mg_connection_1 * v7; // 0x1a9e8
    int32_t v8; // 0x1aaac
    char * v9; // 0x1bb0c
    int32_t v10; // 0x1bc07
    char * v11; // 0x1bc0c
    char * v12; // 0x1bc10
    char * v13; // 0x1bc14
    int32_t v14; // 0x1bc18
    char * v15; // 0x1bc1c
    char * v16; // 0x1bc20
    char * v17; // 0x1bc24
    int32_t v18; // 0x1bc28
    char * v19; // 0x1bc2c
    int32_t v20; // 0x1bd07
    char * v21; // 0x1bd0c
    char * v22; // 0x1bd10
    char * v23; // 0x1bd14
    int16_t * v24; // 0x1bd18
    char * v25; // 0x1bd1a
    int32_t v26; // 0x1be18
    int32_t v27; // 0x1be30
    int32_t v28; // 0x8912
    int32_t v29; // 0x92e8
    int32_t v30; // 0x9340
    int32_t v31; // 0x9348
    int32_t v32; // 0x934c
    int32_t v33; // 0x9350
    int32_t v34; // 0x9358
    int32_t v35; // 0x935c
    int32_t v36; // 0x9360
    int32_t v37; // 0x9364
    int32_t v38; // 0x9368
    int32_t v39; // 0x93b4
    int32_t v40; // 0x93c0
    int32_t v41; // 0x94cc
    int32_t v42; // 0x95cc
    int32_t v43; // 0x96cc
    int32_t v44; // 0xab74
    struct mg_context_1 * v45; // 0xbc49
    int32_t v46; // 0xc2a3
    int32_t v47; // 0xd8b1
    int32_t v48; // 0xdab9
    struct mg_context_1 * v49; // 0xdcd9
    int32_t v50; // 0xddd5
    int32_t v51; // 0xddd6
    int32_t v52; // 0xe491
    int16_t v53; // 0xffff
    struct ip_mreq option_value;
    char str2[16];
    struct sockaddr_in_2 addr;
    char str[777];
    int32_t v54;
    int32_t addrlen = v54; // bp-36
    int32_t v55;
    int32_t one = v55; // bp-32
    int32_t v56;
    int32_t s = v56; // bp-24
    int32_t v57;
    int32_t send_size = v57; // bp-20
    one = 1;
    memset(str, 0, 777);
    int32_t v58; // 0x93a4
    int32_t chars_printed = snprintf(str, 777, "HTTP/1.1 200 OK\r\nLOCATION: http://%s:%d/dd.xml\r\nCACHE-CONTROL: max-age=1800\r\nEXT:\r\nBOOTID.UPNP.ORG: 1\r\nSERVER: Linux/2.6 UPnP/1.0 quick_ssdp/1.0\r\nST: urn:dial-multiscreen-org:service:dial:1\r\nUSN: uuid:%s::urn:dial-multiscreen-org:service:dial:1\r\n\r\n", (char *)((int32_t)&v58 | (int32_t)"1\r\nSERVER: Linux/2.6 UPnP/1.0 quick_ssdp/1.0\r\nST: urn:dial-multiscreen-org:service:dial:1\r\nUSN: uuid:%s::urn:dial-multiscreen-org:service:dial:1\r\n\r\n"), my_port, m_uuid);
    send_size = chars_printed;
    int32_t sock_fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_IP); // 0xe140
    s = sock_fd;
    if (sock_fd == -1) {
        // 0xe152
        perror("socket");
        exit(1);
        // UNREACHABLE
    }
    // 0xe164
    if (setsockopt(sock_fd, SO_DEBUG, 2, (char *)&one, 4) == -1) {
        // 0xe180
        perror("reuseaddr");
        exit(1);
        // UNREACHABLE
    }
    // 0xe192
    inet_addr("239.255.255.250");
    inet_addr("239.255.255.250");
    htons(1900);
    htons(1900);
    if (bind(s, (struct sockaddr *)&addr, 16) == -1) {
        // 0xe1d0
        perror("bind");
        exit(1);
        // UNREACHABLE
    }
    // 0xe1e2
    inet_addr("239.255.255.250");
    inet_addr("239.255.255.250");
    inet_addr((char *)((int32_t)&v58 | (int32_t)"1\r\nSERVER: Linux/2.6 UPnP/1.0 quick_ssdp/1.0\r\nST: urn:dial-multiscreen-org:service:dial:1\r\nUSN: uuid:%s::urn:dial-multiscreen-org:service:dial:1\r\n\r\n"));
    inet_addr((char *)((int32_t)&v58 | (int32_t)"1\r\nSERVER: Linux/2.6 UPnP/1.0 quick_ssdp/1.0\r\nST: urn:dial-multiscreen-org:service:dial:1\r\nUSN: uuid:%s::urn:dial-multiscreen-org:service:dial:1\r\n\r\n"));
    if (setsockopt(s, 0, 35, (char *)&option_value, 8) == -1) {
        // 0xe222
        perror("add_membership");
        exit(1);
        // UNREACHABLE
    }
    // 0xe234
    // branch -> 0xe260
    while (true) {
      lab_0xe260:
        // 0xe260
        memset(str2, 0, 16);
        strcpy(str2, (char *)((int32_t)&v58 | (int32_t)"1\r\nSERVER: Linux/2.6 UPnP/1.0 quick_ssdp/1.0\r\nST: urn:dial-multiscreen-org:service:dial:1\r\nUSN: uuid:%s::urn:dial-multiscreen-org:service:dial:1\r\n\r\n"));
        get_local_address();
        memset(str, 0, 777);
        int32_t chars_printed2 = snprintf(str, 777, "HTTP/1.1 200 OK\r\nLOCATION: http://%s:%d/dd.xml\r\nCACHE-CONTROL: max-age=1800\r\nEXT:\r\nBOOTID.UPNP.ORG: 1\r\nSERVER: Linux/2.6 UPnP/1.0 quick_ssdp/1.0\r\nST: urn:dial-multiscreen-org:service:dial:1\r\nUSN: uuid:%s::urn:dial-multiscreen-org:service:dial:1\r\n\r\n", (char *)((int32_t)&v58 | (int32_t)"1\r\nSERVER: Linux/2.6 UPnP/1.0 quick_ssdp/1.0\r\nST: urn:dial-multiscreen-org:service:dial:1\r\nUSN: uuid:%s::urn:dial-multiscreen-org:service:dial:1\r\n\r\n"), my_port, m_uuid);
        send_size = chars_printed2;
        addrlen = 16;
        if (recvfrom(s, gBuf, 4095, 0, (struct sockaddr *)&addr, &addrlen) == -1) {
            // 0xe2fe
            perror("recvfrom");
            // branch -> 0xe260
            continue;
        } else {
            // 0xe30c
            if (strstr(gBuf, "urn:dial-multiscreen-org:service:dial:1") != NULL) {
                // break -> 0xe338
                break;
            }
            // continue -> 0xe260
            continue;
        }
    }
    // 0xe338
    sendto(s, str, send_size, 0, (struct sockaddr *)&addr, addrlen);
    // branch -> 0xe260
    goto lab_0xe260;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/dial/src/server/quick_ssdp.c
// Address range: 0xe584 - 0xe5bf
// Line range:    381 - 388
void createIGMPTask(void) {
    struct anon_struct_19 attr;
    int32_t v1; // 0x19000
    int32_t v2; // 0x19004
    int32_t v3; // 0x19008
    int32_t v4; // 0x192dc
    int32_t v5; // 0x193b8
    char * v6; // 0x193bc
    struct mg_connection_1 * v7; // 0x1a9e8
    int32_t v8; // 0x1aaac
    char * v9; // 0x1bb0c
    int32_t v10; // 0x1bc07
    char * v11; // 0x1bc0c
    char * v12; // 0x1bc10
    char * v13; // 0x1bc14
    int32_t v14; // 0x1bc18
    char * v15; // 0x1bc1c
    char * v16; // 0x1bc20
    char * v17; // 0x1bc24
    int32_t v18; // 0x1bc28
    char * v19; // 0x1bc2c
    int32_t v20; // 0x1bd07
    char * v21; // 0x1bd0c
    char * v22; // 0x1bd10
    char * v23; // 0x1bd14
    int16_t * v24; // 0x1bd18
    char * v25; // 0x1bd1a
    int32_t v26; // 0x1be18
    int32_t v27; // 0x1be30
    int32_t v28; // 0x8912
    int32_t v29; // 0x92e8
    int32_t v30; // 0x9340
    int32_t v31; // 0x9348
    int32_t v32; // 0x934c
    int32_t v33; // 0x9350
    int32_t v34; // 0x9358
    int32_t v35; // 0x935c
    int32_t v36; // 0x9360
    int32_t v37; // 0x9364
    int32_t v38; // 0x9368
    int32_t v39; // 0x93a4
    int32_t v40; // 0x93b4
    int32_t v41; // 0x93c0
    int32_t v42; // 0x94cc
    int32_t v43; // 0x95cc
    int32_t v44; // 0x96cc
    int32_t v45; // 0xab74
    struct mg_context_1 * v46; // 0xbc49
    int32_t v47; // 0xc2a3
    int32_t v48; // 0xd8b1
    int32_t v49; // 0xdab9
    struct mg_context_1 * v50; // 0xdcd9
    int32_t v51; // 0xddd5
    int32_t v52; // 0xddd6
    int16_t v53; // 0xffff
    pthread_attr_init((int32_t *)&attr);
    pthread_attr_setdetachstate((int32_t *)&attr, PTHREAD_CREATE_JOINABLE);
    int32_t thread_func; // 0xe491
    pthread_create(&_mIGMPThread, (int32_t *)&attr, (char * (**)(char *))&thread_func, NULL);
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/dial/src/server/quick_ssdp.c
// Address range: 0xe5c0 - 0xe753
// Line range:    390 - 429
void run_ssdp(int32_t port, char * pFriendlyName, char * pModelName, char * pUuid) {
    int32_t v1; // 0x19000
    int32_t v2; // 0x19004
    int32_t v3; // 0x19008
    int32_t v4; // 0x192dc
    int32_t v5; // 0x193b8
    char * v6; // 0x193bc
    struct mg_connection_1 * v7; // 0x1a9e8
    int32_t v8; // 0x1aaac
    int32_t v9; // 0x1bc07
    int32_t v10; // 0x1bd07
    int32_t v11; // 0x1be18
    int32_t v12; // 0x1be30
    int32_t v13; // 0x8912
    int32_t v14; // 0x92e8
    int32_t v15; // 0x9340
    int32_t v16; // 0x9348
    int32_t v17; // 0x934c
    int32_t v18; // 0x9350
    int32_t v19; // 0x9358
    int32_t v20; // 0x935c
    int32_t v21; // 0x9360
    int32_t v22; // 0x9364
    int32_t v23; // 0x9368
    int32_t v24; // 0x93a4
    int32_t v25; // 0x93b4
    int32_t v26; // 0x93c0
    int32_t v27; // 0x94cc
    int32_t v28; // 0x95cc
    int32_t v29; // 0x96cc
    int32_t v30; // 0xab74
    struct mg_context_1 * v31; // 0xbc49
    int32_t v32; // 0xc2a3
    int32_t v33; // 0xd8b1
    int32_t v34; // 0xdab9
    int32_t v35; // 0xddd5
    int32_t v36; // 0xe491
    int16_t v37; // 0xffff
    struct sockaddr_2 v38;
    // 0xe5c0
    int32_t v39;
    int32_t len = v39; // bp-36
    len = 16;
    if (pFriendlyName == NULL) {
        // 0xe626
        *(int32_t *)&friendly_name = 0x4d4f4854;
        char * v40 = (char *)0x4e4f53; // 0x1bb0c
        // branch -> 0xe63e
    } else {
        // 0xe5d8
        memset(friendly_name, 0, 256);
        strlen(friendly_name);
        strlen(friendly_name);
        // branch -> 0xe63e
    }
    // 0xe63e
    if (pModelName == NULL) {
        // 0xe666
        *(int32_t *)&model_name = 0x4d4f4854;
        char * v41 = (char *)0x2d4e4f53; // 0x1bd0c
        char * v42 = (char *)0x4e2d5654; // 0x1bd10
        char * v43 = (char *)0x37363654; // 0x1bd14
        int16_t * v44; // 0x1bd18
        *(int16_t *)&v44 = 0x5545;
        char * v45; // 0x1bd1a
        *(char *)&v45 = 0;
        // branch -> 0xe68a
    } else {
        // 0xe644
        strncpy(model_name, pModelName, 256);
        // branch -> 0xe68a
    }
    // 0xe68a
    if (pUuid == NULL) {
        // 0xe6b2
        *(int32_t *)&m_uuid = 0x64616564;
        char * v46 = (char *)0x66656562; // 0x1bc0c
        char * v47 = (char *)0x6165642d; // 0x1bc10
        char * v48 = (char *)0x65622d64; // 0x1bc14
        int32_t v49 = 0x642d6665; // 0x1bc18
        char * v50 = (char *)0x2d646165; // 0x1bc1c
        char * v51 = (char *)0x66656562; // 0x1bc20
        char * v52 = (char *)0x64616564; // 0x1bc24
        int32_t v53 = 0x66656562; // 0x1bc28
        char * v54; // 0x1bc2c
        *(char *)&v54 = 0;
        // branch -> 0xe6d8
    } else {
        // 0xe690
        strncpy(m_uuid, pUuid, 256);
        // branch -> 0xe6d8
    }
    // 0xe6d8
    dial_port = port;
    get_local_address();
    struct mg_context_1 * v55; // 0xdcd9
    int32_t v56; // 0xddd6
    struct mg_context_1 * v57 = mg_start((char * (*)(int32_t, struct mg_connection_1 *, struct mg_request_info_1 *))&v55, NULL, (int32_t)&v56); // 0xe6f6
    ctx = (int32_t)v57;
    if (mg_get_listen_addr(v57, (struct sockaddr_1 *)&v38, &len) != 0) {
        // 0xe728
        int16_t net_short; // 0xe72c
        my_port = ntohs(net_short);
        // branch -> 0xe742
    }
    // 0xe742
    createIGMPTask();
    handle_mcast();
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/dial/src/server/dial_data.c
// Address range: 0xec7c - 0xeccb
// Line range:    37 - 44
char * getAppPath(char * app_name) {
    int32_t v1; // 0x19000
    int32_t v2; // 0x19004
    int32_t v3; // 0x19008
    int32_t v4; // 0x192dc
    int32_t v5; // 0x193b8
    char * v6; // 0x193bc
    struct mg_connection_1 * v7; // 0x1a9e8
    int32_t v8; // 0x1aaac
    char * v9; // 0x1bb0c
    int32_t v10; // 0x1bc07
    char * v11; // 0x1bc0c
    char * v12; // 0x1bc10
    char * v13; // 0x1bc14
    int32_t v14; // 0x1bc18
    char * v15; // 0x1bc1c
    char * v16; // 0x1bc20
    char * v17; // 0x1bc24
    int32_t v18; // 0x1bc28
    char * v19; // 0x1bc2c
    int32_t v20; // 0x1bd07
    char * v21; // 0x1bd0c
    char * v22; // 0x1bd10
    char * v23; // 0x1bd14
    int16_t * v24; // 0x1bd18
    char * v25; // 0x1bd1a
    int32_t v26; // 0x1be18
    int32_t v27; // 0x1be30
    int32_t v28; // 0x8912
    int32_t v29; // 0x92e8
    int32_t v30; // 0x9340
    int32_t v31; // 0x9348
    int32_t v32; // 0x934c
    int32_t v33; // 0x9350
    int32_t v34; // 0x9358
    int32_t v35; // 0x935c
    int32_t v36; // 0x9360
    int32_t v37; // 0x9364
    int32_t v38; // 0x9368
    int32_t v39; // 0x93a4
    int32_t v40; // 0x93b4
    int32_t v41; // 0x93c0
    int32_t v42; // 0x94cc
    int32_t v43; // 0x95cc
    int32_t v44; // 0x96cc
    int32_t v45; // 0xab74
    struct mg_context_1 * v46; // 0xbc49
    int32_t v47; // 0xc2a3
    int32_t v48; // 0xd8b1
    int32_t v49; // 0xdab9
    struct mg_context_1 * v50; // 0xdcd9
    int32_t v51; // 0xddd5
    int32_t v52; // 0xddd6
    int32_t v53; // 0xe491
    int16_t v54; // 0xffff
    // 0xec7c
    char * v55;
    char * filename = v55; // bp-16
    int32_t v56;
    int32_t name_size = v56; // bp-12
    int32_t size = strlen(app_name) + 8; // 0xec8c
    name_size = size;
    char * mem = malloc(size); // 0xec92
    filename = mem;
    *mem = 0;
    strncat(filename, "/data/", name_size);
    strncat(filename, app_name, name_size - 7);
    return filename;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/dial/src/server/dial_data.c
// Address range: 0xed40 - 0xee2f
// Line range:    59 - 79
struct DIALData__2 * retrieve_dial_data(char * app_name) {
    int32_t v1; // 0x19000
    int32_t v2; // 0x19004
    int32_t v3; // 0x19008
    int32_t v4; // 0x192dc
    int32_t v5; // 0x193b8
    char * v6; // 0x193bc
    struct mg_connection_1 * v7; // 0x1a9e8
    int32_t v8; // 0x1aaac
    char * v9; // 0x1bb0c
    int32_t v10; // 0x1bc07
    char * v11; // 0x1bc0c
    char * v12; // 0x1bc10
    char * v13; // 0x1bc14
    int32_t v14; // 0x1bc18
    char * v15; // 0x1bc1c
    char * v16; // 0x1bc20
    char * v17; // 0x1bc24
    int32_t v18; // 0x1bc28
    char * v19; // 0x1bc2c
    int32_t v20; // 0x1bd07
    char * v21; // 0x1bd0c
    char * v22; // 0x1bd10
    char * v23; // 0x1bd14
    int16_t * v24; // 0x1bd18
    char * v25; // 0x1bd1a
    int32_t v26; // 0x1be18
    int32_t v27; // 0x1be30
    int32_t v28; // 0x8912
    int32_t v29; // 0x92e8
    int32_t v30; // 0x9340
    int32_t v31; // 0x9348
    int32_t v32; // 0x934c
    int32_t v33; // 0x9350
    int32_t v34; // 0x9358
    int32_t v35; // 0x935c
    int32_t v36; // 0x9360
    int32_t v37; // 0x9364
    int32_t v38; // 0x9368
    int32_t v39; // 0x93a4
    int32_t v40; // 0x93b4
    int32_t v41; // 0x93c0
    int32_t v42; // 0x94cc
    int32_t v43; // 0x95cc
    int32_t v44; // 0x96cc
    int32_t v45; // 0xab74
    struct mg_context_1 * v46; // 0xbc49
    int32_t v47; // 0xc2a3
    int32_t v48; // 0xd8b1
    int32_t v49; // 0xdab9
    struct mg_context_1 * v50; // 0xdcd9
    int32_t v51; // 0xddd5
    int32_t v52; // 0xddd6
    int32_t v53; // 0xe491
    int16_t v54; // 0xffff
    char str[256];
    char str3[256];
    struct DIALData__2 * v55;
    struct DIALData__2 * newNode = v55; // bp-24
    struct _IO_FILE_2 * v56;
    struct _IO_FILE_2 * f = v56; // bp-20
    struct DIALData__2 * v57;
    struct DIALData__2 * result = v57; // bp-12
    struct _IO_FILE * file = fopen(getAppPath(app_name), "r"); // 0xed64
    f = (struct _IO_FILE_2 *)file;
    if (file == NULL) {
        // 0xee26
        return (struct DIALData__2 *)0;
    }
    // 0xedfa
    result = NULL;
    if (fscanf(file, "%255s %255s\n", &str, &str3) == -1) {
        // 0xee1a
        fclose((struct _IO_FILE *)f);
        // branch -> 0xee26
        // 0xee26
        return (struct DIALData__2 *)(int32_t)result;
    }
    newNode = (struct DIALData__2 *)malloc(12);
    int32_t len = strlen(str); // 0xed92
    malloc(len);
    malloc(len);
    int32_t str2; // 0xedac
    strcpy((char *)str2, str);
    int32_t len2 = strlen(str3); // 0xedc0
    malloc(len2);
    malloc(len2);
    int32_t str4; // 0xedda
    strcpy((char *)str4, str3);
    *(int32_t *)newNode = (int32_t)result;
    result = newNode;
    while (fscanf((struct _IO_FILE *)f, "%255s %255s\n", &str, &str3) != -1) {
        // 0xed80
        newNode = (struct DIALData__2 *)malloc(12);
        len = strlen(str);
        malloc(len);
        malloc(len);
        strcpy((char *)str2, str);
        len2 = strlen(str3);
        malloc(len2);
        malloc(len2);
        strcpy((char *)str4, str3);
        *(int32_t *)newNode = (int32_t)result;
        result = newNode;
        // continue -> 0xed80
    }
    // 0xee1a
    fclose((struct _IO_FILE *)f);
    // branch -> 0xee26
    // 0xee26
    return (struct DIALData__2 *)(int32_t)result;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/dial/src/server/dial_ipc.c
// Address range: 0xee30 - 0xee5f
// Line range:    22 - 28
void ipc_set_pipe_name(char * pipeName, int32_t * is_pipe_name_set) {
    int32_t v1; // 0x19000
    int32_t v2; // 0x19004
    int32_t v3; // 0x19008
    int32_t v4; // 0x192dc
    int32_t v5; // 0x193b8
    char * v6; // 0x193bc
    struct mg_connection_1 * v7; // 0x1a9e8
    int32_t v8; // 0x1aaac
    char * v9; // 0x1bb0c
    int32_t v10; // 0x1bc07
    char * v11; // 0x1bc0c
    char * v12; // 0x1bc10
    char * v13; // 0x1bc14
    int32_t v14; // 0x1bc18
    char * v15; // 0x1bc1c
    char * v16; // 0x1bc20
    char * v17; // 0x1bc24
    int32_t v18; // 0x1bc28
    char * v19; // 0x1bc2c
    int32_t v20; // 0x1bd07
    char * v21; // 0x1bd0c
    char * v22; // 0x1bd10
    char * v23; // 0x1bd14
    int16_t * v24; // 0x1bd18
    char * v25; // 0x1bd1a
    int32_t v26; // 0x1be18
    int32_t v27; // 0x1be30
    int32_t v28; // 0x8912
    int32_t v29; // 0x92e8
    int32_t v30; // 0x9340
    int32_t v31; // 0x9348
    int32_t v32; // 0x934c
    int32_t v33; // 0x9350
    int32_t v34; // 0x9358
    int32_t v35; // 0x935c
    int32_t v36; // 0x9360
    int32_t v37; // 0x9364
    int32_t v38; // 0x9368
    int32_t v39; // 0x93a4
    int32_t v40; // 0x93b4
    int32_t v41; // 0x93c0
    int32_t v42; // 0x94cc
    int32_t v43; // 0x95cc
    int32_t v44; // 0x96cc
    int32_t v45; // 0xab74
    struct mg_context_1 * v46; // 0xbc49
    int32_t v47; // 0xc2a3
    int32_t v48; // 0xd8b1
    int32_t v49; // 0xdab9
    struct mg_context_1 * v50; // 0xdcd9
    int32_t v51; // 0xddd5
    int32_t v52; // 0xddd6
    int32_t v53; // 0xe491
    int16_t v54; // 0xffff
    // 0xee30
    sprintf(pipeName, "/tmp/dialserver-%s", "0522");
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/dial/src/server/dial_ipc.c
// Address range: 0xee60 - 0xeed3
// Line range:    30 - 75
int32_t ipc_initialize_pipe(char * fifo_name, int32_t * is_pipe_name_set) {
    int32_t v1; // 0x19000
    int32_t v2; // 0x19004
    int32_t v3; // 0x19008
    int32_t v4; // 0x192dc
    int32_t v5; // 0x193b8
    char * v6; // 0x193bc
    struct mg_connection_1 * v7; // 0x1a9e8
    int32_t v8; // 0x1aaac
    char * v9; // 0x1bb0c
    int32_t v10; // 0x1bc07
    char * v11; // 0x1bc0c
    char * v12; // 0x1bc10
    char * v13; // 0x1bc14
    int32_t v14; // 0x1bc18
    char * v15; // 0x1bc1c
    char * v16; // 0x1bc20
    char * v17; // 0x1bc24
    int32_t v18; // 0x1bc28
    char * v19; // 0x1bc2c
    int32_t v20; // 0x1bd07
    char * v21; // 0x1bd0c
    char * v22; // 0x1bd10
    char * v23; // 0x1bd14
    int16_t * v24; // 0x1bd18
    char * v25; // 0x1bd1a
    int32_t v26; // 0x1be18
    int32_t v27; // 0x1be30
    int32_t v28; // 0x8912
    int32_t v29; // 0x92e8
    int32_t v30; // 0x9340
    int32_t v31; // 0x9348
    int32_t v32; // 0x934c
    int32_t v33; // 0x9350
    int32_t v34; // 0x9358
    int32_t v35; // 0x935c
    int32_t v36; // 0x9360
    int32_t v37; // 0x9364
    int32_t v38; // 0x9368
    int32_t v39; // 0x93a4
    int32_t v40; // 0x93b4
    int32_t v41; // 0x93c0
    int32_t v42; // 0x94cc
    int32_t v43; // 0x95cc
    int32_t v44; // 0x96cc
    int32_t v45; // 0xab74
    struct mg_context_1 * v46; // 0xbc49
    int32_t v47; // 0xc2a3
    int32_t v48; // 0xd8b1
    int32_t v49; // 0xdab9
    struct mg_context_1 * v50; // 0xdcd9
    int32_t v51; // 0xddd5
    int32_t v52; // 0xddd6
    int32_t v53; // 0xe491
    int16_t v54; // 0xffff
    // 0xee60
    if (*is_pipe_name_set == 0) {
        // 0xee76
        // branch -> 0xeeca
        // 0xeeca
        return 0;
    }
    // 0xee7a
    if (access(fifo_name, F_OK) == -1) {
        // 0xee8a
        if (mkfifo(fifo_name, 0x11b6) != 0) {
            // 0xee9c
            // branch -> 0xeeca
            // 0xeeca
            return 0;
        }
    }
    // 0xeea0
    open(fifo_name, 2050);
    open(fifo_name, 2050);
    int32_t result; // 0xeeca
    int32_t v55; // 0xeebe
    if (v55 > -1) {
        // 0xeec8
        result = 1;
        // branch -> 0xeeca
    } else {
        // 0xeec4
        result = 0;
        // branch -> 0xeeca
    }
    // 0xeeca
    return result;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/dial/src/server/dial_ipc.c
// Address range: 0xeed4 - 0xef0b
// Line range:    77 - 87
void ipc_create_pipe(char * pipe_name) {
    int32_t v1; // 0x19000
    int32_t v2; // 0x19004
    int32_t v3; // 0x19008
    int32_t v4; // 0x192dc
    int32_t v5; // 0x193b8
    char * v6; // 0x193bc
    struct mg_connection_1 * v7; // 0x1a9e8
    int32_t v8; // 0x1aaac
    char * v9; // 0x1bb0c
    int32_t v10; // 0x1bc07
    char * v11; // 0x1bc0c
    char * v12; // 0x1bc10
    char * v13; // 0x1bc14
    int32_t v14; // 0x1bc18
    char * v15; // 0x1bc1c
    char * v16; // 0x1bc20
    char * v17; // 0x1bc24
    int32_t v18; // 0x1bc28
    char * v19; // 0x1bc2c
    int32_t v20; // 0x1bd07
    char * v21; // 0x1bd0c
    char * v22; // 0x1bd10
    char * v23; // 0x1bd14
    int16_t * v24; // 0x1bd18
    char * v25; // 0x1bd1a
    int32_t v26; // 0x1be18
    int32_t v27; // 0x1be30
    int32_t v28; // 0x8912
    int32_t v29; // 0x92e8
    int32_t v30; // 0x9340
    int32_t v31; // 0x9348
    int32_t v32; // 0x934c
    int32_t v33; // 0x9350
    int32_t v34; // 0x9358
    int32_t v35; // 0x935c
    int32_t v36; // 0x9360
    int32_t v37; // 0x9364
    int32_t v38; // 0x9368
    int32_t v39; // 0x93a4
    int32_t v40; // 0x93b4
    int32_t v41; // 0x93c0
    int32_t v42; // 0x94cc
    int32_t v43; // 0x95cc
    int32_t v44; // 0x96cc
    int32_t v45; // 0xab74
    struct mg_context_1 * v46; // 0xbc49
    int32_t v47; // 0xc2a3
    int32_t v48; // 0xd8b1
    int32_t v49; // 0xdab9
    struct mg_context_1 * v50; // 0xdcd9
    int32_t v51; // 0xddd5
    int32_t v52; // 0xddd6
    int32_t v53; // 0xe491
    int16_t v54; // 0xffff
    // 0xeed4
    int32_t v55;
    int32_t pipe_name_setted = v55; // bp-12
    pipe_name_setted = 0;
    ipc_set_pipe_name(pipe_name, &pipe_name_setted);
    if (ipc_initialize_pipe(pipe_name, &pipe_name_setted) != 0) {
        // 0xef04
        return;
    }
    // 0xeefe
    exit(1);
    // UNREACHABLE
}

// Address range: 0xef70 - 0xefb3
int32_t __libc_csu_init(int32_t result, int32_t a2, int32_t a3) {
    int32_t v1; // 0x19008
    int32_t v2; // 0x192dc
    int32_t v3; // 0x193b8
    char * v4; // 0x193bc
    struct mg_connection_1 * v5; // 0x1a9e8
    int32_t v6; // 0x1aaac
    char * v7; // 0x1bb0c
    int32_t v8; // 0x1bc07
    char * v9; // 0x1bc0c
    char * v10; // 0x1bc10
    char * v11; // 0x1bc14
    int32_t v12; // 0x1bc18
    char * v13; // 0x1bc1c
    char * v14; // 0x1bc20
    char * v15; // 0x1bc24
    int32_t v16; // 0x1bc28
    char * v17; // 0x1bc2c
    int32_t v18; // 0x1bd07
    char * v19; // 0x1bd0c
    char * v20; // 0x1bd10
    char * v21; // 0x1bd14
    int16_t * v22; // 0x1bd18
    char * v23; // 0x1bd1a
    int32_t v24; // 0x1be18
    int32_t v25; // 0x1be30
    int32_t v26; // 0x8912
    int32_t v27; // 0x92e8
    int32_t v28; // 0x9340
    int32_t v29; // 0x9348
    int32_t v30; // 0x934c
    int32_t v31; // 0x9350
    int32_t v32; // 0x9358
    int32_t v33; // 0x935c
    int32_t v34; // 0x9360
    int32_t v35; // 0x9364
    int32_t v36; // 0x9368
    int32_t v37; // 0x93a4
    int32_t v38; // 0x93b4
    int32_t v39; // 0x93c0
    int32_t v40; // 0x94cc
    int32_t v41; // 0x95cc
    int32_t v42; // 0x96cc
    int32_t v43; // 0xab74
    struct mg_context_1 * v44; // 0xbc49
    int32_t v45; // 0xc2a3
    int32_t v46; // 0xd8b1
    int32_t v47; // 0xdab9
    struct mg_context_1 * v48; // 0xdcd9
    int32_t v49; // 0xddd5
    int32_t v50; // 0xddd6
    int32_t v51; // 0xe491
    int16_t v52; // 0xffff
    // 0xef70
    int32_t v53; // 0x19000
    int32_t v54 = &v53; // R5
    _init();
    int32_t v55; // 0x19004
    int32_t v56 = (int32_t)&v55 - v54; // 0xef88
    if ((v56 & 2) == 0) {
        // 0xefa8
        return result;
    }
    int32_t v57 = 0; // 0xefa0
    int32_t v58 = v54 - 4; // 0xef96
    int32_t v59; // 0xef96
    ((int32_t (*)(int32_t, int32_t, int32_t, int32_t))(v59 & -2))(result, a2, a3, v59);
    // branch -> 0xef96
    while (v57 + 1 != v56 / 4) {
        // 0xef96
        // 0xef96
        v57++;
        v58 += 4;
        ((int32_t (*)(int32_t, int32_t, int32_t, int32_t))(v59 & -2))(result, a2, a3, v59);
        // branch -> 0xef96
    }
    // 0xefa8
    return result;
}

// --------------- Dynamically Linked Functions ---------------

// int * __errno_location(void);
// int access(const char * name, int type);
// void api_send_message_to_application(int32_t a1, int32_t a2, int32_t a3);
// void api_sockIPC_event_send(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
// void api_sockIPC_get_channel(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
// void api_sockIPC_start_channel(int32_t a1);
// int bind(int fd, __CONST_SOCKADDR_ARG addr, socklen_t len);
// void * calloc(size_t nmemb, size_t size);
// int close(int fd);
// void exit(int status);
// int fclose(FILE * stream);
// int fcntl(int fd, int cmd, ...);
// int ferror(FILE * stream);
// FILE * fopen(const char * restrict filename, const char * restrict modes);
// void free(void * ptr);
// int fscanf(FILE * restrict stream, const char * restrict format, ...);
// size_t fwrite(const void * restrict ptr, size_t size, size_t n, FILE * restrict s);
// int getsockname(int fd, __SOCKADDR_ARG addr, socklen_t * restrict len);
// int gettimeofday(struct timeval * restrict tv, __timezone_ptr_t tz);
// uint32_t htonl(uint32_t hostlong);
// uint16_t htons(uint16_t hostshort);
// in_addr_t inet_addr(const char * cp);
// int ioctl(int fd, unsigned long int request, ...);
// int listen(int fd, int n);
// void * malloc(size_t size);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// void * memset(void * s, int c, size_t n);
// int mkfifo(const char * path, __mode_t mode);
// uint16_t ntohs(uint16_t netshort);
// int open(const char * file, int oflag, ...);
// DIR * opendir(const char * name);
// void perror(const char * s);
// int printf(const char * restrict format, ...);
// int pthread_attr_init(pthread_attr_t * attr);
// int pthread_attr_setdetachstate(pthread_attr_t * attr, int detachstate);
// int pthread_cond_init(pthread_cond_t * restrict cond, const pthread_condattr_t * restrict cond_attr);
// int pthread_cond_timedwait(pthread_cond_t * restrict cond, pthread_mutex_t * restrict mutex, const struct timespec * restrict abstime);
// int pthread_create(pthread_t * restrict newthread, const pthread_attr_t * restrict attr, void *(* start_routine)(void *), void * restrict arg);
// int pthread_mutex_destroy(pthread_mutex_t * mutex);
// int pthread_mutex_init(pthread_mutex_t * mutex, const pthread_mutexattr_t * mutexattr);
// int pthread_mutex_lock(pthread_mutex_t * mutex);
// int pthread_mutex_unlock(pthread_mutex_t * mutex);
// int puts(const char * s);
// ssize_t recvfrom(int fd, void * restrict buf, size_t n, int flags, __SOCKADDR_ARG addr, socklen_t * restrict addr_len);
// int regcomp(regex_t * restrict preg, const char * restrict pattern, int cflags);
// size_t regerror(int errcode, const regex_t * restrict preg, char * restrict errbuf, size_t errbuf_size);
// int regexec(const regex_t * restrict preg, const char * restrict string, size_t nmatch, regmatch_t pmatch[__restrict_arr], int eflags);
// void regfree(regex_t * preg);
// ssize_t send(int fd, const void * buf, size_t n, int flags);
// ssize_t sendto(int fd, const void * buf, size_t n, int flags, __CONST_SOCKADDR_ARG addr, socklen_t addr_len);
// int setsockopt(int fd, int level, int optname, const void * optval, socklen_t optlen);
// __sighandler_t signal(int sig, __sighandler_t handler);
// unsigned int sleep(unsigned int seconds);
// int snprintf(char * restrict s, size_t maxlen, const char * restrict format, ...);
// int socket(int domain, int type, int protocol);
// int sprintf(char * restrict s, const char * restrict format, ...);
// void srand(unsigned int seed);
// char * strcat(char * restrict dest, const char * restrict src);
// int strcmp(const char * s1, const char * s2);
// char * strcpy(char * restrict dest, const char * restrict src);
// char * strdup(const char * s);
// char * strerror(int errnum);
// size_t strlen(const char * s);
// char * strncat(char * restrict dest, const char * restrict src, size_t n);
// int strncmp(const char * s1, const char * s2, size_t n);
// char * strncpy(char * restrict dest, const char * restrict src, size_t n);
// char * strstr(char * haystack, const char * needle);
// time_t time(time_t * timer);
// int vsnprintf(char * restrict s, size_t maxlen, const char * restrict format, _G_va_list arg);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.7.3)
// Detected language: C
// Detected functions: 50
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2018-02-15 16:18:37
