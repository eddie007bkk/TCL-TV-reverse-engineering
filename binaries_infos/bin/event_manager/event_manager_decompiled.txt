//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2018 Retargetable Decompiler <info@retdec.com>
//

#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <pthread.h>
#include <signal.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stropts.h>
#include <sys/select.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/wait.h>
#include <unistd.h>

// ---------------- Integer Types Definitions -----------------

typedef int8_t int2_t;

// ------------------------ Structures ------------------------

struct ApplicationManagerController {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
};

struct _IO_FILE {
    int32_t e0;
    char * e1;
    char * e2;
    char * e3;
    char * e4;
    char * e5;
    char * e6;
    char * e7;
    char * e8;
    char * e9;
    char * e10;
    char * e11;
    struct _IO_marker * e12;
    struct _IO_FILE * e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int16_t e17;
    char e18;
    char e19[1];
    char * e20;
    int64_t e21;
    char * e22;
    char * e23;
    char * e24;
    char * e25;
    int32_t e26;
    int32_t e27;
    char e28[40];
};

struct _IO_marker {
    struct _IO_marker * e0;
    struct _IO_FILE * e1;
    int32_t e2;
};

struct _List_node_base_1 {
    struct _List_node_base_1 * e0;
    struct _List_node_base_1 * e1;
};

struct _List_impl_1 {
    struct _List_node_base_1 e0;
};

struct _List_base_lt_ApplicationManager__actionEntry_comma_std__allocator_lt_ApplicationManager__actionEntry_gt__gt__1 {
    struct _List_impl_1 e0;
};

struct _TYPEDEF_fd_set {
    int32_t e0[1];
};

struct __pthread_internal_slist {
    struct __pthread_internal_slist * e0;
};

struct __pthread_internal_slist_3 {
    struct __pthread_internal_slist_3 * e0;
};

struct __pthread_internal_slist_7 {
    struct __pthread_internal_slist_7 * e0;
};

struct __pthread_internal_slist_8 {
    struct __pthread_internal_slist_8 * e0;
};

struct __pthread_internal_slist_9 {
    struct __pthread_internal_slist_9 * e0;
};

struct __va_list {
    char * e0;
};

struct __va_list_1 {
    char * e0;
};

struct aeFileEvent {
    int32_t e0;
    void (*e1)(struct aeEventLoop *, int32_t, char *, int32_t);
    void (*e2)(struct aeEventLoop *, int32_t, char *, int32_t);
    char * e3;
};

struct aeFiredEvent {
    int32_t e0;
    int32_t e1;
};

struct aeEventLoop {
    int32_t e0;
    int64_t e1;
    struct aeFileEvent e2[10000];
    struct aeFiredEvent e3[10000];
    struct aeTimeEvent * e4;
    int32_t e5;
    char * e6;
    void (*e7)(struct aeEventLoop *);
};

struct aeTimeEvent {
    int64_t e0;
    int32_t e1;
    int32_t e2;
    int32_t (*e3)(struct aeEventLoop *, int64_t, char *);
    void (*e4)(struct aeEventLoop *, char *);
    char * e5;
    struct aeTimeEvent * e6;
};

struct anon_struct_0 {
    int32_t e0;
    struct __pthread_internal_slist e1;
};

struct __pthread_mutex_s {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    struct anon_struct_0 e5;
};

struct anon_struct_1 {
    struct __pthread_mutex_s e0;
    char e1[24];
    int32_t e2;
};

struct TAG_Mutex {
    struct anon_struct_1 e0;
};

struct anon_struct_118 {
    int32_t e0;
    char * e1[200];
};

struct anon_struct_119 {
    char * e0;
};

struct anon_struct_121 {
    int32_t e0;
    struct __pthread_internal_slist_7 e1;
};

struct __pthread_mutex_s_7 {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    struct anon_struct_121 e5;
};

struct anon_struct_122 {
    struct __pthread_mutex_s_7 e0;
    char e1[24];
    int32_t e2;
};

struct TAG_Mutex_3 {
    struct anon_struct_122 e0;
};

struct anon_struct_124 {
    int32_t e0;
    int32_t e1;
    int64_t e2;
    int64_t e3;
    int64_t e4;
    char * e5;
    int32_t e6;
    int32_t e7;
};

struct anon_struct_125 {
    struct anon_struct_124 e0;
    char e1[48];
    int64_t e2;
};

struct TAG_WaitCond_2 {
    struct anon_struct_125 e0;
};

struct anon_struct_129 {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3[4];
    char * e4;
};

struct anon_struct_131 {
    int32_t e0;
    struct __pthread_internal_slist_8 e1;
};

struct __pthread_mutex_s_8 {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    struct anon_struct_131 e5;
};

struct anon_struct_132 {
    struct __pthread_mutex_s_8 e0;
    char e1[24];
    int32_t e2;
};

struct TAG_Mutex_4 {
    struct anon_struct_132 e0;
};

struct anon_struct_133 {
    int32_t e0;
    int32_t e1;
    int64_t e2;
    int64_t e3;
    int64_t e4;
    char * e5;
    int32_t e6;
    int32_t e7;
};

struct anon_struct_134 {
    struct anon_struct_133 e0;
    char e1[48];
    int64_t e2;
};

struct TAG_WaitCond_3 {
    struct anon_struct_134 e0;
};

struct anon_struct_139 {
    struct APPMNGR_EventQ_Ctrl_1 * e0;
    int32_t * e1;
};

struct anon_struct_140 {
    char e0[16];
};

struct anon_struct_142 {
    int32_t e0;
    struct __pthread_internal_slist_9 e1;
};

struct __pthread_mutex_s_9 {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    struct anon_struct_142 e5;
};

struct anon_struct_143 {
    struct __pthread_mutex_s_9 e0;
    char e1[24];
    int32_t e2;
};

struct TAG_Mutex_5 {
    struct anon_struct_143 e0;
};

struct anon_struct_144 {
    int32_t e0;
    int32_t e1;
    int64_t e2;
    int64_t e3;
    int64_t e4;
    char * e5;
    int32_t e6;
    int32_t e7;
};

struct anon_struct_145 {
    struct anon_struct_144 e0;
    char e1[48];
    int64_t e2;
};

struct TAG_WaitCond_4 {
    struct anon_struct_145 e0;
};

struct anon_struct_150 {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    char e3[64];
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    char * e9;
    int32_t e10;
};

struct anon_struct_151 {
    struct TAG_Mutex_5 e0;
    struct TAG_WaitCond_4 e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
};

struct anon_struct_2 {
    int32_t e0;
    int32_t e1;
    int64_t e2;
    int64_t e3;
    int64_t e4;
    char * e5;
    int32_t e6;
    int32_t e7;
};

struct anon_struct_23 {
    int32_t e0;
    struct __pthread_internal_slist_3 e1;
};

struct __pthread_mutex_s_3 {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    struct anon_struct_23 e5;
};

struct anon_struct_24 {
    struct __pthread_mutex_s_3 e0;
    char e1[24];
    int32_t e2;
};

struct TAG_Mutex_2 {
    struct anon_struct_24 e0;
};

struct anon_struct_25 {
    int32_t e0;
    int32_t e1;
    int64_t e2;
    int64_t e3;
    int64_t e4;
    char * e5;
    int32_t e6;
    int32_t e7;
};

struct anon_struct_26 {
    struct anon_struct_25 e0;
    char e1[48];
    int64_t e2;
};

struct TAG_WaitCond_1 {
    struct anon_struct_26 e0;
};

struct anon_struct_3 {
    struct anon_struct_2 e0;
    char e1[48];
    int64_t e2;
};

struct TAG_WaitCond {
    struct anon_struct_3 e0;
};

struct anon_struct_31 {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    char e3[64];
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    char * e9;
    int32_t e10;
};

struct anon_struct_36 {
    int32_t e0;
    int32_t e1;
    int32_t e2;
};

struct anon_struct_41 {
    int32_t e0;
    char e1[5];
    int32_t e2;
    char e3[10];
};

struct epoll_data {
    char * e0;
    int32_t e1;
    int32_t e2;
    int64_t e3;
};

struct epoll_event {
    int32_t e0;
    struct epoll_data e1;
};

struct ifmap {
    int32_t e0;
    int32_t e1;
    int16_t e2;
    char e3;
    char e4;
    char e5;
};

struct iovec {
    char * e0;
    int32_t e1;
};

struct list {
    struct listNode * e0;
    struct listNode * e1;
    char * (*e2)(char *);
    void (*e3)(char *);
    int32_t (*e4)(char *, char *);
    int32_t e5;
};

struct listIter_1 {
    struct listNode_1 * e0;
    int32_t e1;
};

struct listNode {
    struct listNode * e0;
    struct listNode * e1;
    char * e2;
};

struct listNode_1 {
    struct listNode_1 * e0;
    struct listNode_1 * e1;
    char * e2;
};

struct list_1 {
    struct listNode_1 * e0;
    struct listNode_1 * e1;
    char * (*e2)(char *);
    void (*e3)(char *);
    int32_t (*e4)(char *, char *);
    int32_t e5;
};

struct list_head {
    struct list_head * e0;
    struct list_head * e1;
};

struct TAG_TaskStack {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    struct TAG_Mutex e4;
    struct TAG_WaitCond e5;
    struct list_head e6;
    int32_t (*e7)(struct TAG_TaskStack *);
    struct service_ptr__lb__TAG_TaskStack_ptr__comma_i32_comma_void_ptr__rb_ * e8;
    int32_t (*e9)(struct TAG_TaskStack *, int32_t, char *, int32_t *, int32_t *);
    int32_t (*e10)(struct TAG_TaskStack *, int32_t, int32_t);
    int32_t (*e11)(struct TAG_TaskStack *, struct service *);
    int32_t (*e12)(struct TAG_TaskStack *, struct service *);
    int32_t (*e13)(char *);
    int32_t (*e14)(struct TAG_TaskStack *);
    void (*e15)(struct TAG_TaskStack *);
};

struct list_head_1 {
    struct list_head_1 * e0;
    struct list_head_1 * e1;
};

struct APPMNGR_EventQ_Ctrl {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    struct TAG_Mutex_2 e3;
    struct TAG_WaitCond_1 e4;
    struct list_head_1 e5;
    int32_t (*e6)(struct TagEventItem *);
    int32_t (*e7)(struct TagEventItem *);
    int32_t (*e8)(struct APPMNGR_EventQ_Ctrl *);
    int32_t (*e9)(struct APPMNGR_EventQ_Ctrl *);
    int32_t (*e10)(struct APPMNGR_EventQ_Ctrl *);
    int32_t (*e11)(struct APPMNGR_EventQ_Ctrl *, int32_t, int32_t);
    int32_t (*e12)(struct APPMNGR_EventQ_Ctrl *, struct TagEventItem *);
    int32_t (*e13)(struct APPMNGR_EventQ_Ctrl *, struct TagEventItem *);
    int32_t (*e14)(struct APPMNGR_EventQ_Ctrl *);
    int32_t (*e15)(struct APPMNGR_EventQ_Ctrl *, struct TagEventItem *);
    int32_t (*e16)(struct APPMNGR_EventQ_Ctrl *);
    int32_t (*e17)(struct APPMNGR_EventQ_Ctrl *, int32_t, char *);
    int32_t (*e18)(struct APPMNGR_EventQ_Ctrl *);
    int32_t (*e19)(struct APPMNGR_EventQ_Ctrl *);
    int32_t (*e20)(struct APPMNGR_EventQ_Ctrl *);
    int32_t (*e21)(struct TagEventItem *);
    int32_t (*e22)(struct TagEventItem *);
};

struct TagEventItem {
    int32_t e0;
    int32_t e1;
    char * e2;
    char e3[104];
    struct list_head_1 e4;
};

struct list_head_4 {
    struct list_head_4 * e0;
    struct list_head_4 * e1;
};

struct APPMNGR_EventQ_Ctrl_1 {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    struct TAG_Mutex_4 e3;
    struct TAG_WaitCond_3 e4;
    struct list_head_4 e5;
    int32_t (*e6)(struct TagEventItem_3 *);
    int32_t (*e7)(struct TagEventItem_3 *);
    int32_t (*e8)(struct APPMNGR_EventQ_Ctrl_1 *);
    int32_t (*e9)(struct APPMNGR_EventQ_Ctrl_1 *);
    int32_t (*e10)(struct APPMNGR_EventQ_Ctrl_1 *);
    int32_t (*e11)(struct APPMNGR_EventQ_Ctrl_1 *, int32_t, int32_t);
    int32_t (*e12)(struct APPMNGR_EventQ_Ctrl_1 *, struct TagEventItem_3 *);
    int32_t (*e13)(struct APPMNGR_EventQ_Ctrl_1 *, struct TagEventItem_3 *);
    int32_t (*e14)(struct APPMNGR_EventQ_Ctrl_1 *);
    int32_t (*e15)(struct APPMNGR_EventQ_Ctrl_1 *, struct TagEventItem_3 *);
    int32_t (*e16)(struct APPMNGR_EventQ_Ctrl_1 *);
    int32_t (*e17)(struct APPMNGR_EventQ_Ctrl_1 *, int32_t, char *);
    int32_t (*e18)(struct APPMNGR_EventQ_Ctrl_1 *);
    int32_t (*e19)(struct APPMNGR_EventQ_Ctrl_1 *);
    int32_t (*e20)(struct APPMNGR_EventQ_Ctrl_1 *);
    int32_t (*e21)(struct TagEventItem_3 *);
    int32_t (*e22)(struct TagEventItem_3 *);
};

struct TagEventItem_3 {
    int32_t e0;
    int32_t e1;
    char * e2;
    char e3[104];
    struct list_head_4 e4;
};

struct list_head_5 {
    struct list_head_5 * e0;
    struct list_head_5 * e1;
};

struct TAG_TaskStack_1 {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    struct TAG_Mutex_5 e4;
    struct TAG_WaitCond_4 e5;
    struct list_head_5 e6;
    int32_t (*e7)(struct TAG_TaskStack_1 *);
    struct service_1_ptr__lb__TAG_TaskStack_1_ptr__comma_i32_comma_void_ptr__rb_ * e8;
    int32_t (*e9)(struct TAG_TaskStack_1 *, int32_t, char *, int32_t *, int32_t *);
    int32_t (*e10)(struct TAG_TaskStack_1 *, int32_t, int32_t);
    int32_t (*e11)(struct TAG_TaskStack_1 *, struct service_1 *);
    int32_t (*e12)(struct TAG_TaskStack_1 *, struct service_1 *);
    int32_t (*e13)(char *);
    int32_t (*e14)(struct TAG_TaskStack_1 *);
    void (*e15)(struct TAG_TaskStack_1 *);
};

struct PM_OBJ_TAG {
    struct TAG_TaskStack_1 e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    struct service_1 * e4;
    struct list_head_5 e5;
    struct list_head_5 e6;
    int32_t e7;
    struct anon_struct_151 e8;
    struct tag_KeySetNode * e9[12];
    struct list_head_5 e10;
    struct TAG_Mutex_5 e11;
    int32_t (*e12)(struct PM_OBJ_TAG *, int32_t, char);
    int32_t (*e13)(int32_t, struct anon_struct_150 *);
    int32_t (*e14)(int32_t, struct anon_struct_150 *);
    int32_t (*e15)(struct anon_struct_150 *);
    int32_t (*e16)(int32_t);
    int32_t (*e17)(char *);
    int32_t (*e18)();
    int32_t (*e19)();
    int32_t (*e20)(int32_t);
    int32_t (*e21)(int32_t, struct anon_struct_150 *);
    int32_t (*e22)(int32_t, struct anon_struct_150 *);
};

struct list_lt_ApplicationManager__actionEntry {
    int32_t e0;
};

struct msghdr {
    char * e0;
    int32_t e1;
    struct iovec * e2;
    int32_t e3;
    char * e4;
    int32_t e5;
    int32_t e6;
};

struct parse_state {
    char * e0;
    char * e1;
    int32_t e2;
    int32_t e3;
    char * e4;
    void (*e5)(struct parse_state *, int32_t, char **);
    char * e6;
};

struct redisClient {
    int32_t e0;
    char * e1;
    int32_t e2;
    struct redisObject ** e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    struct list * e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    char e12[9000];
};

struct redisObject {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    char * e5;
};

struct service {
    struct list_head e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t * e5;
    int32_t e6;
    char * e7;
    char * e8;
    int32_t e9;
    char * e10;
    int32_t e11;
    int32_t e12;
    int32_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
    int32_t e20;
    int32_t e21[12];
    int32_t e22;
    struct socketinfo * e23;
    struct svcenvinfo * e24;
    int32_t e25;
    char * e26[1];
};

struct service_1 {
    struct list_head_5 e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t * e5;
    int32_t e6;
    char * e7;
    char * e8;
    int32_t e9;
    char * e10;
    int32_t e11;
    int32_t e12;
    int32_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
    int32_t e20;
    int32_t e21[12];
    int32_t e22;
    struct socketinfo_1 * e23;
    struct svcenvinfo_1 * e24;
    int32_t e25;
    char * e26[1];
};

struct service_1_ptr__lb__TAG_TaskStack_1_ptr__comma_i32_comma_void_ptr__rb_ {
    int32_t e0;
};

struct service_ptr__lb__TAG_TaskStack_ptr__comma_i32_comma_void_ptr__rb_ {
    int32_t e0;
};

struct sockaddr {
    int16_t e0;
    char e1[14];
};

struct sockaddr_2 {
    int16_t e0;
    char e1[14];
};

struct anon_struct_141 {
    struct sockaddr_2 e0;
    struct sockaddr_2 e1;
    struct sockaddr_2 e2;
    struct sockaddr_2 e3;
    struct sockaddr_2 e4;
    int16_t e5;
    int32_t e6;
    int32_t e7;
    struct ifmap e8;
    char e9[16];
    char e10[16];
    char * e11;
};

struct ifreq {
    struct anon_struct_140 e0;
    struct anon_struct_141 e1;
};

struct sockaddr_un {
    int16_t e0;
    char e1[108];
};

struct sockaddr_un_2 {
    int16_t e0;
    char e1[108];
};

struct ApplicationManager_1 {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    struct anon_struct_119 e5;
    char e6[5];
    char e7[50];
    int32_t e8;
    int32_t e9;
    char ** e10;
    struct anon_struct_118 e11;
    char * e12;
    struct sockaddr_un_2 e13;
    struct sockaddr_un_2 e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    struct list_lt_ApplicationManager__actionEntry e18;
    int32_t e19;
    bool e20;
};

struct socketinfo {
    int32_t e0;
};

struct socketinfo_1 {
    struct socketinfo_1 * e0;
    char * e1;
    char * e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
};

struct svcenvinfo {
    int32_t e0;
};

struct svcenvinfo_1 {
    struct svcenvinfo_1 * e0;
    char * e1;
    char * e2;
};

struct tag_KeySetNode {
    int32_t e0;
    int32_t e1;
    char * e2;
    struct tag_KeySetNode * e3;
    struct tag_KeySetNode * e4;
};

struct timeval {
    int32_t e0;
    int32_t e1;
};

struct timeval_3 {
    int32_t e0;
    int32_t e1;
};

struct ucred {
    int32_t e0;
    int32_t e1;
    int32_t e2;
};

// ------------------- Function Prototypes --------------------

int32_t __do_global_dtors_aux(int32_t result);
int32_t __libc_csu_init(int32_t result, int32_t a2, int32_t a3);
void _init(void);
void _ZN18ApplicationManager10makeArgs_QEPKcPS_(struct ApplicationManager_1 * this, char * pData, struct ApplicationManager_1 * pobject);
void _ZN18ApplicationManager11exit_notifyEPvi(char * p_AM, int32_t appPID);
void _ZN18ApplicationManager12ListCommandsEv(void);
void _ZN18ApplicationManager13parse_cmdlineEPKcPNS_9Args_MainE(struct ApplicationManager_1 * this, char * cmd, struct anon_struct_118 * pout_args);
void _ZN18ApplicationManager17setenv_model_nameEv(struct ApplicationManager_1 * this);
void _ZN18ApplicationManager18setenv_frc_featureEv(struct ApplicationManager_1 * this);
void _ZN18ApplicationManager23setenv_firmware_versionEv(struct ApplicationManager_1 * this);
void _ZN18ApplicationManager25ControllerCommandToStringENS_17ControllerCommandE(int32_t cmd);
void _ZN18ApplicationManager25StringToControllerCommandEPKc(char * cmd);
void _ZN18ApplicationManager4initEPKc(struct ApplicationManager_1 * this, char * language);
void _ZN18ApplicationManagerC2Eii(struct ApplicationManager_1 * this, int32_t efd, int32_t echo_efd);
void _ZN28ApplicationManagerController31SendCommandToApplicationManagerEN18ApplicationManager17ControllerCommandE(struct ApplicationManagerController * this, int32_t cmd);
void _ZN28ApplicationManagerController4execEPKcS1_PvS2_(char * cmd_string, char * pData, char * pThis, char * pTargetThis);
void _ZN28ApplicationManagerController4initEv(struct ApplicationManagerController * this);
void _ZN28ApplicationManagerControllerC2Ev(struct ApplicationManagerController * this);
void _ZNSt10_List_baseIN18ApplicationManager11actionEntryESaIS1_EE8_M_clearEv(struct _List_base_lt_ApplicationManager__actionEntry_comma_std__allocator_lt_ApplicationManager__actionEntry_gt__gt__1 * this);
struct aeEventLoop * aeCreateEventLoop(void);
int32_t aeCreateFileEvent(struct aeEventLoop * eventLoop, int32_t fd, int32_t mask, void (*proc)(struct aeEventLoop *, int32_t, char *, int32_t), char * clientData);
void aeDeleteEventLoop(struct aeEventLoop * eventLoop);
void aeDeleteFileEvent(struct aeEventLoop * eventLoop, int32_t fd, int32_t mask);
int32_t aeDeleteTimeEvent(struct aeEventLoop * eventLoop, int64_t id);
void aeGetTime(int32_t * seconds, int32_t * milliseconds);
void aeMain(struct aeEventLoop * eventLoop);
int32_t aeProcessEvents(struct aeEventLoop * eventLoop, uint32_t flags);
void amc_disable_netflix_key_event(void);
int32_t amc_send_netflix_start_dummy(void);
void anetCreateSocket(char * err, int32_t domain);
void anetListen(char * err, int32_t s, struct sockaddr * sa, int32_t len);
void anetSetError(char * err, char * fmt, ...);
int32_t anetUnixServer(char * err, char * path);
int32_t appmngr_adjust_keyset_by_proc_name(char * name, int32_t nMask, int32_t level1, int32_t level0);
void appmngr_dump_keySetArr(void);
int32_t appmngr_dynamic_adjust_interactive_list(void);
int32_t appmngr_eventqueue_construct(struct APPMNGR_EventQ_Ctrl * thiz);
int32_t appmngr_ipc_broadcast_event_to_slaves(void);
int32_t appmngr_monitor_process_status(int32_t block);
int32_t appmngr_mutex_init(struct TAG_Mutex_3 * mutex);
int32_t appmngr_mutex_lock(struct TAG_Mutex_3 * mutex);
int32_t appmngr_mutex_unlock(struct TAG_Mutex_3 * mutex);
int32_t appmngr_pm_check_focus_process(void);
int32_t appmngr_pm_clear_terminative_process(int32_t pid_child, int32_t kill_flag, int32_t type, char * param);
int32_t appmngr_pm_get_key_feedback(int32_t result);
int32_t appmngr_pm_init_ini(void);
int32_t appmngr_pm_init_rc(void);
int32_t appmngr_pm_install_focus(void);
int32_t appmngr_pm_key_set_delete(int32_t sockfd);
int32_t appmngr_pm_monitor_detached_process(void);
int32_t appmngr_pm_process_rm_pid(int32_t pid);
int32_t appmngr_push_process_manage_event(int32_t sockfd, struct anon_struct_31 * pPmMsg);
int32_t appmngr_push_system_virtual_event(struct anon_struct_36 * sysEvent);
int32_t appmngr_send_msg_netflix_exit_dummy(void);
int32_t appmngr_send_msg_netflix_start_dummy(void);
int32_t appmngr_send_msg_to_ui_by_transpond(void);
int32_t appmngr_server_free_client(int32_t sockfd);
void appmngr_taskstack_construct(struct TAG_TaskStack * thiz);
int32_t appmngr_taskstack_item_attach_input(void);
int32_t appmngr_waitcond_init(struct TAG_WaitCond_2 * waitcond);
int32_t appmngr_waitcond_signal(struct TAG_WaitCond_2 * waitcond);
void call_gmon_start(void);
int32_t check_network(char * dev_name);
int32_t checksum_ok(void);
int32_t cmd_netflix_background(void);
int32_t cmd_netflix_clear_user_accounts(int32_t re_launch);
int32_t cmd_netflix_down(void);
int32_t cmd_netflix_enter(void);
int32_t cmd_netflix_exit(void);
int32_t cmd_netflix_left(void);
int32_t cmd_netflix_reset_when_factory_default(void);
int32_t cmd_netflix_resume(void);
int32_t cmd_netflix_right(void);
int32_t cmd_netflix_sigkill(void);
int32_t cmd_netflix_sleep(void);
int32_t cmd_netflix_start_by_button(void);
int32_t cmd_netflix_start_by_dial(char * payload);
int32_t cmd_netflix_start_by_icon(void);
int32_t cmd_netflix_start_by_power_hotkey(void);
int32_t cmd_netflix_start_foreground(void);
int32_t cmd_netflix_start_suspend(void);
int32_t cmd_netflix_stop_dial(void);
int32_t cmd_netflix_stop_resources(void);
int32_t cmd_netflix_stop_user(char * type);
int32_t cmd_netflix_suspend(void);
int32_t cmd_netflix_up(void);
int32_t cmd_netflix_wake(void);
void config_network_check(int32_t value, char * dev);
struct APPMNGR_EventQ_Ctrl * create_eventQ_ctrl_obj(void);
int32_t create_socket(char * name, int32_t type, int32_t perm, int32_t uid, int32_t gid);
int32_t deinit_event_queue_mem(void);
int32_t deinit_queue_mem(struct anon_struct_129 * pmanObj);
int32_t deregister_tm_clones(void);
void disable_netflix_key_event(void);
int32_t Do_Ctrl_Cmd_Netflix(char * cmd, char * pData);
void dump_event(struct TagEventItem * evt, int32_t option, int32_t evtQ_num);
void DUMP_service(void);
int32_t errno_switch(int32_t erno);
int32_t exec_netflix_control_command(int32_t operation, char * pUrl);
int32_t frame_dummy(int32_t a1, int32_t a2);
void freeClient(struct redisClient * c);
int32_t function_101fe(int32_t a1, int32_t a2);
int32_t function_10216(int32_t a1, int32_t a2);
int32_t function_1045a(int32_t a1, int32_t a2);
int32_t function_1055a(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_1071e(int32_t a1, int32_t a2);
int32_t function_10b0a(int32_t a1, int32_t a2);
int32_t function_10eba(int32_t result);
int32_t function_10eda(int32_t result);
int32_t function_11172(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_13292(int32_t a1, int32_t a2);
int32_t function_132bc(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10);
int32_t function_1338a(void);
int32_t function_13390(void);
int32_t function_14220(int32_t a1, int32_t a2);
int32_t function_1423e(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9);
int32_t function_144d6(int32_t a1);
int32_t function_144e4(void);
int32_t function_14592(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t str, int32_t a11);
void function_145dc(void);
void function_15514(void);
int32_t function_e6ce(int32_t a1, int32_t a2);
int32_t function_e6ea(int32_t result, int32_t a2);
int32_t function_e772(int32_t result);
int32_t function_e936(int32_t result);
int32_t function_e956(int32_t result);
int32_t function_eb9a(int32_t a1, int32_t a2, int32_t a3);
int32_t function_f9e2(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_fe7e(int32_t a1, int32_t a2);
int32_t function_fe96(int32_t a1, int32_t a2);
struct APPMNGR_EventQ_Ctrl * get_eventQ_ctrl_obj(void);
int32_t get_pm_focus_fd(void);
struct PM_OBJ_TAG * get_process_mngr_obj(void);
int32_t handle_property_set_fd(int32_t fd, int32_t flag_cred);
int32_t ini_parser_create(char * file_name);
int32_t ini_parser_destory(void);
int32_t init_event_queue_mem(void);
int32_t init_input_capture(int32_t argc, char ** argv);
int32_t init_netflix_manager_module(void);
int32_t init_queue_mem(struct anon_struct_129 * pmanObj, int32_t sizeUnit);
int32_t init_socket_server_module(int32_t with_thread, int32_t * flag_ready);
int32_t init_task_queue_mem(void);
int32_t init_taskQ_ctrl_obj(struct TAG_TaskStack * stack_ctrl);
struct list_1 * listCreate(void);
void listDelNode(struct list_1 * list, struct listNode_1 * node);
struct listIter_1 * listGetIterator(struct list_1 * list, int32_t direction);
struct listNode_1 * listNext(struct listIter_1 * iter);
void listRelease(struct list_1 * list);
void listReleaseIterator(struct listIter_1 * iter);
struct listNode_1 * listSearchKey(struct list_1 * list, char * key);
int32_t LoadIniFile(void);
int32_t lock_mutex_server(void);
int32_t lock_send_buffer(void);
int32_t lookup_keyword(char * s);
int32_t main_process_manager(void);
int32_t main_test_svc(void);
int32_t netflix_get_system_info(struct anon_struct_41 * pst, int32_t mask);
int32_t netflix_home_key_process(void);
int32_t netflix_power_off_process(void);
int32_t next_token(struct parse_state * state);
int32_t notify_netflix_exit_from_em(int32_t pid);
void parse_config(char * fn, char * s);
int32_t parse_config_file(char * fn);
void parse_error(struct parse_state * state, char * fmt, ...);
void parse_new_section(struct parse_state * state, int32_t kw, int32_t nargs, char ** args);
void print_timestamp(char * str);
int32_t proc_netflix_exit_cleanup(uint32_t exit_code);
int32_t process_client(int32_t c, char ** uidlist);
char * read_file(char * fn, int32_t * _sz);
int32_t recv_cred(int32_t s, struct ucred * credp, char * buf, int32_t bufsiz, char * addr, int32_t * alen);
int32_t register_tm_clones(void);
int32_t release_process_by_pid(int32_t pid);
void sdsfree(char * s);
int32_t send_cred(int32_t fd);
int32_t send_waiting_status_to_amc(int32_t message);
struct service_1 * service_find_by_name(char * name);
struct service_1 * service_find_by_pid(int32_t pid);
void service_for_each(void (*func)(struct service_1 *));
void service_stop(struct service_1 * svc);
void start_event_loop_thread(struct anon_struct_139 * param);
int32_t start_socket_service(char * name);
int32_t test_server_unix_socket_simply(void);
int32_t test_server_unix_socket_ucred(void);
void unblockClientWaitingData(struct redisClient * c);
int32_t unknown_e23c(int32_t a1, int32_t a2);
int32_t unknown_e580(void);
int32_t unlock_mutex_server(void);
int32_t unlock_send_buffer(void);
void valid_name(char * name);
int32_t wait_status_by_seconds(int32_t tm_sec, int32_t wait_msg);

// --------------------- Global Variables ---------------------

char * boot_cmdline = "\x10\x7e\x01";
int32_t cmptr = 0;
char dev_network_checking[10];
int32_t enable_network_checking = 0;
char env_str_image_version[128];
int32_t evtQueueObjCtrl = 0;
int32_t mApplicationPid_bak = 0;
int32_t mProcMngrObj = 0;
int32_t mRestartCounter = 0;
int32_t memManObj_EventQ = 0;
int32_t memManObj_TaskQ = 0;
struct ApplicationManagerController * ptr_AMC = NULL;
char str_frc[10];
char str_model_name[100];
char test[4608];
int32_t wait_eventFd = -1;

// ------------------------ Functions -------------------------

// Address range: 0xe02c - 0xe035
void _init(void) {
    int32_t v1 = 0x821014b; // 0x101c1
    int32_t v2 = -0x1608004b; // 0x111f1
    int32_t v3 = -0x54b00f17; // 0x12d09
    int32_t v4 = 0x4b0a0b5; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **) = (void (*)(struct parse_state *, int32_t, char **))0x28bf0047; // 0x13fed
    int32_t v6 = 223; // 0x14b14
    int16_t * v7 = (int16_t *)0x360024; // 0x14cde
    int32_t v8 = 0x4b5106b; // 0x157c5
    int32_t v9 = 0x45280046; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11 = 0xe759; // 0x21098
    int32_t v12 = 0xe741; // 0x2109c
    int32_t v13 = 0; // 0x210a0
    int32_t v14 = 1; // 0x210a4
    int32_t * v15 = &v16; // 0x211dc
    int32_t v17 = 0x11241; // 0x213b8
    char * (**v18)(char *) = (char * (**)(char *))0x13d01; // 0x213bc
    int32_t * v19 = &v20; // 0x213c8
    int32_t * v21 = &mRestartCounter; // 0x213cc
    struct ApplicationManagerController ** v22 = &ptr_AMC; // 0x213d0
    int32_t v23 = 0x111f1; // 0x213d4
    char (*v24)[10] = &str_frc; // 0x213e0
    char * v25[2] = {&str_model_name[0], (char *)&v3}; // 0x213e4
    char * (**v26)(char *) = (char * (**)(char *))0x12d09; // 0x213e8
    char * v27 = "\xa0\x1b\x02"; // 0x213ec
    int16_t * v28 = (int16_t *)0x10d91; // 0x213f0
    char * v29 = "\x01"; // 0x213f2
    char * v30 = "\xb0\x31\x02"; // 0x213f4
    int32_t v31 = 0x10f81; // 0x213f8
    int32_t v32 = 0x10f09; // 0x21400
    int32_t v33 = 0xea25; // 0x21404
    void (*v34)(struct aeEventLoop *, int32_t, char *, int32_t) = (void (*)(struct aeEventLoop *, int32_t, char *, int32_t))0xfa6d; // 0x21408
    char (*v35)[128] = &env_str_image_version; // 0x21418
    int32_t v36 = 0x10e01; // 0x2141c
    int32_t v37 = 0x10da1; // 0x21420
    char ** v38 = &boot_cmdline; // 0x21424
    int32_t v39 = 0x10fdd; // 0x21428
    int32_t v40 = 0x11059; // 0x21434
    int32_t v41; // 0x21438
    int32_t * v42 = &mApplicationPid_bak; // 0x2143c
    int32_t v43 = 0x10d95; // 0x21440
    int32_t v44 = 0x21c7c; // 0x21448
    int32_t v45 = 0x10d75; // 0x2144c
    int32_t v46 = 0x10e6d; // 0x21450
    int32_t v47 = 0; // 0x21458
    int32_t v48 = 0x15665; // 0x21460
    char * v49 = "\x02"; // 0x21470
    int32_t v50 = 3; // 0x21498
    int32_t v51 = 0x12c61; // 0x214a4
    char * v52 = "\x02"; // 0x215d8
    int32_t v20 = 1; // 0x217b4
    char * v53; // 0x21ae8
    char * v54; // 0x2292e
    int32_t v55 = 0; // 0x22f95
    int32_t v56 = 0; // 0x22f9c
    int32_t v57 = 0; // 0x22fa0
    int32_t v58 = 0; // 0x22fa4
    int32_t v59 = 0; // 0x22fb0
    struct TAG_Mutex_3 * v60 = NULL; // 0x22fb8
    char * v61; // 0x22fd4
    int32_t v62 = 0; // 0x22fdc
    int32_t v63 = 0; // 0x2300c
    int32_t v64 = 0; // 0x2301c
    int32_t v65 = 0; // 0x23030
    int32_t v66 = 0; // 0x23034
    int32_t v67 = 0; // 0x23038
    struct PM_OBJ_TAG * v68 = NULL; // 0x2303c
    int32_t v69 = 0; // 0x23040
    int32_t v70 = 0; // 0x23044
    int32_t v71 = 0; // 0x23048
    int32_t v72 = 0; // 0x2304c
    struct TAG_Mutex_3 * v73 = NULL; // 0x23058
    struct TAG_WaitCond_2 * v74 = NULL; // 0x23070
    int32_t v75 = 0; // 0x230a0
    int32_t v76 = 0; // 0x230a4
    int32_t v77 = 0; // 0x230e0
    int32_t v78 = 0; // 0x230e4
    struct TAG_Mutex_3 * v79 = NULL; // 0x230e8
    char * v80; // 0x23100
    int32_t v81 = 0; // 0x23104
    int32_t v82 = 0; // 0x23108
    int32_t v83 = 0; // 0x2310c
    int32_t v84 = 0; // 0x23110
    int32_t v85 = 0; // 0x23114
    int32_t v86 = 0; // 0x23118
    int32_t v87 = 0; // 0x2311c
    int32_t v88 = 0; // 0x23120
    int32_t v89 = 0; // 0x23124
    int32_t v90 = 0; // 0x23128
    int32_t v91 = 0x6f0000; // 0x8946
    int32_t v92 = 0x120000; // 0xa6f2
    int32_t v93 = 0x10001; // 0xdba0
    int32_t v94 = 0x34010e8; // 0xf00b
    int32_t v95 = -0x2f1742ba; // 0xf053
    int32_t v96 = 0x20f5b1bf; // 0xf207
    int32_t v97 = 0xf200c4b; // 0xfa6d
    // 0xe02c
    call_gmon_start();
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_main.c
// Address range: 0xe5b4 - 0xe69f
// Line range:    306 - 467
int main(int argc, char ** argv) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0xe5b4
    create_eventQ_ctrl_obj();
    return -1;
}

// Address range: 0xe6ce - 0xe6d7
int32_t function_e6ce(int32_t a1, int32_t a2) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0xe6ce
    return unknown_e23c(a1, a1);
}

// Address range: 0xe6d8 - 0xe6e9
void call_gmon_start(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21460
    char * v46; // 0x21470
    int32_t v47; // 0x21498
    int32_t v48; // 0x214a4
    char * v49; // 0x215d8
    int32_t v50; // 0x217b4
    char * v51; // 0x21ae8
    char * v52; // 0x2292e
    int32_t v53; // 0x22f95
    int32_t v54; // 0x22f9c
    int32_t v55; // 0x22fa0
    int32_t v56; // 0x22fa4
    int32_t v57; // 0x22fb0
    struct TAG_Mutex_3 * v58; // 0x22fb8
    char * v59; // 0x22fd4
    int32_t v60; // 0x22fdc
    int32_t v61; // 0x2300c
    int32_t v62; // 0x2301c
    int32_t v63; // 0x23030
    int32_t v64; // 0x23034
    int32_t v65; // 0x23038
    struct PM_OBJ_TAG * v66; // 0x2303c
    int32_t v67; // 0x23040
    int32_t v68; // 0x23044
    int32_t v69; // 0x23048
    int32_t v70; // 0x2304c
    struct TAG_Mutex_3 * v71; // 0x23058
    struct TAG_WaitCond_2 * v72; // 0x23070
    int32_t v73; // 0x230a0
    int32_t v74; // 0x230a4
    int32_t v75; // 0x230e0
    int32_t v76; // 0x230e4
    struct TAG_Mutex_3 * v77; // 0x230e8
    char * v78; // 0x23100
    int32_t v79; // 0x23104
    int32_t v80; // 0x23108
    int32_t v81; // 0x2310c
    int32_t v82; // 0x23110
    int32_t v83; // 0x23114
    int32_t v84; // 0x23118
    int32_t v85; // 0x2311c
    int32_t v86; // 0x23120
    int32_t v87; // 0x23124
    int32_t v88; // 0x23128
    int32_t v89; // 0x8946
    int32_t v90; // 0xa6f2
    int32_t v91; // 0xdba0
    int32_t v92; // 0xf00b
    int32_t v93; // 0xf053
    int32_t v94; // 0xf207
    int32_t v95; // 0xfa6d
    // 0xe6d8
    int32_t v96; // 0x21458
    if (v96 == 0) {
        // 0xe6e6
        return;
    }
    // 0xe6e2
    unknown_e580();
    unknown_e580();
}

// Address range: 0xe6ea - 0xe6ef
int32_t function_e6ea(int32_t result, int32_t a2) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0xe6ea
    return result;
}

// Address range: 0xe6f0 - 0xe713
int32_t deregister_tm_clones(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x2292e
    int32_t v53; // 0x22f95
    int32_t v54; // 0x22f9c
    int32_t v55; // 0x22fa0
    int32_t v56; // 0x22fa4
    int32_t v57; // 0x22fb0
    struct TAG_Mutex_3 * v58; // 0x22fb8
    char * v59; // 0x22fd4
    int32_t v60; // 0x22fdc
    int32_t v61; // 0x2300c
    int32_t v62; // 0x2301c
    int32_t v63; // 0x23030
    int32_t v64; // 0x23034
    int32_t v65; // 0x23038
    struct PM_OBJ_TAG * v66; // 0x2303c
    int32_t v67; // 0x23040
    int32_t v68; // 0x23044
    int32_t v69; // 0x23048
    int32_t v70; // 0x2304c
    struct TAG_Mutex_3 * v71; // 0x23058
    struct TAG_WaitCond_2 * v72; // 0x23070
    int32_t v73; // 0x230a0
    int32_t v74; // 0x230a4
    int32_t v75; // 0x230e0
    int32_t v76; // 0x230e4
    struct TAG_Mutex_3 * v77; // 0x230e8
    char * v78; // 0x23100
    int32_t v79; // 0x23104
    int32_t v80; // 0x23108
    int32_t v81; // 0x2310c
    int32_t v82; // 0x23110
    int32_t v83; // 0x23114
    int32_t v84; // 0x23118
    int32_t v85; // 0x2311c
    int32_t v86; // 0x23120
    int32_t v87; // 0x23124
    int32_t v88; // 0x23128
    int32_t v89; // 0x8946
    int32_t v90; // 0xa6f2
    int32_t v91; // 0xdba0
    int32_t v92; // 0xf00b
    int32_t v93; // 0xf053
    int32_t v94; // 0xf207
    int32_t v95; // 0xfa6d
    // 0xe6f0
    char * v96; // 0x21ae8
    return (int32_t)&v96;
}

// Address range: 0xe714 - 0xe73f
int32_t register_tm_clones(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x2292e
    int32_t v53; // 0x22f95
    int32_t v54; // 0x22f9c
    int32_t v55; // 0x22fa0
    int32_t v56; // 0x22fa4
    int32_t v57; // 0x22fb0
    struct TAG_Mutex_3 * v58; // 0x22fb8
    char * v59; // 0x22fd4
    int32_t v60; // 0x22fdc
    int32_t v61; // 0x2300c
    int32_t v62; // 0x2301c
    int32_t v63; // 0x23030
    int32_t v64; // 0x23034
    int32_t v65; // 0x23038
    struct PM_OBJ_TAG * v66; // 0x2303c
    int32_t v67; // 0x23040
    int32_t v68; // 0x23044
    int32_t v69; // 0x23048
    int32_t v70; // 0x2304c
    struct TAG_Mutex_3 * v71; // 0x23058
    struct TAG_WaitCond_2 * v72; // 0x23070
    int32_t v73; // 0x230a0
    int32_t v74; // 0x230a4
    int32_t v75; // 0x230e0
    int32_t v76; // 0x230e4
    struct TAG_Mutex_3 * v77; // 0x230e8
    char * v78; // 0x23100
    int32_t v79; // 0x23104
    int32_t v80; // 0x23108
    int32_t v81; // 0x2310c
    int32_t v82; // 0x23110
    int32_t v83; // 0x23114
    int32_t v84; // 0x23118
    int32_t v85; // 0x2311c
    int32_t v86; // 0x23120
    int32_t v87; // 0x23124
    int32_t v88; // 0x23128
    int32_t v89; // 0x8946
    int32_t v90; // 0xa6f2
    int32_t v91; // 0xdba0
    int32_t v92; // 0xf00b
    int32_t v93; // 0xf053
    int32_t v94; // 0xf207
    int32_t v95; // 0xfa6d
    // 0xe714
    char * v96; // 0x21ae8
    return (int32_t)&v96;
}

// Address range: 0xe740 - 0xe757
int32_t __do_global_dtors_aux(int32_t result) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x2292e
    int32_t v53; // 0x22f95
    int32_t v54; // 0x22f9c
    int32_t v55; // 0x22fa0
    int32_t v56; // 0x22fa4
    int32_t v57; // 0x22fb0
    struct TAG_Mutex_3 * v58; // 0x22fb8
    char * v59; // 0x22fd4
    int32_t v60; // 0x22fdc
    int32_t v61; // 0x2300c
    int32_t v62; // 0x2301c
    int32_t v63; // 0x23030
    int32_t v64; // 0x23034
    int32_t v65; // 0x23038
    struct PM_OBJ_TAG * v66; // 0x2303c
    int32_t v67; // 0x23040
    int32_t v68; // 0x23044
    int32_t v69; // 0x23048
    int32_t v70; // 0x2304c
    struct TAG_Mutex_3 * v71; // 0x23058
    struct TAG_WaitCond_2 * v72; // 0x23070
    int32_t v73; // 0x230a0
    int32_t v74; // 0x230a4
    int32_t v75; // 0x230e0
    int32_t v76; // 0x230e4
    struct TAG_Mutex_3 * v77; // 0x230e8
    char * v78; // 0x23100
    int32_t v79; // 0x23104
    int32_t v80; // 0x23108
    int32_t v81; // 0x2310c
    int32_t v82; // 0x23110
    int32_t v83; // 0x23114
    int32_t v84; // 0x23118
    int32_t v85; // 0x2311c
    int32_t v86; // 0x23120
    int32_t v87; // 0x23124
    int32_t v88; // 0x23128
    int32_t v89; // 0x8946
    int32_t v90; // 0xa6f2
    int32_t v91; // 0xdba0
    int32_t v92; // 0xf00b
    int32_t v93; // 0xf053
    int32_t v94; // 0xf207
    int32_t v95; // 0xfa6d
    char * v96; // 0x21ae8
    if (*(char *)&v96 == 0) {
        // 0xe748
        deregister_tm_clones();
        result = (int32_t)&v96;
        // branch -> 0xe750
    }
    // 0xe750
    return result;
}

// Address range: 0xe758 - 0xe771
int32_t frame_dummy(int32_t a1, int32_t a2) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x2292e
    int32_t v53; // 0x22f95
    int32_t v54; // 0x22f9c
    int32_t v55; // 0x22fa0
    int32_t v56; // 0x22fa4
    int32_t v57; // 0x22fb0
    struct TAG_Mutex_3 * v58; // 0x22fb8
    char * v59; // 0x22fd4
    int32_t v60; // 0x22fdc
    int32_t v61; // 0x2300c
    int32_t v62; // 0x2301c
    int32_t v63; // 0x23030
    int32_t v64; // 0x23034
    int32_t v65; // 0x23038
    struct PM_OBJ_TAG * v66; // 0x2303c
    int32_t v67; // 0x23040
    int32_t v68; // 0x23044
    int32_t v69; // 0x23048
    int32_t v70; // 0x2304c
    struct TAG_Mutex_3 * v71; // 0x23058
    struct TAG_WaitCond_2 * v72; // 0x23070
    int32_t v73; // 0x230a0
    int32_t v74; // 0x230a4
    int32_t v75; // 0x230e0
    int32_t v76; // 0x230e4
    struct TAG_Mutex_3 * v77; // 0x230e8
    char * v78; // 0x23100
    int32_t v79; // 0x23104
    int32_t v80; // 0x23108
    int32_t v81; // 0x2310c
    int32_t v82; // 0x23110
    int32_t v83; // 0x23114
    int32_t v84; // 0x23118
    int32_t v85; // 0x2311c
    int32_t v86; // 0x23120
    int32_t v87; // 0x23124
    int32_t v88; // 0x23128
    int32_t v89; // 0x8946
    int32_t v90; // 0xa6f2
    int32_t v91; // 0xdba0
    int32_t v92; // 0xf00b
    int32_t v93; // 0xf053
    int32_t v94; // 0xf207
    int32_t v95; // 0xfa6d
    // 0xe758
    register_tm_clones();
    char * v96; // 0x21ae8
    return (int32_t)&v96;
}

// Address range: 0xe772 - 0xe777
int32_t function_e772(int32_t result) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0xe772
    return result;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_task_queue.c
// Address range: 0xe7b4 - 0xe7b7
// Line range:    437 - 440
int32_t appmngr_taskstack_item_attach_input(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0xe7b4
    return 0;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_task_queue.c
// Address range: 0xe928 - 0xe935
// Line range:    21 - 23
int32_t init_task_queue_mem(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0xe928
    return init_queue_mem((struct anon_struct_129 *)&memManObj_TaskQ, 156);
}

// Address range: 0xe936 - 0xe937
int32_t function_e936(int32_t result) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0xe936
    return result;
}

// Address range: 0xe956 - 0xe957
int32_t function_e956(int32_t result) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0xe956
    return result;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_task_queue.c
// Address range: 0xeaa0 - 0xeb5b
// Line range:    442 - 487
void appmngr_taskstack_construct(struct TAG_TaskStack * thiz) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0xeaa0
    if (thiz == NULL) {
        // 0xeac2
        return;
    }
    // 0xeaac
    memset((char *)thiz, 0, 136);
    if (init_task_queue_mem() != 0) {
        // 0xeabc
        return;
    }
    // 0xeac8
    appmngr_mutex_init((struct TAG_Mutex_3 *)((int32_t)thiz + 16));
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_task_queue.c
// Address range: 0xeb5c - 0xeb5f
// Line range:    148 - 150
int32_t init_taskQ_ctrl_obj(struct TAG_TaskStack * stack_ctrl) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0xeb5c
    appmngr_taskstack_construct(stack_ctrl);
    return (int32_t)stack_ctrl;
}

// Address range: 0xeb9a - 0xeba3
int32_t function_eb9a(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0xeb9a
    int32_t v97;
    return 256 * v97;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/sds.c
// Address range: 0xec2c - 0xec37
// Line range:    83 - 85
void sdsfree(char * s) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0xec2c
    if (s == NULL) {
        // 0xec34
        return;
    }
    // 0xec2e
    free((char *)((int32_t)s - 8));
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_socket_server.c
// Address range: 0xeff0 - 0xf013
// Line range:    495 - 503
void anetSetError(char * err, char * fmt, ...) {
    struct __va_list v1;
    int32_t v2; // 0x101c1
    int32_t v3; // 0x111f1
    int32_t v4; // 0x12d09
    int32_t v5; // 0x13d01
    void (*v6)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v7; // 0x14b14
    int16_t * v8; // 0x14cde
    int32_t v9; // 0x157c5
    int32_t v10; // 0x1630f
    char * v11; // 0x16b14
    int32_t v12; // 0x21098
    int32_t v13; // 0x2109c
    int32_t v14; // 0x210a0
    int32_t v15; // 0x210a4
    int32_t * v16; // 0x211dc
    int32_t v17; // 0x213b8
    char * (**v18)(char *); // 0x213bc
    int32_t * v19; // 0x213c8
    int32_t * v20; // 0x213cc
    struct ApplicationManagerController ** v21; // 0x213d0
    int32_t v22; // 0x213d4
    char (*v23)[10]; // 0x213e0
    char * v24[2]; // 0x213e4
    char * (**v25)(char *); // 0x213e8
    char * v26; // 0x213ec
    int16_t * v27; // 0x213f0
    char * v28; // 0x213f2
    char * v29; // 0x213f4
    int32_t v30; // 0x213f8
    int32_t v31; // 0x21400
    int32_t v32; // 0x21404
    void (*v33)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v34)[128]; // 0x21418
    int32_t v35; // 0x2141c
    int32_t v36; // 0x21420
    char ** v37; // 0x21424
    int32_t v38; // 0x21428
    int32_t v39; // 0x21434
    int32_t v40; // 0x21438
    int32_t * v41; // 0x2143c
    int32_t v42; // 0x21440
    int32_t v43; // 0x21448
    int32_t v44; // 0x2144c
    int32_t v45; // 0x21450
    int32_t v46; // 0x21458
    int32_t v47; // 0x21460
    char * v48; // 0x21470
    int32_t v49; // 0x21498
    int32_t v50; // 0x214a4
    char * v51; // 0x215d8
    int32_t v52; // 0x217b4
    char * v53; // 0x21ae8
    char * v54; // 0x2292e
    int32_t v55; // 0x22f95
    int32_t v56; // 0x22f9c
    int32_t v57; // 0x22fa0
    int32_t v58; // 0x22fa4
    int32_t v59; // 0x22fb0
    struct TAG_Mutex_3 * v60; // 0x22fb8
    char * v61; // 0x22fd4
    int32_t v62; // 0x22fdc
    int32_t v63; // 0x2300c
    int32_t v64; // 0x2301c
    int32_t v65; // 0x23030
    int32_t v66; // 0x23034
    int32_t v67; // 0x23038
    struct PM_OBJ_TAG * v68; // 0x2303c
    int32_t v69; // 0x23040
    int32_t v70; // 0x23044
    int32_t v71; // 0x23048
    int32_t v72; // 0x2304c
    struct TAG_Mutex_3 * v73; // 0x23058
    struct TAG_WaitCond_2 * v74; // 0x23070
    int32_t v75; // 0x230a0
    int32_t v76; // 0x230a4
    int32_t v77; // 0x230e0
    int32_t v78; // 0x230e4
    struct TAG_Mutex_3 * v79; // 0x230e8
    char * v80; // 0x23100
    int32_t v81; // 0x23104
    int32_t v82; // 0x23108
    int32_t v83; // 0x2310c
    int32_t v84; // 0x23110
    int32_t v85; // 0x23114
    int32_t v86; // 0x23118
    int32_t v87; // 0x2311c
    int32_t v88; // 0x23120
    int32_t v89; // 0x23124
    int32_t v90; // 0x23128
    int32_t v91; // 0x8946
    int32_t v92; // 0xa6f2
    int32_t v93; // 0xdba0
    int32_t v94; // 0xf00b
    int32_t v95; // 0xf053
    int32_t v96; // 0xf207
    int32_t v97; // 0xfa6d
    if (err != NULL) {
        // 0xeff8
        int32_t v98;
        v1.e0 = (char *)&v98;
        vsnprintf(err, 256, fmt, (int32_t)&v98);
        // branch -> 0xf008
    }
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_socket_server.c
// Address range: 0xf05c - 0xf08b
// Line range:    215 - 222
void aeGetTime(int32_t * seconds, int32_t * milliseconds) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    struct timeval tp;
    gettimeofday(&tp, NULL);
    int32_t v97; // 0xf076
    *seconds = v97;
    int32_t v98; // 0xf06c
    *milliseconds = v98 / 1000;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_socket_server.c
// Address range: 0xf08c - 0xf0fb
// Line range:    519 - 529
void anetCreateSocket(char * err, int32_t domain) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    int32_t v97 = (int32_t)err; // R6
    int32_t option_value = 1; // bp-20
    int32_t sock_fd = socket(domain, SOCK_STREAM, IPPROTO_IP); // 0xf09c
    if (sock_fd == -1) {
        int32_t err_num = *__errno_location(); // 0xf0c4
        strerror(err_num);
        strerror(err_num);
        anetSetError((char *)v97, (char *)0x16a20);
        // branch -> 0xf0ba
    } else {
        // 0xf0a6
        if (setsockopt(sock_fd, SO_DEBUG, 2, (char *)&option_value, 4) == -1) {
            int32_t err_num2 = *__errno_location(); // 0xf0dc
            strerror(err_num2);
            strerror(err_num2);
            anetSetError((char *)v97, (char *)0x16a38);
            // branch -> 0xf0ba
        }
    }
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_socket_server.c
// Address range: 0xf0fc - 0xf16f
// Line range:    505 - 513
void anetListen(char * err, int32_t s, struct sockaddr * sa, int32_t len) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    int32_t v97 = (int32_t)err; // R6
    if (bind(s, sa, len) == -1) {
        int32_t err_num = *__errno_location(); // 0xf12a
        strerror(err_num);
        strerror(err_num);
        anetSetError((char *)v97, "bind: %s\n");
        close(s);
        return;
    }
    // 0xf112
    if (listen(s, 511) != -1) {
        // 0xf122
        return;
    }
    int32_t err_num2 = *__errno_location(); // 0xf14a
    strerror(err_num2);
    strerror(err_num2);
    anetSetError((char *)v97, (char *)0x16a64);
    close(s);
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_socket_server.c
// Address range: 0xf170 - 0xf1db
// Line range:    149 - 162
struct aeEventLoop * aeCreateEventLoop(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    char * mem = malloc((int32_t)"ext_token" | 0x30000); // 0xf17a
    int32_t v97 = (int32_t)mem; // R4
    if (mem == NULL) {
        // 0xf1cc
        return (struct aeEventLoop *)v97;
    }
    // 0xf182
    if ((v97 + 8) % 4 == 0) {
        // if_f19e_0_true
        // branch -> after_if_f19e_0
    }
    // after_if_f19e_0
    if (malloc(0x28008) == NULL || epoll_create(1024) == -1) {
        // 0xf1d0
        free((char *)v97);
        // branch -> 0xf1cc
        // 0xf1cc
        return (struct aeEventLoop *)0;
    }
    // branch -> 0xf1c0
    for (int32_t i = 0; i < 0x27ff1; i += 16) {
        // continue -> 0xf1c0
    }
    // 0xf1cc
    return (struct aeEventLoop *)v97;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_socket_server.c
// Address range: 0xf1dc - 0xf1fb
// Line range:    171 - 173
void aeDeleteEventLoop(struct aeEventLoop * eventLoop) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0xf1dc
    int32_t fd; // 0xf1e6
    close(fd);
    int32_t v97; // 0xf1e2
    free((char *)v97);
    free((char *)eventLoop);
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_socket_server.c
// Address range: 0xf208 - 0xf2af
// Line range:    180 - 183
int32_t aeCreateFileEvent(struct aeEventLoop * eventLoop, int32_t fd, int32_t mask, void (*proc)(struct aeEventLoop *, int32_t, char *, int32_t), char * clientData) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    if (fd > 0x27ff) {
        // 0xf2aa
        // branch -> 0xf2a4
        // 0xf2a4
        return -1;
    }
    int32_t v97 = 1;
    v97 = 5;
    int32_t v98; // 0xf260
    int32_t v99 = epoll_ctl(v98, 1, fd, (struct epoll_event *)&v97); // 0xf268
    int32_t result; // 0xf2a6_2
    if (v99 != -1) {
        // 0xf270
        result = 0;
        // branch -> 0xf2a4
    } else {
        result = v99;
    }
    // 0xf2a4
    return result;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_socket_server.c
// Address range: 0xf2b0 - 0xf34f
// Line range:    197 - 210
void aeDeleteFileEvent(struct aeEventLoop * eventLoop, int32_t fd, int32_t mask) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    if (fd > 0x27ff) {
        // 0xf30a
        return;
    }
    int32_t v97 = 16 * (fd + 1) + (int32_t)eventLoop; // 0xf2c0
    int32_t * v98 = (int32_t *)v97; // 0xf2c0_0
    int32_t v99 = *v98; // 0xf2c0
    if (v99 == 0) {
        // 0xf30a
        return;
    }
    int32_t v100 = -1 - mask; // 0xf2c8
    int32_t v101 = v99 & v100; // 0xf2ca
    *v98 = v101;
    int32_t v102;
    int32_t v103; // 0xf2da
    uint32_t v104; // 0xf2c6
    int32_t v105; // 0xf300
    int32_t v106; // 0xf31e
    int32_t v107; // 0xf2dc
    if (fd == v104 && v101 == 0) {
        // 0xf32e
        if (v104 >= 0) {
            // 0xf332
            int32_t v108; // 0xf334
            if (v108 == 0) {
                int32_t v109 = v104 - 1; // 0xf340
                // branch -> 0xf340
                while (true) {
                    // 0xf340
                    if (v109 != 0) {
                        // 0xf33a
                        int32_t v110; // 0xf33a
                        if (v110 != 0) {
                            // break -> 0xf34a
                            break;
                        }
                        v97 -= 16;
                        v109--;
                        // continue -> 0xf340
                        continue;
                    }
                }
                // 0xf34a
                // branch -> 0xf2d2
                // 0xf2d2
                v107 = v100 & v103;
                v102 = 1;
                if ((int2_t)v107 == 1) {
                    // 0xf30e
                    if (v107 == 0) {
                        // 0xf31c
                        epoll_ctl(v106, 2, fd, (struct epoll_event *)&v102);
                        // branch -> 0xf30a
                        // 0xf30a
                        return;
                    }
                } else {
                    // 0xf2ec
                    v102 = 5;
                    // branch -> 0xf2fe
                }
                // 0xf2fe
                epoll_ctl(v105, 3, fd, (struct epoll_event *)&v102);
                // branch -> 0xf30a
                // 0xf30a
                return;
            }
        }
        // 0xf34a
        // branch -> 0xf2d2
    }
    // 0xf2d2
    v107 = v100 & v103;
    v102 = 1;
    if ((int2_t)v107 == 1) {
        // 0xf30e
        if (v107 == 0) {
            // 0xf31c
            epoll_ctl(v106, 2, fd, (struct epoll_event *)&v102);
            // branch -> 0xf30a
            // 0xf30a
            return;
        }
    } else {
        // 0xf2ec
        v102 = 5;
        // branch -> 0xf2fe
    }
    // 0xf2fe
    epoll_ctl(v105, 3, fd, (struct epoll_event *)&v102);
    // branch -> 0xf30a
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_socket_server.c
// Address range: 0xf3f8 - 0xf447
// Line range:    257 - 265
int32_t aeDeleteTimeEvent(struct aeEventLoop * eventLoop, int64_t id) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    int32_t * v97 = (int32_t *)((int32_t)eventLoop + 0x3c010); // 0xf3fe_0
    int32_t v98 = *v97; // 0xf3fe
    if (v98 == 0) {
        // 0xf424
        return -1;
    }
    // 0xf402
    int32_t v99; // 0xf40a
    if (v98 % 4 == 0) {
        // if_f402_0_true
        uint64_t v100; // 0xf402
        v99 = v100;
        // branch -> after_if_f402_0
    } else {
        // if_f402_0_false
        int32_t v101; // 0xf402
        v99 = v101;
        // branch -> after_if_f402_0
    }
    // after_if_f402_0
    int32_t v102;
    int32_t v103; // 0xf42e
    int32_t v104; // 0xf432
    int32_t v105; // 0xf440
    if (v99 == v102) {
        // 0xf440
        *v97 = v105;
        // branch -> 0xf42e
        // 0xf42e
        if (v103 != 0) {
            // 0xf432
            ((int32_t (*)(int32_t))(v103 & -2))(v104);
            // branch -> 0xf436
        }
        // 0xf436
        free((char *)v98);
        return 0;
    }
    // 0xf41e
    if (v105 == 0) {
        // 0xf424
        return -1;
    }
    int32_t v106 = v105;
    while (true) {
        // 0xf410
        int32_t v107; // 0xf418
        if (v105 % 4 == 0) {
            // if_f410_0_true
            uint64_t v108; // 0xf410
            v107 = v108;
            // branch -> after_if_f410_0
        } else {
            // if_f410_0_false
            int32_t v109; // 0xf410
            v107 = v109;
            // branch -> after_if_f410_0
        }
        // after_if_f410_0
        if (v107 == v102) {
            // 0xf42a
            // branch -> 0xf42e
            // 0xf42e
            if (v103 != 0) {
                // 0xf432
                ((int32_t (*)(int32_t))(v103 & -2))(v104);
                // branch -> 0xf436
            }
            // 0xf436
            free((char *)v106);
            return 0;
        }
        // 0xf41c
        int32_t v110; // 0xf41e
        v106 = v110;
        if (v110 == 0) {
            // break -> 0xf424
            break;
        }
        v105 = v110;
        // continue -> 0xf410
    }
    // 0xf424
    return -1;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_socket_server.c
// Address range: 0xf68c - 0xf68f
// Line range:    643 - 644
void unblockClientWaitingData(struct redisClient * c) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_socket_server.c
// Address range: 0xf690 - 0xf70b
// Line range:    648 - 665
void freeClient(struct redisClient * c) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    int32_t v97 = (int32_t)c;
    if (c != NULL) {
        // 0xf69a
        printf((char *)0x16ad8);
        // branch -> 0xf6a4
    }
    // 0xf6a4
    int32_t v98; // 0xf6a4
    sdsfree((char *)v98);
    int32_t v99; // 0xf6aa
    if (0x8000000 * v99 < 0) {
        // 0xf6f8
        unblockClientWaitingData((struct redisClient *)v97);
        // branch -> 0xf6b4
    }
    // 0xf6b4
    int32_t v100; // 0xf6bc
    int32_t v101; // 0xf6b8
    aeDeleteFileEvent((struct aeEventLoop *)v100, v101, 1);
    int32_t v102; // 0xf6c8
    int32_t v103; // 0xf6c6
    aeDeleteFileEvent((struct aeEventLoop *)v102, v103, 2);
    int32_t v104; // 0xf6d0
    listRelease((struct list_1 *)v104);
    int32_t fd; // 0xf6d6
    close(fd);
    int32_t v105; // 0xf6de
    struct listNode_1 * v106 = listSearchKey((struct list_1 *)v105, (char *)v97); // 0xf6e0
    if (v106 == NULL) {
        // 0xf6ee
        free((char *)v97);
        return;
    }
    // 0xf6e8
    int32_t v107; // 0xf6e8
    listDelNode((struct list_1 *)v107, v106);
}

// Address range: 0xf9e2 - 0xf9eb
int32_t function_f9e2(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0xf9e2
    return 256 * a4;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_socket_server.c
// Address range: 0xfab4 - 0xfaff
// Line range:    1522 - 1528
int32_t anetUnixServer(char * err, char * path) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    struct sockaddr_un v97;
    struct sockaddr_un str;
    int32_t result = (int32_t)err; // 0xfab4_0
    anetCreateSocket(err, 1);
    if (result == -1) {
        // 0xfafa
        // branch -> 0xfaf4
        // 0xfaf4
        return -1;
    }
    // 0xfac8
    memset((char *)&v97, 0, 110);
    strncpy((char *)&str, (char *)(int32_t)path, 107);
    anetListen((char *)result, result, (struct sockaddr *)&v97, 110);
    if (result != -1) {
        // 0xfac8
        // branch -> 0xfaf4
        // 0xfaf4
        return result;
    }
    // 0xfafa
    // branch -> 0xfaf4
    // 0xfaf4
    return -1;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_socket_server.c
// Address range: 0xfb00 - 0xfbb7
// Line range:    1755 - 1762
int32_t create_socket(char * name, int32_t type, int32_t perm, int32_t uid, int32_t gid) {
    struct sockaddr_un addr;
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    struct sockaddr_un str;
    int32_t sock_fd = socket(AF_LOCAL, type, IPPROTO_IP); // 0xfb0e
    int32_t fd = sock_fd; // R4
    if (sock_fd < 0) {
        int32_t err_num = *__errno_location(); // 0xfb92
        strerror(err_num);
        strerror(err_num);
        printf((char *)0x16b18);
        // branch -> 0xfb74
        // 0xfb74
        return -1;
    }
    // 0xfb16
    memset((char *)&addr, 0, 110);
    snprintf((char *)&str, 108, "/applications/tv_bin/ipc_socket/%s", (char *)(int32_t)name);
    if (unlink((char *)&str) != 0) {
        // 0xfb40
        if (*__errno_location() != 2) {
            // 0xfb82
            close(fd);
            // branch -> 0xfb74
            // 0xfb74
            return -1;
        }
    }
    // 0xfb4a
    if (bind(fd, (struct sockaddr *)&addr, 110) == 0) {
        // 0xfb56
        chmod((char *)&str, perm);
        printf("Created socket '%s' with mode '%o', user '%d', group '%d'\n", &str, perm, uid, gid);
        // branch -> 0xfb74
    } else {
        // 0xfb7a
        unlink((char *)&str);
        // branch -> 0xfb82
        int32_t fd2 = fd; // 0xfb82
        fd = -1;
        close(fd2);
        // branch -> 0xfb74
    }
    // 0xfb74
    return fd;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_socket_server.c
// Address range: 0xfbb8 - 0xfbeb
// Line range:    1798 - 1810
int32_t start_socket_service(char * name) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    int32_t fd = create_socket(name, 1, 511, 0, 0); // 0xfbc8
    int32_t result; // 0xfbe0
    if (fd < 0) {
        // 0xfbe6
        result = -1;
        // branch -> 0xfbe0
    } else {
        // 0xfbd0
        fcntl(fd, F_SETFD);
        listen(fd, 8);
        result = fd;
        // branch -> 0xfbe0
    }
    // 0xfbe0
    return result;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_socket_server.c
// Address range: 0xfbec - 0xfcd3
// Line range:    1992 - 2079
int32_t recv_cred(int32_t s, struct ucred * credp, char * buf, int32_t bufsiz, char * addr, int32_t * alen) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    struct iovec v97[1];
    struct msghdr v98;
    char message[24];
    int32_t v99;
    v98.e4 = (char *)v99;
    v97[0].e0 = NULL;
    int32_t v100;
    if (v100 != 0) {
        // 0xfc16
        // branch -> 0xfc1a
    }
    // 0xfc1a
    v98.e0 = (char *)1;
    v98.e2 = (struct iovec *)24;
    int32_t v101 = recvmsg(s, (struct msghdr *)&message, 0); // 0xfc3810
    int32_t result = v101; // R5
    if (v101 != -1) {
        // 0xfc5c
        if (v100 != 0) {
            // 0xfc62
            // branch -> 0xfc8c
        }
        // 0xfc8c
        *__errno_location() = 2;
        perror("\n <return>:");
        // branch -> 0xfc54
        // 0xfc54
        return -1;
    }
    while (true) {
        // 0xfc42
        if (*__errno_location() != 4) {
            // 0xfc4c
            perror((char *)0x16ba4);
            // branch -> 0xfc54
            // 0xfc54
            return result;
        }
        int32_t v102 = recvmsg(s, (struct msghdr *)&message, 0); // 0xfc38
        result = v102;
        if (v102 != -1) {
            // break -> 0xfc5c
            break;
        }
        // continue -> 0xfc42
    }
    // 0xfc5c
    if (v100 != 0) {
        // 0xfc62
        // branch -> 0xfc8c
    }
    // 0xfc8c
    *__errno_location() = 2;
    perror("\n <return>:");
    // branch -> 0xfc54
    // 0xfc54
    return -1;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_socket_server.c
// Address range: 0xfcd4 - 0xfd1f
// Line range:    2101 - 2140
int32_t process_client(int32_t c, char ** uidlist) {
    struct ucred v1;
    int32_t v2; // 0x101c1
    int32_t v3; // 0x111f1
    int32_t v4; // 0x12d09
    int32_t v5; // 0x13d01
    void (*v6)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v7; // 0x14b14
    int16_t * v8; // 0x14cde
    int32_t v9; // 0x157c5
    int32_t v10; // 0x1630f
    char * v11; // 0x16b14
    int32_t v12; // 0x21098
    int32_t v13; // 0x2109c
    int32_t v14; // 0x210a0
    int32_t v15; // 0x210a4
    int32_t * v16; // 0x211dc
    int32_t v17; // 0x213b8
    char * (**v18)(char *); // 0x213bc
    int32_t * v19; // 0x213c8
    int32_t * v20; // 0x213cc
    struct ApplicationManagerController ** v21; // 0x213d0
    int32_t v22; // 0x213d4
    char (*v23)[10]; // 0x213e0
    char * v24[2]; // 0x213e4
    char * (**v25)(char *); // 0x213e8
    char * v26; // 0x213ec
    int16_t * v27; // 0x213f0
    char * v28; // 0x213f2
    char * v29; // 0x213f4
    int32_t v30; // 0x213f8
    int32_t v31; // 0x21400
    int32_t v32; // 0x21404
    void (*v33)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v34)[128]; // 0x21418
    int32_t v35; // 0x2141c
    int32_t v36; // 0x21420
    char ** v37; // 0x21424
    int32_t v38; // 0x21428
    int32_t v39; // 0x21434
    int32_t v40; // 0x21438
    int32_t * v41; // 0x2143c
    int32_t v42; // 0x21440
    int32_t v43; // 0x21448
    int32_t v44; // 0x2144c
    int32_t v45; // 0x21450
    int32_t v46; // 0x21458
    int32_t v47; // 0x21460
    char * v48; // 0x21470
    int32_t v49; // 0x21498
    int32_t v50; // 0x214a4
    char * v51; // 0x215d8
    int32_t v52; // 0x217b4
    char * v53; // 0x21ae8
    char * v54; // 0x2292e
    int32_t v55; // 0x22f95
    int32_t v56; // 0x22f9c
    int32_t v57; // 0x22fa0
    int32_t v58; // 0x22fa4
    int32_t v59; // 0x22fb0
    struct TAG_Mutex_3 * v60; // 0x22fb8
    char * v61; // 0x22fd4
    int32_t v62; // 0x22fdc
    int32_t v63; // 0x2300c
    int32_t v64; // 0x2301c
    int32_t v65; // 0x23030
    int32_t v66; // 0x23034
    int32_t v67; // 0x23038
    struct PM_OBJ_TAG * v68; // 0x2303c
    int32_t v69; // 0x23040
    int32_t v70; // 0x23044
    int32_t v71; // 0x23048
    int32_t v72; // 0x2304c
    struct TAG_Mutex_3 * v73; // 0x23058
    struct TAG_WaitCond_2 * v74; // 0x23070
    int32_t v75; // 0x230a0
    int32_t v76; // 0x230a4
    int32_t v77; // 0x230e0
    int32_t v78; // 0x230e4
    struct TAG_Mutex_3 * v79; // 0x230e8
    char * v80; // 0x23100
    int32_t v81; // 0x23104
    int32_t v82; // 0x23108
    int32_t v83; // 0x2310c
    int32_t v84; // 0x23110
    int32_t v85; // 0x23114
    int32_t v86; // 0x23118
    int32_t v87; // 0x2311c
    int32_t v88; // 0x23120
    int32_t v89; // 0x23124
    int32_t v90; // 0x23128
    int32_t v91; // 0x8946
    int32_t v92; // 0xa6f2
    int32_t v93; // 0xdba0
    int32_t v94; // 0xf00b
    int32_t v95; // 0xf053
    int32_t v96; // 0xf207
    int32_t v97; // 0xfa6d
    // 0xfcd4
    int16_t v98;
    int16_t port = v98; // bp-34
    int32_t v99;
    int32_t b = v99; // bp-32
    int32_t result = setsockopt(c, SO_DEBUG, 16, (char *)&b, 4); // 0xfce6
    if (result == -1) {
        // 0xfd0a
        return result;
    }
    int32_t v100 = recv_cred(c, &v1, (char *)&port, 2, NULL, NULL); // 0xfcfe
    int32_t result2 = 0; // 0xfd0c_2
    if (v100 == -1) {
        // 0xfd0e
        perror("recv_cred(xx)");
        result2 = -2;
        // branch -> 0xfd0a
    }
    // 0xfd0a
    return result2;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_socket_server.c
// Address range: 0xfd20 - 0xfd8f
// Line range:    1822 - 1851
int32_t handle_property_set_fd(int32_t fd, int32_t flag_cred) {
    struct sockaddr_un addr;
    struct ucred option_value;
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0xfd20
    int32_t v97;
    int32_t addr_size = v97; // bp-148
    int32_t v98;
    int32_t cr_size = v98; // bp-144
    addr_size = 110;
    cr_size = 12;
    int32_t accepted_sock_fd = accept(fd, (struct sockaddr *)&addr, &addr_size); // 0xfd34
    if (accepted_sock_fd < 0) {
        // 0xfd7a
        // branch -> 0xfd66
        // 0xfd66
        return -1;
    }
    // 0xfd3c
    int32_t result; // 0xfd68_2
    if (flag_cred != 0) {
        // 0xfd6a
        if (process_client(accepted_sock_fd, NULL) > -1) {
            // 0xfd5e
            close(accepted_sock_fd);
            result = 0;
            // branch -> 0xfd66
        } else {
            // 0xfd74
            result = -3;
            // branch -> 0xfd66
        }
        // 0xfd66
        return result;
    }
    // 0xfd3e
    if (getsockopt(accepted_sock_fd, SO_DEBUG, 17, (char *)&option_value, &cr_size) < 0) {
        // 0xfd80
        close(accepted_sock_fd);
        result = -2;
        // branch -> 0xfd66
    } else {
        // 0xfd50
        printf((char *)0x16bc4);
        // branch -> 0xfd5e
        // 0xfd5e
        close(accepted_sock_fd);
        result = 0;
        // branch -> 0xfd66
    }
    // 0xfd66
    return result;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_socket_server.c
// Address range: 0xfd90 - 0xfdc3
// Line range:    1899 - 1907
int32_t test_server_unix_socket_simply(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    int32_t v97 = start_socket_service((char *)0x16be8); // 0xfd96
    if (v97 <= 0) {
        // 0xfdb8
        return -1;
    }
    // 0xfda4
    if (handle_property_set_fd(v97, 0) == 0) {
        // 0xfdb4
        return 0;
    }
    sleep(1);
    while (handle_property_set_fd(v97, 0) != 0) {
        // 0xfda0
        sleep(1);
        // continue -> 0xfda0
    }
    // 0xfdb4
    return 0;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_socket_server.c
// Address range: 0xfdc4 - 0xfe33
// Line range:    2193 - 2209
int32_t send_cred(int32_t fd) {
    char v1[1];
    int32_t v2; // 0x101c1
    int32_t v3; // 0x111f1
    int32_t v4; // 0x12d09
    int32_t v5; // 0x13d01
    void (*v6)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v7; // 0x14b14
    int16_t * v8; // 0x14cde
    int32_t v9; // 0x157c5
    int32_t v10; // 0x1630f
    char * v11; // 0x16b14
    int32_t v12; // 0x21098
    int32_t v13; // 0x2109c
    int32_t v14; // 0x210a0
    int32_t v15; // 0x210a4
    int32_t * v16; // 0x211dc
    int32_t v17; // 0x213b8
    char * (**v18)(char *); // 0x213bc
    int32_t * v19; // 0x213c8
    int32_t * v20; // 0x213cc
    struct ApplicationManagerController ** v21; // 0x213d0
    int32_t v22; // 0x213d4
    char (*v23)[10]; // 0x213e0
    char * v24[2]; // 0x213e4
    char * (**v25)(char *); // 0x213e8
    char * v26; // 0x213ec
    int16_t * v27; // 0x213f0
    char * v28; // 0x213f2
    char * v29; // 0x213f4
    int32_t v30; // 0x213f8
    int32_t v31; // 0x21400
    int32_t v32; // 0x21404
    void (*v33)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v34)[128]; // 0x21418
    int32_t v35; // 0x2141c
    int32_t v36; // 0x21420
    char ** v37; // 0x21424
    int32_t v38; // 0x21428
    int32_t v39; // 0x21434
    int32_t v40; // 0x21438
    int32_t * v41; // 0x2143c
    int32_t v42; // 0x21440
    int32_t v43; // 0x21448
    int32_t v44; // 0x2144c
    int32_t v45; // 0x21450
    int32_t v46; // 0x21458
    int32_t v47; // 0x21460
    char * v48; // 0x21470
    int32_t v49; // 0x21498
    int32_t v50; // 0x214a4
    char * v51; // 0x215d8
    int32_t v52; // 0x217b4
    char * v53; // 0x21ae8
    char * v54; // 0x2292e
    int32_t v55; // 0x22f95
    int32_t v56; // 0x22f9c
    int32_t v57; // 0x22fa0
    int32_t v58; // 0x22fa4
    int32_t v59; // 0x22fb0
    struct TAG_Mutex_3 * v60; // 0x22fb8
    char * v61; // 0x22fd4
    int32_t v62; // 0x22fdc
    int32_t v63; // 0x2300c
    int32_t v64; // 0x2301c
    int32_t v65; // 0x23030
    int32_t v66; // 0x23034
    int32_t v67; // 0x23038
    struct PM_OBJ_TAG * v68; // 0x2303c
    int32_t v69; // 0x23040
    int32_t v70; // 0x23044
    int32_t v71; // 0x23048
    int32_t v72; // 0x2304c
    struct TAG_Mutex_3 * v73; // 0x23058
    struct TAG_WaitCond_2 * v74; // 0x23070
    int32_t v75; // 0x230a0
    int32_t v76; // 0x230a4
    int32_t v77; // 0x230e0
    int32_t v78; // 0x230e4
    struct TAG_Mutex_3 * v79; // 0x230e8
    char * v80; // 0x23100
    int32_t v81; // 0x23104
    int32_t v82; // 0x23108
    int32_t v83; // 0x2310c
    int32_t v84; // 0x23110
    int32_t v85; // 0x23114
    int32_t v86; // 0x23118
    int32_t v87; // 0x2311c
    int32_t v88; // 0x23120
    int32_t v89; // 0x23124
    int32_t v90; // 0x23128
    int32_t v91; // 0x8946
    int32_t v92; // 0xa6f2
    int32_t v93; // 0xdba0
    int32_t v94; // 0xf00b
    int32_t v95; // 0xf053
    int32_t v96; // 0xf207
    int32_t v97; // 0xfa6d
    struct iovec v98[1];
    struct msghdr message;
    v98[0].e0 = &v1[0];
    message.e0 = NULL;
    message.e2 = &v98[0];
    if (cmptr != 0) {
        // 0xfde8
        geteuid();
        geteuid();
        getegid();
        getegid();
        getpid();
        getpid();
        message.e4 = (char *)cmptr;
        sendmsg(fd, &message, 0);
        // branch -> 0xfe16
        // 0xfe16
        return 0;
    }
    char * mem = malloc(24); // 0xfe1c
    int32_t result;
    if (mem != NULL) {
        // 0xfe1a
        // branch -> 0xfde8
        // 0xfde8
        geteuid();
        geteuid();
        getegid();
        getegid();
        getpid();
        getpid();
        message.e4 = (char *)(int32_t)mem;
        sendmsg(fd, &message, 0);
        result = 0;
        // branch -> 0xfe16
    } else {
        result = -1;
    }
    // 0xfe16
    return result;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_socket_server.c
// Address range: 0xfe34 - 0xfe6b
// Line range:    2227 - 2251
int32_t test_server_unix_socket_ucred(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    int32_t fd = start_socket_service("unix_listen_sock_ucred"); // 0xfe3a
    if (fd <= 0) {
        // 0xfe62
        return -1;
    }
    int32_t result = handle_property_set_fd(fd, 1); // 0xfe4c2
    if (result == 0) {
        // 0xfe58
        close(fd);
        return result;
    }
    sleep(1);
    int32_t result2 = handle_property_set_fd(fd, 1); // 0xfe4c
    while (result2 != 0) {
        // 0xfe44
        sleep(1);
        result2 = handle_property_set_fd(fd, 1);
        // continue -> 0xfe44
    }
    // 0xfe58
    close(fd);
    return result2;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_socket_server.c
// Address range: 0xfe6c - 0xfe7d
// Line range:    2258 - 2260
int32_t lock_mutex_server(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    int32_t v28; // 0x213f8
    int32_t v29; // 0x21400
    int32_t v30; // 0x21404
    void (*v31)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v32)[128]; // 0x21418
    int32_t v33; // 0x2141c
    int32_t v34; // 0x21420
    char ** v35; // 0x21424
    int32_t v36; // 0x21428
    int32_t v37; // 0x21434
    int32_t v38; // 0x21438
    int32_t * v39; // 0x2143c
    int32_t v40; // 0x21440
    int32_t v41; // 0x21448
    int32_t v42; // 0x2144c
    int32_t v43; // 0x21450
    int32_t v44; // 0x21458
    int32_t v45; // 0x21460
    char * v46; // 0x21470
    int32_t v47; // 0x21498
    int32_t v48; // 0x214a4
    char * v49; // 0x215d8
    int32_t v50; // 0x217b4
    char * v51; // 0x21ae8
    char * v52; // 0x2292e
    int32_t v53; // 0x22f95
    int32_t v54; // 0x22f9c
    int32_t v55; // 0x22fa0
    int32_t v56; // 0x22fa4
    int32_t v57; // 0x22fb0
    struct TAG_Mutex_3 * v58; // 0x22fb8
    char * v59; // 0x22fd4
    int32_t v60; // 0x22fdc
    int32_t v61; // 0x2300c
    int32_t v62; // 0x2301c
    int32_t v63; // 0x23030
    int32_t v64; // 0x23034
    int32_t v65; // 0x23038
    struct PM_OBJ_TAG * v66; // 0x2303c
    int32_t v67; // 0x23040
    int32_t v68; // 0x23044
    int32_t v69; // 0x23048
    int32_t v70; // 0x2304c
    struct TAG_Mutex_3 * v71; // 0x23058
    struct TAG_WaitCond_2 * v72; // 0x23070
    int32_t v73; // 0x230a0
    int32_t v74; // 0x230a4
    int32_t v75; // 0x230e0
    int32_t v76; // 0x230e4
    struct TAG_Mutex_3 * v77; // 0x230e8
    char * v78; // 0x23100
    int32_t v79; // 0x23104
    int32_t v80; // 0x23108
    int32_t v81; // 0x2310c
    int32_t v82; // 0x23110
    int32_t v83; // 0x23114
    int32_t v84; // 0x23118
    int32_t v85; // 0x2311c
    int32_t v86; // 0x23120
    int32_t v87; // 0x23124
    int32_t v88; // 0x23128
    int32_t v89; // 0x8946
    int32_t v90; // 0xa6f2
    int32_t v91; // 0xdba0
    int32_t v92; // 0xf00b
    int32_t v93; // 0xf053
    int32_t v94; // 0xf207
    int32_t v95; // 0xfa6d
    // 0xfe6c
    char * v96; // 0x213f4
    return appmngr_mutex_lock((struct TAG_Mutex_3 *)((int32_t)v96 + 4));
}

// Address range: 0xfe7e - 0xfe83
int32_t function_fe7e(int32_t a1, int32_t a2) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0xfe7e
    int32_t v97;
    return 256 * v97;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_socket_server.c
// Address range: 0xfe84 - 0xfe95
// Line range:    2263 - 2265
int32_t unlock_mutex_server(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    int32_t v28; // 0x213f8
    int32_t v29; // 0x21400
    int32_t v30; // 0x21404
    void (*v31)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v32)[128]; // 0x21418
    int32_t v33; // 0x2141c
    int32_t v34; // 0x21420
    char ** v35; // 0x21424
    int32_t v36; // 0x21428
    int32_t v37; // 0x21434
    int32_t v38; // 0x21438
    int32_t * v39; // 0x2143c
    int32_t v40; // 0x21440
    int32_t v41; // 0x21448
    int32_t v42; // 0x2144c
    int32_t v43; // 0x21450
    int32_t v44; // 0x21458
    int32_t v45; // 0x21460
    char * v46; // 0x21470
    int32_t v47; // 0x21498
    int32_t v48; // 0x214a4
    char * v49; // 0x215d8
    int32_t v50; // 0x217b4
    char * v51; // 0x21ae8
    char * v52; // 0x2292e
    int32_t v53; // 0x22f95
    int32_t v54; // 0x22f9c
    int32_t v55; // 0x22fa0
    int32_t v56; // 0x22fa4
    int32_t v57; // 0x22fb0
    struct TAG_Mutex_3 * v58; // 0x22fb8
    char * v59; // 0x22fd4
    int32_t v60; // 0x22fdc
    int32_t v61; // 0x2300c
    int32_t v62; // 0x2301c
    int32_t v63; // 0x23030
    int32_t v64; // 0x23034
    int32_t v65; // 0x23038
    struct PM_OBJ_TAG * v66; // 0x2303c
    int32_t v67; // 0x23040
    int32_t v68; // 0x23044
    int32_t v69; // 0x23048
    int32_t v70; // 0x2304c
    struct TAG_Mutex_3 * v71; // 0x23058
    struct TAG_WaitCond_2 * v72; // 0x23070
    int32_t v73; // 0x230a0
    int32_t v74; // 0x230a4
    int32_t v75; // 0x230e0
    int32_t v76; // 0x230e4
    struct TAG_Mutex_3 * v77; // 0x230e8
    char * v78; // 0x23100
    int32_t v79; // 0x23104
    int32_t v80; // 0x23108
    int32_t v81; // 0x2310c
    int32_t v82; // 0x23110
    int32_t v83; // 0x23114
    int32_t v84; // 0x23118
    int32_t v85; // 0x2311c
    int32_t v86; // 0x23120
    int32_t v87; // 0x23124
    int32_t v88; // 0x23128
    int32_t v89; // 0x8946
    int32_t v90; // 0xa6f2
    int32_t v91; // 0xdba0
    int32_t v92; // 0xf00b
    int32_t v93; // 0xf053
    int32_t v94; // 0xf207
    int32_t v95; // 0xfa6d
    // 0xfe84
    char * v96; // 0x213f4
    return appmngr_mutex_unlock((struct TAG_Mutex_3 *)((int32_t)v96 + 4));
}

// Address range: 0xfe96 - 0xfe9b
int32_t function_fe96(int32_t a1, int32_t a2) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0xfe96
    int32_t v97;
    return 256 * v97;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_socket_server.c
// Address range: 0xff00 - 0x1018f
// Line range:    369 - 307
int32_t aeProcessEvents(struct aeEventLoop * eventLoop, uint32_t flags) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    int32_t v97 = (int32_t)eventLoop;
    if (flags % 4 == 0) {
        // 0xffcc
        return 0;
    }
    // 0xff14
    int32_t v98; // 0xff14
    if (v98 != -1) {
        // 0xff1a
        // branch -> 0x100e0
    }
    // 0x100e0
    int32_t v99; // 0xff40
    if (0x20000000 * flags < 0) {
        v99 = 0;
        // branch -> 0xff3c
    } else {
        // 0xff30
        v99 = -1;
        // branch -> 0xff3c
    }
    // 0xff3c
    int32_t v100;
    int32_t v101; // 0xff30
    int32_t v102 = epoll_wait(v100, (struct epoll_event *)(v101 + 8), 0x2800, v99); // 0xff40
    int32_t v103 = v102; // R7
    int32_t result2; // 0xffee
    if (v102 < 1) {
        // 0xffde
        if (0x40000000 * flags > 0) {
            // 0xffcc
            return 0;
        }
    } else {
        int32_t v104 = v97 + 0x28010; // 0xff4e
        int32_t v105 = 0; // 0xff52
        // branch -> 0xff52
        while (true) {
            int32_t v106 = v105 + 1; // 0xff54
            v104 += 8;
            if (v106 == v102) {
                int32_t v107 = 0; // 0x1002e
                // branch -> 0xff7c
                int32_t result; // 0xffba
                while (true) {
                    // 0xff7c
                    int32_t v108; // 0xff80
                    int32_t v109; // 0xff88
                    int32_t v110 = v109 & v108; // 0xff90
                    int32_t v111;
                    int32_t v112; // 0xffba
                    int32_t v113; // 0xff7c
                    if (0x80000000 * v110 == 0) {
                        // 0xff96
                        if (0x40000000 * v110 <= 0) {
                          lab_0xff9a:
                            // 0xff9a
                            lock_mutex_server();
                            int32_t v114; // 0xffa8
                            int32_t v115; // 0xffac
                            ((int32_t (*)(int32_t, int32_t, int32_t, int32_t))(v115 & -2))(v97, v113, v114, v108);
                            unlock_mutex_server();
                            v112 = v111;
                            // branch -> 0xffba
                        } else {
                            v112 = v107;
                        }
                    } else {
                        // 0x10028
                        int32_t v116; // 0x10028
                        int32_t v117; // 0x10036
                        ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t))(v117 & -2))(v97, v113, v116, v108, v107);
                        int32_t v118; // 0x1003c
                        if ((v118 & 2) != v108) {
                            // 0x1004c
                            int32_t v119; // 0x1004c
                            int32_t v120; // 0x10050
                            if (v119 != v120) {
                                goto lab_0xff9a;
                            }
                            // 0xffba
                            result = v111 + 1;
                            v104 += 8;
                            if (result == v103) {
                                // break -> 0xffc4
                                break;
                            }
                            v107 = result;
                            // continue -> 0xff7c
                            continue;
                        } else {
                            v112 = v111;
                        }
                    }
                    // 0xffba
                    result = v112 + 1;
                    v104 += 8;
                    if (result == v103) {
                        // break -> 0xffc4
                        break;
                    }
                    v107 = result;
                    // continue -> 0xff7c
                }
                // 0xffc4
                if (0x40000000 * flags >= 0) {
                    // 0xffcc
                    return result;
                }
                // 0xffe6
                if ((v97 + 8) % 4 == 0) {
                    // if_ffea_0_true
                    // branch -> after_if_ffea_0
                    // after_if_ffea_0
                    // branch -> 0xffcc
                    // 0xffcc
                    return result2 + result;
                }
                // if_ffea_0_false
                // branch -> after_if_ffea_0
                // after_if_ffea_0
                // branch -> 0xffcc
                // 0xffcc
                return result2 + result;
            }
            // 0xff52
            v102 = v103;
            v105 = v106;
            // branch -> 0xff52
        }
    }
    // 0xffe6
    if ((v97 + 8) % 4 == 0) {
        // if_ffea_0_true
        // branch -> after_if_ffea_0
    }
    // after_if_ffea_0
    // branch -> 0xffcc
    // 0xffcc
    return result2;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_socket_server.c
// Address range: 0x10190 - 0x101bf
// Line range:    473 - 480
void aeMain(struct aeEventLoop * eventLoop) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x10190
    // branch -> 0x101a6
    while (true) {
        // 0x101a6
        int32_t v97; // 0x101a6
        if (v97 != 0) {
            // 0x101ac
            ((int32_t (*)())(v97 & -2))();
            // branch -> 0x101ae
        }
        // 0x101ae
        aeProcessEvents((struct aeEventLoop *)(int32_t)eventLoop, 3);
        int32_t v98; // 0x101b6
        if (v98 != 0) {
            // break -> 0x101bc
            break;
        }
        // continue -> 0x101a6
    }
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_socket_server.c
// Address range: 0x101ec - 0x101fd
// Line range:    2268 - 2270
int32_t lock_send_buffer(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    int32_t v28; // 0x213f8
    int32_t v29; // 0x21400
    int32_t v30; // 0x21404
    void (*v31)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v32)[128]; // 0x21418
    int32_t v33; // 0x2141c
    int32_t v34; // 0x21420
    char ** v35; // 0x21424
    int32_t v36; // 0x21428
    int32_t v37; // 0x21434
    int32_t v38; // 0x21438
    int32_t * v39; // 0x2143c
    int32_t v40; // 0x21440
    int32_t v41; // 0x21448
    int32_t v42; // 0x2144c
    int32_t v43; // 0x21450
    int32_t v44; // 0x21458
    int32_t v45; // 0x21460
    char * v46; // 0x21470
    int32_t v47; // 0x21498
    int32_t v48; // 0x214a4
    char * v49; // 0x215d8
    int32_t v50; // 0x217b4
    char * v51; // 0x21ae8
    char * v52; // 0x2292e
    int32_t v53; // 0x22f95
    int32_t v54; // 0x22f9c
    int32_t v55; // 0x22fa0
    int32_t v56; // 0x22fa4
    int32_t v57; // 0x22fb0
    struct TAG_Mutex_3 * v58; // 0x22fb8
    char * v59; // 0x22fd4
    int32_t v60; // 0x22fdc
    int32_t v61; // 0x2300c
    int32_t v62; // 0x2301c
    int32_t v63; // 0x23030
    int32_t v64; // 0x23034
    int32_t v65; // 0x23038
    struct PM_OBJ_TAG * v66; // 0x2303c
    int32_t v67; // 0x23040
    int32_t v68; // 0x23044
    int32_t v69; // 0x23048
    int32_t v70; // 0x2304c
    struct TAG_Mutex_3 * v71; // 0x23058
    struct TAG_WaitCond_2 * v72; // 0x23070
    int32_t v73; // 0x230a0
    int32_t v74; // 0x230a4
    int32_t v75; // 0x230e0
    int32_t v76; // 0x230e4
    struct TAG_Mutex_3 * v77; // 0x230e8
    char * v78; // 0x23100
    int32_t v79; // 0x23104
    int32_t v80; // 0x23108
    int32_t v81; // 0x2310c
    int32_t v82; // 0x23110
    int32_t v83; // 0x23114
    int32_t v84; // 0x23118
    int32_t v85; // 0x2311c
    int32_t v86; // 0x23120
    int32_t v87; // 0x23124
    int32_t v88; // 0x23128
    int32_t v89; // 0x8946
    int32_t v90; // 0xa6f2
    int32_t v91; // 0xdba0
    int32_t v92; // 0xf00b
    int32_t v93; // 0xf053
    int32_t v94; // 0xf207
    int32_t v95; // 0xfa6d
    // 0x101ec
    char * v96; // 0x213f4
    return appmngr_mutex_lock((struct TAG_Mutex_3 *)((int32_t)v96 + 28));
}

// Address range: 0x101fe - 0x10203
int32_t function_101fe(int32_t a1, int32_t a2) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x101fe
    int32_t v97;
    return 256 * v97;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_socket_server.c
// Address range: 0x10204 - 0x10215
// Line range:    2273 - 2275
int32_t unlock_send_buffer(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    int32_t v28; // 0x213f8
    int32_t v29; // 0x21400
    int32_t v30; // 0x21404
    void (*v31)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v32)[128]; // 0x21418
    int32_t v33; // 0x2141c
    int32_t v34; // 0x21420
    char ** v35; // 0x21424
    int32_t v36; // 0x21428
    int32_t v37; // 0x21434
    int32_t v38; // 0x21438
    int32_t * v39; // 0x2143c
    int32_t v40; // 0x21440
    int32_t v41; // 0x21448
    int32_t v42; // 0x2144c
    int32_t v43; // 0x21450
    int32_t v44; // 0x21458
    int32_t v45; // 0x21460
    char * v46; // 0x21470
    int32_t v47; // 0x21498
    int32_t v48; // 0x214a4
    char * v49; // 0x215d8
    int32_t v50; // 0x217b4
    char * v51; // 0x21ae8
    char * v52; // 0x2292e
    int32_t v53; // 0x22f95
    int32_t v54; // 0x22f9c
    int32_t v55; // 0x22fa0
    int32_t v56; // 0x22fa4
    int32_t v57; // 0x22fb0
    struct TAG_Mutex_3 * v58; // 0x22fb8
    char * v59; // 0x22fd4
    int32_t v60; // 0x22fdc
    int32_t v61; // 0x2300c
    int32_t v62; // 0x2301c
    int32_t v63; // 0x23030
    int32_t v64; // 0x23034
    int32_t v65; // 0x23038
    struct PM_OBJ_TAG * v66; // 0x2303c
    int32_t v67; // 0x23040
    int32_t v68; // 0x23044
    int32_t v69; // 0x23048
    int32_t v70; // 0x2304c
    struct TAG_Mutex_3 * v71; // 0x23058
    struct TAG_WaitCond_2 * v72; // 0x23070
    int32_t v73; // 0x230a0
    int32_t v74; // 0x230a4
    int32_t v75; // 0x230e0
    int32_t v76; // 0x230e4
    struct TAG_Mutex_3 * v77; // 0x230e8
    char * v78; // 0x23100
    int32_t v79; // 0x23104
    int32_t v80; // 0x23108
    int32_t v81; // 0x2310c
    int32_t v82; // 0x23110
    int32_t v83; // 0x23114
    int32_t v84; // 0x23118
    int32_t v85; // 0x2311c
    int32_t v86; // 0x23120
    int32_t v87; // 0x23124
    int32_t v88; // 0x23128
    int32_t v89; // 0x8946
    int32_t v90; // 0xa6f2
    int32_t v91; // 0xdba0
    int32_t v92; // 0xf00b
    int32_t v93; // 0xf053
    int32_t v94; // 0xf207
    int32_t v95; // 0xfa6d
    // 0x10204
    char * v96; // 0x213f4
    return appmngr_mutex_unlock((struct TAG_Mutex_3 *)((int32_t)v96 + 28));
}

// Address range: 0x10216 - 0x1021b
int32_t function_10216(int32_t a1, int32_t a2) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x10216
    int32_t v97;
    return 256 * v97;
}

// Address range: 0x1045a - 0x1045f
int32_t function_1045a(int32_t a1, int32_t a2) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x1045a
    int32_t v97;
    return 256 * v97;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_socket_server.c
// Address range: 0x10460 - 0x10559
// Line range:    2278 - 2323
int32_t init_socket_server_module(int32_t with_thread, int32_t * flag_ready) {
    int32_t v1; // 0x111f1
    int32_t v2; // 0x12d09
    int32_t v3; // 0x13d01
    void (*v4)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v5; // 0x14b14
    int16_t * v6; // 0x14cde
    int32_t v7; // 0x157c5
    int32_t v8; // 0x1630f
    char * v9; // 0x16b14
    int32_t v10; // 0x21098
    int32_t v11; // 0x2109c
    int32_t v12; // 0x210a0
    int32_t v13; // 0x210a4
    int32_t * v14; // 0x211dc
    int32_t v15; // 0x213b8
    char * (**v16)(char *); // 0x213bc
    int32_t * v17; // 0x213c8
    int32_t * v18; // 0x213cc
    struct ApplicationManagerController ** v19; // 0x213d0
    int32_t v20; // 0x213d4
    char (*v21)[10]; // 0x213e0
    char * v22[2]; // 0x213e4
    char * (**v23)(char *); // 0x213e8
    char * v24; // 0x213ec
    int16_t * v25; // 0x213f0
    char * v26; // 0x213f2
    int32_t v27; // 0x213f8
    int32_t v28; // 0x21400
    int32_t v29; // 0x21404
    void (*v30)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v31)[128]; // 0x21418
    int32_t v32; // 0x2141c
    int32_t v33; // 0x21420
    char ** v34; // 0x21424
    int32_t v35; // 0x21428
    int32_t v36; // 0x21434
    int32_t v37; // 0x21438
    int32_t * v38; // 0x2143c
    int32_t v39; // 0x21440
    int32_t v40; // 0x21448
    int32_t v41; // 0x2144c
    int32_t v42; // 0x21450
    int32_t v43; // 0x21458
    int32_t v44; // 0x21460
    char * v45; // 0x21470
    int32_t v46; // 0x21498
    int32_t v47; // 0x214a4
    char * v48; // 0x215d8
    int32_t v49; // 0x217b4
    char * v50; // 0x21ae8
    char * v51; // 0x2292e
    int32_t v52; // 0x22f95
    int32_t v53; // 0x22f9c
    int32_t v54; // 0x22fa0
    int32_t v55; // 0x22fa4
    int32_t v56; // 0x22fb0
    struct TAG_Mutex_3 * v57; // 0x22fb8
    char * v58; // 0x22fd4
    int32_t v59; // 0x22fdc
    int32_t v60; // 0x2300c
    int32_t v61; // 0x2301c
    int32_t v62; // 0x23030
    int32_t v63; // 0x23034
    int32_t v64; // 0x23038
    struct PM_OBJ_TAG * v65; // 0x2303c
    int32_t v66; // 0x23040
    int32_t v67; // 0x23044
    int32_t v68; // 0x23048
    int32_t v69; // 0x2304c
    struct TAG_Mutex_3 * v70; // 0x23058
    struct TAG_WaitCond_2 * v71; // 0x23070
    int32_t v72; // 0x230a0
    int32_t v73; // 0x230a4
    int32_t v74; // 0x230e0
    int32_t v75; // 0x230e4
    struct TAG_Mutex_3 * v76; // 0x230e8
    char * v77; // 0x23100
    int32_t v78; // 0x23104
    int32_t v79; // 0x23108
    int32_t v80; // 0x2310c
    int32_t v81; // 0x23110
    int32_t v82; // 0x23114
    int32_t v83; // 0x23118
    int32_t v84; // 0x2311c
    int32_t v85; // 0x23120
    int32_t v86; // 0x23124
    int32_t v87; // 0x23128
    int32_t v88; // 0x8946
    int32_t v89; // 0xa6f2
    int32_t v90; // 0xdba0
    int32_t v91; // 0xf00b
    int32_t v92; // 0xf053
    int32_t v93; // 0xf207
    int32_t thread_func_arg = (int32_t)flag_ready;
    char * v94; // 0x213f4
    int32_t thread = (int32_t)v94;
    int32_t path = (int32_t)"/tmp/ipc_socket";
    memset(v94, 0, 348);
    listCreate();
    listCreate();
    aeCreateEventLoop();
    aeCreateEventLoop();
    appmngr_mutex_init((struct TAG_Mutex_3 *)(thread + 4));
    appmngr_mutex_init((struct TAG_Mutex_3 *)(thread + 28));
    if (access((char *)path, F_OK) < 0) {
        // 0x10538
        mkdir((char *)path, 438);
        // branch -> 0x104aa
    }
    // 0x104aa
    int32_t thread_func; // 0x101c1
    int32_t v95; // 0xfa6d
    int32_t v96; // 0x104cc
    int32_t v97; // 0x10512
    int32_t v98; // 0x104e0
    int32_t v99; // 0x104f0
    int32_t v100; // 0x104f8
    int32_t v101; // 0x104c6
    if (access((char *)0x16c28, F_OK) >= 0) {
        // 0x104ba
        unlink((char *)0x16c28);
        v96 = anetUnixServer((char *)(thread + 84), (char *)v101);
        if (v96 == -1) {
            // 0x10552
            exit(1);
            // UNREACHABLE
        }
        // 0x104d8
        if (v96 >= 1) {
            // 0x104dc
            aeCreateFileEvent((struct aeEventLoop *)v98, v96, 1, (void (*)(struct aeEventLoop *, int32_t, char *, int32_t))&v95, NULL);
            // branch -> 0x104ee
        }
        // 0x104ee
        if (with_thread == 0) {
            // 0x104f0
            aeMain((struct aeEventLoop *)v99);
            aeDeleteEventLoop((struct aeEventLoop *)v100);
            // branch -> 0x10502
            // 0x10502
            return with_thread;
        }
        // 0x10508
        v97 = pthread_create((int32_t *)thread, NULL, (char * (**)(char *))&thread_func, (char *)thread_func_arg);
        if (v97 != 0) {
            // 0x1051a
            printf((char *)0x16c6c);
            // branch -> 0x10502
        }
        // 0x10502
        return 0;
    }
    int32_t fd = open((char *)0x16c28, 66);
    if (fd < 0) {
        // 0x10544
        perror("\n unix daemon path err !! ");
        // branch -> 0x10502
        // 0x10502
        return -1;
    }
    // 0x10532
    close(fd);
    // branch -> 0x104ba
    // 0x104ba
    unlink((char *)0x16c28);
    v96 = anetUnixServer((char *)(thread + 84), (char *)v101);
    if (v96 == -1) {
        // 0x10552
        exit(1);
        // UNREACHABLE
    }
    // 0x104d8
    if (v96 >= 1) {
        // 0x104dc
        aeCreateFileEvent((struct aeEventLoop *)v98, v96, 1, (void (*)(struct aeEventLoop *, int32_t, char *, int32_t))&v95, NULL);
        // branch -> 0x104ee
    }
    // 0x104ee
    int32_t result; // 0x10504_2
    if (with_thread == 0) {
        // 0x104f0
        aeMain((struct aeEventLoop *)v99);
        aeDeleteEventLoop((struct aeEventLoop *)v100);
        result = with_thread;
        // branch -> 0x10502
    } else {
        // 0x10508
        v97 = pthread_create((int32_t *)thread, NULL, (char * (**)(char *))&thread_func, (char *)thread_func_arg);
        if (v97 != 0) {
            // 0x1051a
            printf((char *)0x16c6c);
            result = 0;
            // branch -> 0x10502
        } else {
            result = 0;
        }
    }
    // 0x10502
    return result;
}

// Address range: 0x1055a - 0x1057b
int32_t function_1055a(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x1055a
    return 256 * a4;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_socket_server.c
// Address range: 0x1057c - 0x1058f
// Line range:    2387 - 2392
int32_t main_test_svc(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x1057c
    int32_t v97;
    int32_t flag = v97; // bp-12
    init_socket_server_module(0, &flag);
    return 0;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_socket_server.c
// Address range: 0x106bc - 0x1071d
// Line range:    2415 - 2446
int32_t appmngr_server_free_client(int32_t sockfd) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x106bc
    if (sockfd == 0) {
        // 0x106d0
        return 0;
    }
    int32_t v97 = 0;
    int32_t v98; // 0x106c8
    struct listIter_1 * v99 = listGetIterator((struct list_1 *)v98, 0); // 0x106d8
    int32_t v100 = (int32_t)v99;
    if (listNext(v99) == NULL) {
        // 0x1070c
        listReleaseIterator((struct listIter_1 *)v100);
        if (v97 == 0) {
            // 0x10716
            return -1;
        }
        // 0x106d0
        return 0;
    }
    while (true) {
        // 0x106e6
        int32_t v101; // 0x106e6
        if (v101 != 0) {
            // 0x106ec
            int32_t v102; // 0x106ec
            if (v102 == sockfd) {
                // 0x106f2
                lock_mutex_server();
                v97 = 1;
                freeClient((struct redisClient *)v101);
                unlock_mutex_server();
                if (listNext((struct listIter_1 *)v100) == NULL) {
                    // break -> 0x1070c
                    break;
                }
                // continue -> 0x106e6
                continue;
            }
        }
        // 0x106de
        if (listNext((struct listIter_1 *)v100) == NULL) {
            // break -> 0x1070c
            break;
        }
        // continue -> 0x106e6
    }
    // 0x1070c
    listReleaseIterator((struct listIter_1 *)v100);
    if (v97 == 0) {
        // 0x10716
        return -1;
    }
    // 0x106d0
    return 0;
}

// Address range: 0x1071e - 0x10723
int32_t function_1071e(int32_t a1, int32_t a2) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x1071e
    int32_t v97;
    return 256 * v97;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_parse_ini.c
// Address range: 0x107a8 - 0x10a53
// Line range:    257 - 270
int32_t LoadIniFile(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    int32_t v97;
    memset((char *)&v97, 0, 128);
    int32_t v98;
    memset((char *)&v98, 0, 64);
    int32_t v99;
    memset((char *)&v99, 0, 64);
    int32_t v100;
    memset((char *)&v100, 0, 128);
    int32_t file_path; // 0x107ea
    fopen((char *)file_path, "r");
    return -1;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_parse_ini.c
// Address range: 0x10a54 - 0x10a9b
// Line range:    310 - 314
int32_t ini_parser_create(char * file_name) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    int16_t * v25; // 0x213f0
    char * v26; // 0x213f2
    char * v27; // 0x213f4
    int32_t v28; // 0x213f8
    int32_t v29; // 0x21400
    int32_t v30; // 0x21404
    void (*v31)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v32)[128]; // 0x21418
    int32_t v33; // 0x2141c
    int32_t v34; // 0x21420
    char ** v35; // 0x21424
    int32_t v36; // 0x21428
    int32_t v37; // 0x21434
    int32_t v38; // 0x21438
    int32_t * v39; // 0x2143c
    int32_t v40; // 0x21440
    int32_t v41; // 0x21448
    int32_t v42; // 0x2144c
    int32_t v43; // 0x21450
    int32_t v44; // 0x21458
    int32_t v45; // 0x21460
    char * v46; // 0x21470
    int32_t v47; // 0x21498
    int32_t v48; // 0x214a4
    char * v49; // 0x215d8
    int32_t v50; // 0x217b4
    char * v51; // 0x21ae8
    char * v52; // 0x2292e
    int32_t v53; // 0x22f95
    int32_t v54; // 0x22f9c
    int32_t v55; // 0x22fa0
    int32_t v56; // 0x22fa4
    int32_t v57; // 0x22fb0
    struct TAG_Mutex_3 * v58; // 0x22fb8
    char * v59; // 0x22fd4
    int32_t v60; // 0x22fdc
    int32_t v61; // 0x2300c
    int32_t v62; // 0x2301c
    int32_t v63; // 0x23030
    int32_t v64; // 0x23034
    int32_t v65; // 0x23038
    struct PM_OBJ_TAG * v66; // 0x2303c
    int32_t v67; // 0x23040
    int32_t v68; // 0x23044
    int32_t v69; // 0x23048
    int32_t v70; // 0x2304c
    struct TAG_Mutex_3 * v71; // 0x23058
    struct TAG_WaitCond_2 * v72; // 0x23070
    int32_t v73; // 0x230a0
    int32_t v74; // 0x230a4
    int32_t v75; // 0x230e0
    int32_t v76; // 0x230e4
    struct TAG_Mutex_3 * v77; // 0x230e8
    char * v78; // 0x23100
    int32_t v79; // 0x23104
    int32_t v80; // 0x23108
    int32_t v81; // 0x2310c
    int32_t v82; // 0x23110
    int32_t v83; // 0x23114
    int32_t v84; // 0x23118
    int32_t v85; // 0x2311c
    int32_t v86; // 0x23120
    int32_t v87; // 0x23124
    int32_t v88; // 0x23128
    int32_t v89; // 0x8946
    int32_t v90; // 0xa6f2
    int32_t v91; // 0xdba0
    int32_t v92; // 0xf00b
    int32_t v93; // 0xf053
    int32_t v94; // 0xf207
    int32_t v95; // 0xfa6d
    int32_t v96 = (int32_t)file_name; // 0x10a54_0
    if (file_name == NULL) {
        // 0x10a8c
        return -1;
    }
    int32_t v97 = v96; // 0x10a66
    char * v98; // 0x213ec
    if (v98 == NULL) {
        char * mem = malloc(12); // 0x10a78
        if (mem == NULL) {
            // 0x10a8c
            return -1;
        }
        // 0x10a82
        *(int32_t *)mem = 0;
        v97 = v96;
        // branch -> 0x10a66
    }
    // 0x10a66
    __strdup((char *)v97);
    __strdup((char *)v97);
    LoadIniFile();
    return 0;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_parse_ini.c
// Address range: 0x10a9c - 0x10b09
// Line range:    333 - 369
int32_t ini_parser_destory(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    int16_t * v25; // 0x213f0
    char * v26; // 0x213f2
    char * v27; // 0x213f4
    int32_t v28; // 0x213f8
    int32_t v29; // 0x21400
    int32_t v30; // 0x21404
    void (*v31)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v32)[128]; // 0x21418
    int32_t v33; // 0x2141c
    int32_t v34; // 0x21420
    char ** v35; // 0x21424
    int32_t v36; // 0x21428
    int32_t v37; // 0x21434
    int32_t v38; // 0x21438
    int32_t * v39; // 0x2143c
    int32_t v40; // 0x21440
    int32_t v41; // 0x21448
    int32_t v42; // 0x2144c
    int32_t v43; // 0x21450
    int32_t v44; // 0x21458
    int32_t v45; // 0x21460
    char * v46; // 0x21470
    int32_t v47; // 0x21498
    int32_t v48; // 0x214a4
    char * v49; // 0x215d8
    int32_t v50; // 0x217b4
    char * v51; // 0x21ae8
    char * v52; // 0x2292e
    int32_t v53; // 0x22f95
    int32_t v54; // 0x22f9c
    int32_t v55; // 0x22fa0
    int32_t v56; // 0x22fa4
    int32_t v57; // 0x22fb0
    struct TAG_Mutex_3 * v58; // 0x22fb8
    char * v59; // 0x22fd4
    int32_t v60; // 0x22fdc
    int32_t v61; // 0x2300c
    int32_t v62; // 0x2301c
    int32_t v63; // 0x23030
    int32_t v64; // 0x23034
    int32_t v65; // 0x23038
    struct PM_OBJ_TAG * v66; // 0x2303c
    int32_t v67; // 0x23040
    int32_t v68; // 0x23044
    int32_t v69; // 0x23048
    int32_t v70; // 0x2304c
    struct TAG_Mutex_3 * v71; // 0x23058
    struct TAG_WaitCond_2 * v72; // 0x23070
    int32_t v73; // 0x230a0
    int32_t v74; // 0x230a4
    int32_t v75; // 0x230e0
    int32_t v76; // 0x230e4
    struct TAG_Mutex_3 * v77; // 0x230e8
    char * v78; // 0x23100
    int32_t v79; // 0x23104
    int32_t v80; // 0x23108
    int32_t v81; // 0x2310c
    int32_t v82; // 0x23110
    int32_t v83; // 0x23114
    int32_t v84; // 0x23118
    int32_t v85; // 0x2311c
    int32_t v86; // 0x23120
    int32_t v87; // 0x23124
    int32_t v88; // 0x23128
    int32_t v89; // 0x8946
    int32_t v90; // 0xa6f2
    int32_t v91; // 0xdba0
    int32_t v92; // 0xf00b
    int32_t v93; // 0xf053
    int32_t v94; // 0xf207
    int32_t v95; // 0xfa6d
    // 0x10a9c
    char * v96; // 0x213ec
    if (v96 == NULL) {
        // 0x10b02
        return -1;
    }
    // 0x10aac
    free(v96);
    int32_t v97; // 0x10ab4
    int32_t v98 = v97; // R6
    if (v97 == 0) {
        // 0x10afa
        free((char *)(int32_t)v96);
        return 0;
    }
    while (true) {
        // 0x10ab8
        int32_t v99; // 0x10ab8
        int32_t v100 = v99; // R4
        int32_t v101; // 0x10af2
        int32_t v102; // 0x10ade
        int32_t v103; // 0x10ae4
        int32_t v104; // 0x10aea
        if (v99 != 0) {
            while (true) {
                int32_t v105 = v99; // 0x10ad2
                int32_t v106; // 0x10ac0
                if (v106 != 0) {
                    // 0x10ac4
                    int32_t v107; // 0x10ac4
                    free((char *)v107);
                    int32_t v108; // 0x10acc
                    free((char *)v108);
                    v105 = v100;
                    // branch -> 0x10ad2
                }
                // 0x10ad2
                free((char *)v105);
                int32_t v109; // 0x10ad2
                if (v109 == 0) {
                    // 0x10ade
                    // branch -> 0x10ade
                    // 0x10ade
                    free((char *)v102);
                    free((char *)v103);
                    free((char *)v98);
                    v101 = v104;
                    if (v101 != 0) {
                      lab_0x10af4:
                        // 0x10af4
                        v98 = v101;
                        // branch -> 0x10ab8
                        break;
                    }
                    // 0x10af8
                    // branch -> 0x10afa
                    // 0x10afa
                    free((char *)(int32_t)v96);
                    return 0;
                }
                // 0x10abe
                v100 = v109;
                v99 = v109;
                // branch -> 0x10ac0
            }
        }
        // 0x10ade
        free((char *)v102);
        free((char *)v103);
        free((char *)v98);
        v101 = v104;
        if (v101 != 0) {
            goto lab_0x10af4;
        }
        // 0x10af8
        // branch -> 0x10afa
        // 0x10afa
        free((char *)(int32_t)v96);
        return 0;
    }
}

// Address range: 0x10b0a - 0x10b0f
int32_t function_10b0a(int32_t a1, int32_t a2) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x10b0a
    int32_t v97;
    return 256 * v97;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_ipc_socket.c
// Address range: 0x10b9c - 0x10b9f
// Line range:    9 - 12
int32_t checksum_ok(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x10b9c
    return 1;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_ipc_socket.c
// Address range: 0x10ba0 - 0x10ba3
// Line range:    14 - 17
int32_t appmngr_ipc_broadcast_event_to_slaves(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x10ba0
    return 0;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_event_queue.c
// Address range: 0x10ea0 - 0x10eab
// Line range:    39 - 42
struct APPMNGR_EventQ_Ctrl * get_eventQ_ctrl_obj(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x10ea0
    return (struct APPMNGR_EventQ_Ctrl *)&evtQueueObjCtrl;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_event_queue.c
// Address range: 0x10eac - 0x10eb9
// Line range:    44 - 46
int32_t init_event_queue_mem(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x10eac
    return init_queue_mem((struct anon_struct_129 *)&memManObj_EventQ, 124);
}

// Address range: 0x10eba - 0x10ebb
int32_t function_10eba(int32_t result) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x10eba
    return result;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_event_queue.c
// Address range: 0x10ed0 - 0x10ed9
// Line range:    77 - 79
int32_t deinit_event_queue_mem(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x10ed0
    return deinit_queue_mem((struct anon_struct_129 *)&memManObj_EventQ);
}

// Address range: 0x10eda - 0x10edb
int32_t function_10eda(int32_t result) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x10eda
    return result;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_event_queue.c
// Address range: 0x11054 - 0x11057
// Line range:    172 - 173
void dump_event(struct TagEventItem * evt, int32_t option, int32_t evtQ_num) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_event_queue.c
// Address range: 0x110b4 - 0x11171
// Line range:    196 - 249
int32_t appmngr_eventqueue_construct(struct APPMNGR_EventQ_Ctrl * thiz) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    int32_t v97 = (int32_t)thiz;
    if (thiz == NULL) {
        // 0x110d6
        return 2;
    }
    // 0x110c0
    memset((char *)thiz, 0, 168);
    int32_t result = init_event_queue_mem(); // 0x110c8
    if (result != 0) {
        // 0x110d0
        return 4;
    }
    // 0x110dc
    appmngr_mutex_init((struct TAG_Mutex_3 *)(v97 + 12));
    appmngr_waitcond_init((struct TAG_WaitCond_2 *)(v97 + 40));
    return result;
}

// Address range: 0x11172 - 0x111ab
int32_t function_11172(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x11172
    return 128 * a4;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_event_queue.c
// Address range: 0x111ac - 0x111c7
// Line range:    31 - 37
struct APPMNGR_EventQ_Ctrl * create_eventQ_ctrl_obj(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x111ac
    appmngr_eventqueue_construct((struct APPMNGR_EventQ_Ctrl *)&evtQueueObjCtrl);
    return NULL;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_event_queue.c
// Address range: 0x112d8 - 0x11337
// Line range:    829 - 855
int32_t appmngr_push_process_manage_event(int32_t sockfd, struct anon_struct_31 * pPmMsg) {
    struct TagEventItem v1;
    int32_t v2; // 0x101c1
    int32_t v3; // 0x111f1
    int32_t v4; // 0x12d09
    int32_t v5; // 0x13d01
    void (*v6)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v7; // 0x14b14
    int16_t * v8; // 0x14cde
    int32_t v9; // 0x157c5
    int32_t v10; // 0x1630f
    char * v11; // 0x16b14
    int32_t v12; // 0x21098
    int32_t v13; // 0x2109c
    int32_t v14; // 0x210a0
    int32_t v15; // 0x210a4
    int32_t * v16; // 0x211dc
    int32_t v17; // 0x213b8
    char * (**v18)(char *); // 0x213bc
    int32_t * v19; // 0x213c8
    int32_t * v20; // 0x213cc
    struct ApplicationManagerController ** v21; // 0x213d0
    int32_t v22; // 0x213d4
    char (*v23)[10]; // 0x213e0
    char * v24[2]; // 0x213e4
    char * (**v25)(char *); // 0x213e8
    char * v26; // 0x213ec
    int16_t * v27; // 0x213f0
    char * v28; // 0x213f2
    char * v29; // 0x213f4
    int32_t v30; // 0x213f8
    int32_t v31; // 0x21400
    int32_t v32; // 0x21404
    void (*v33)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v34)[128]; // 0x21418
    int32_t v35; // 0x2141c
    int32_t v36; // 0x21420
    char ** v37; // 0x21424
    int32_t v38; // 0x21428
    int32_t v39; // 0x21434
    int32_t v40; // 0x21438
    int32_t * v41; // 0x2143c
    int32_t v42; // 0x21440
    int32_t v43; // 0x21448
    int32_t v44; // 0x2144c
    int32_t v45; // 0x21450
    int32_t v46; // 0x21458
    int32_t v47; // 0x21460
    char * v48; // 0x21470
    int32_t v49; // 0x21498
    int32_t v50; // 0x214a4
    char * v51; // 0x215d8
    int32_t v52; // 0x217b4
    char * v53; // 0x21ae8
    char * v54; // 0x2292e
    int32_t v55; // 0x22f95
    int32_t v56; // 0x22f9c
    int32_t v57; // 0x22fa0
    int32_t v58; // 0x22fa4
    int32_t v59; // 0x22fb0
    struct TAG_Mutex_3 * v60; // 0x22fb8
    char * v61; // 0x22fd4
    int32_t v62; // 0x22fdc
    int32_t v63; // 0x2300c
    int32_t v64; // 0x2301c
    int32_t v65; // 0x23030
    int32_t v66; // 0x23034
    int32_t v67; // 0x23038
    struct PM_OBJ_TAG * v68; // 0x2303c
    int32_t v69; // 0x23040
    int32_t v70; // 0x23044
    int32_t v71; // 0x23048
    int32_t v72; // 0x2304c
    struct TAG_Mutex_3 * v73; // 0x23058
    struct TAG_WaitCond_2 * v74; // 0x23070
    int32_t v75; // 0x230a0
    int32_t v76; // 0x230a4
    int32_t v77; // 0x230e0
    int32_t v78; // 0x230e4
    struct TAG_Mutex_3 * v79; // 0x230e8
    char * v80; // 0x23100
    int32_t v81; // 0x23104
    int32_t v82; // 0x23108
    int32_t v83; // 0x2310c
    int32_t v84; // 0x23110
    int32_t v85; // 0x23114
    int32_t v86; // 0x23118
    int32_t v87; // 0x2311c
    int32_t v88; // 0x23120
    int32_t v89; // 0x23124
    int32_t v90; // 0x23128
    int32_t v91; // 0x8946
    int32_t v92; // 0xa6f2
    int32_t v93; // 0xdba0
    int32_t v94; // 0xf00b
    int32_t v95; // 0xf053
    int32_t v96; // 0xf207
    int32_t v97; // 0xfa6d
    struct TagEventItem v98;
    int32_t v99;
    int32_t (*v100)() = (int32_t (*)())v99;
    int32_t v101 = (int32_t)pPmMsg;
    get_eventQ_ctrl_obj();
    int32_t v102 = &evtQueueObjCtrl;
    int32_t v103 = (int32_t)&v1; // 0x112ea_0
    memset((char *)&v1, 0, 124);
    int32_t v104;
    int32_t v105;
    int32_t v106;
    int32_t v107;
    int32_t v108; // 0x11314
    int32_t v109; // 0x112f0
    int32_t size; // 0x112fa
    if (v109 != 0) {
        // 0x112fa
        v104 = size;
        if (size != 0) {
          lab_0x11320_3:;
            char * mem = malloc(size); // 0x11322
            v1.e2 = mem;
            if (mem == NULL) {
                // 0x11334
                // branch -> 0x112fe
            } else {
                // 0x1132a
                int32_t v110; // 0x1132c
                memcpy(mem, (char *)v110, v104);
                // branch -> 0x112fe
            }
            // 0x112fe
            memcpy((char *)&v98, (char *)v101, 104);
            dump_event(&v1, 0, 255);
            ((int32_t (*)(int32_t, int32_t, int32_t))(v108 & -2))(v102, v103, v108);
            v101 = v105;
            v102 = v106;
            v104 = v107;
            v100();
            size = v104;
            // branch -> 0x11320
            goto lab_0x11320_3;
        }
        // 0x112fe
        memcpy((char *)&v98, (char *)v101, 104);
        dump_event(&v1, 0, 255);
        ((int32_t (*)(int32_t, int32_t, int32_t))(v108 & -2))(v102, v103, v108);
        v101 = v105;
        v102 = v106;
        v104 = v107;
        v100();
        size = v104;
        // branch -> 0x11320
        goto lab_0x11320_3;
    }
    // 0x112fe
    memcpy((char *)&v98, (char *)v101, 104);
    dump_event(&v1, 0, 255);
    ((int32_t (*)(int32_t, int32_t, int32_t))(v108 & -2))(v102, v103, v108);
    v101 = v105;
    v102 = v106;
    v104 = v107;
    v100();
    size = v104;
    // branch -> 0x11320
    goto lab_0x11320_3;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_event_queue.c
// Address range: 0x113d0 - 0x1140b
// Line range:    954 - 961
int32_t appmngr_push_system_virtual_event(struct anon_struct_36 * sysEvent) {
    struct TagEventItem v1;
    int32_t v2; // 0x101c1
    int32_t v3; // 0x111f1
    int32_t v4; // 0x12d09
    int32_t v5; // 0x13d01
    void (*v6)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v7; // 0x14b14
    int16_t * v8; // 0x14cde
    int32_t v9; // 0x157c5
    int32_t v10; // 0x1630f
    char * v11; // 0x16b14
    int32_t v12; // 0x21098
    int32_t v13; // 0x2109c
    int32_t v14; // 0x210a0
    int32_t v15; // 0x210a4
    int32_t * v16; // 0x211dc
    int32_t v17; // 0x213b8
    char * (**v18)(char *); // 0x213bc
    int32_t * v19; // 0x213c8
    int32_t * v20; // 0x213cc
    struct ApplicationManagerController ** v21; // 0x213d0
    int32_t v22; // 0x213d4
    char (*v23)[10]; // 0x213e0
    char * v24[2]; // 0x213e4
    char * (**v25)(char *); // 0x213e8
    char * v26; // 0x213ec
    int16_t * v27; // 0x213f0
    char * v28; // 0x213f2
    char * v29; // 0x213f4
    int32_t v30; // 0x213f8
    int32_t v31; // 0x21400
    int32_t v32; // 0x21404
    void (*v33)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v34)[128]; // 0x21418
    int32_t v35; // 0x2141c
    int32_t v36; // 0x21420
    char ** v37; // 0x21424
    int32_t v38; // 0x21428
    int32_t v39; // 0x21434
    int32_t v40; // 0x21438
    int32_t * v41; // 0x2143c
    int32_t v42; // 0x21440
    int32_t v43; // 0x21448
    int32_t v44; // 0x2144c
    int32_t v45; // 0x21450
    int32_t v46; // 0x21458
    int32_t v47; // 0x21460
    char * v48; // 0x21470
    int32_t v49; // 0x21498
    int32_t v50; // 0x214a4
    char * v51; // 0x215d8
    int32_t v52; // 0x217b4
    char * v53; // 0x21ae8
    char * v54; // 0x2292e
    int32_t v55; // 0x22f95
    int32_t v56; // 0x22f9c
    int32_t v57; // 0x22fa0
    int32_t v58; // 0x22fa4
    int32_t v59; // 0x22fb0
    struct TAG_Mutex_3 * v60; // 0x22fb8
    char * v61; // 0x22fd4
    int32_t v62; // 0x22fdc
    int32_t v63; // 0x2300c
    int32_t v64; // 0x2301c
    int32_t v65; // 0x23030
    int32_t v66; // 0x23034
    int32_t v67; // 0x23038
    struct PM_OBJ_TAG * v68; // 0x2303c
    int32_t v69; // 0x23040
    int32_t v70; // 0x23044
    int32_t v71; // 0x23048
    int32_t v72; // 0x2304c
    struct TAG_Mutex_3 * v73; // 0x23058
    struct TAG_WaitCond_2 * v74; // 0x23070
    int32_t v75; // 0x230a0
    int32_t v76; // 0x230a4
    int32_t v77; // 0x230e0
    int32_t v78; // 0x230e4
    struct TAG_Mutex_3 * v79; // 0x230e8
    char * v80; // 0x23100
    int32_t v81; // 0x23104
    int32_t v82; // 0x23108
    int32_t v83; // 0x2310c
    int32_t v84; // 0x23110
    int32_t v85; // 0x23114
    int32_t v86; // 0x23118
    int32_t v87; // 0x2311c
    int32_t v88; // 0x23120
    int32_t v89; // 0x23124
    int32_t v90; // 0x23128
    int32_t v91; // 0x8946
    int32_t v92; // 0xa6f2
    int32_t v93; // 0xdba0
    int32_t v94; // 0xf00b
    int32_t v95; // 0xf053
    int32_t v96; // 0xf207
    int32_t v97; // 0xfa6d
    struct TagEventItem v98;
    get_eventQ_ctrl_obj();
    int32_t v99 = &evtQueueObjCtrl;
    int32_t result; // 0x11402_2
    if ((int32_t)sysEvent == 0) {
        // 0x11404
        result = -1;
        // branch -> 0x11400
    } else {
        // 0x113de
        memset((char *)&v1, 0, 124);
        int32_t v100 = (int32_t)&v98; // 0x113f8_3
        int32_t v101; // 0x113f4
        int32_t v102; // 0x113f0
        ((int32_t (*)(int32_t, int32_t, int32_t, int32_t))(v101 & -2))(v99, (int32_t)&v1, v102, v100);
        result = v99;
        // branch -> 0x11400
    }
    // 0x11400
    return result;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/ApplicationManagerController.cpp
// Address range: 0x11464 - 0x11473
// Line range:    32 - 36
// Demangled:     ApplicationManagerController::ApplicationManagerController()
void _ZN28ApplicationManagerControllerC2Ev(struct ApplicationManagerController * this) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/ApplicationManagerController.cpp
// Address range: 0x11474 - 0x1149f
// Line range:    62 - 84
// Demangled:     ApplicationManagerController::SendCommandToApplicationManager(ApplicationManager::ControllerCommand)
void _ZN28ApplicationManagerController31SendCommandToApplicationManagerEN18ApplicationManager17ControllerCommandE(struct ApplicationManagerController * this, int32_t cmd) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    int32_t v53; // 0x22f95
    int32_t v54; // 0x22f9c
    int32_t v55; // 0x22fa0
    int32_t v56; // 0x22fa4
    int32_t v57; // 0x22fb0
    struct TAG_Mutex_3 * v58; // 0x22fb8
    char * v59; // 0x22fd4
    int32_t v60; // 0x22fdc
    int32_t v61; // 0x2300c
    int32_t v62; // 0x2301c
    int32_t v63; // 0x23030
    int32_t v64; // 0x23034
    int32_t v65; // 0x23038
    struct PM_OBJ_TAG * v66; // 0x2303c
    int32_t v67; // 0x23040
    int32_t v68; // 0x23044
    int32_t v69; // 0x23048
    int32_t v70; // 0x2304c
    struct TAG_Mutex_3 * v71; // 0x23058
    struct TAG_WaitCond_2 * v72; // 0x23070
    int32_t v73; // 0x230a0
    int32_t v74; // 0x230a4
    int32_t v75; // 0x230e0
    int32_t v76; // 0x230e4
    struct TAG_Mutex_3 * v77; // 0x230e8
    char * v78; // 0x23100
    int32_t v79; // 0x23104
    int32_t v80; // 0x23108
    int32_t v81; // 0x2310c
    int32_t v82; // 0x23110
    int32_t v83; // 0x23114
    int32_t v84; // 0x23118
    int32_t v85; // 0x2311c
    int32_t v86; // 0x23120
    int32_t v87; // 0x23124
    int32_t v88; // 0x23128
    int32_t v89; // 0x8946
    int32_t v90; // 0xa6f2
    int32_t v91; // 0xdba0
    int32_t v92; // 0xf00b
    int32_t v93; // 0xf053
    int32_t v94; // 0xf207
    int32_t v95; // 0xfa6d
    int32_t fd; // 0x11482
    write(fd, (char *)&cmd, 8);
    char * format; // 0x2292e
    printf((char *)&format);
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/ApplicationManagerController.cpp
// Address range: 0x114a0 - 0x114a3
// Line range:    112 - 114
int32_t amc_send_netflix_start_dummy(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x114a0
    appmngr_send_msg_netflix_start_dummy();
    return 0;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/ApplicationManagerController.cpp
// Address range: 0x114a4 - 0x116e3
// Line range:    118 - 128
int32_t netflix_get_system_info(struct anon_struct_41 * pst, int32_t mask) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x114a4
    return -1;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/ApplicationManagerController.cpp
// Address range: 0x116e4 - 0x118a7
// Line range:    310 - 318
// Demangled:     ApplicationManagerController::exec(char const *, char const *, void *, void *)
void _ZN28ApplicationManagerController4execEPKcS1_PvS2_(char * cmd_string, char * pData, char * pThis, char * pTargetThis) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    int32_t v79; // 0x23104
    int32_t v80; // 0x23108
    int32_t v81; // 0x2310c
    int32_t v82; // 0x23110
    int32_t v83; // 0x23114
    int32_t v84; // 0x23118
    int32_t v85; // 0x2311c
    int32_t v86; // 0x23120
    int32_t v87; // 0x23124
    int32_t v88; // 0x23128
    int32_t v89; // 0x8946
    int32_t v90; // 0xa6f2
    int32_t v91; // 0xdba0
    int32_t v92; // 0xf00b
    int32_t v93; // 0xf053
    int32_t v94; // 0xf207
    int32_t v95; // 0xfa6d
    // 0x116e4
    _ZN18ApplicationManager25StringToControllerCommandEPKc(cmd_string);
    char * format; // 0x23100
    printf((char *)&format);
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/ApplicationManagerController.cpp
// Address range: 0x11918 - 0x1195f
// Line range:    445 - 468
// Demangled:     ApplicationManagerController::init()
void _ZN28ApplicationManagerController4initEv(struct ApplicationManagerController * this) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x11918
    eventfd(0, 0);
    eventfd(0, 0);
    int32_t v97 = eventfd(0, 0); // 0x1192a
    int32_t v98; // 0x1192e
    if (v98 == -1 || v97 == -1) {
        // 0x1194e
        printf("\n [AMC]eventfd create err!");
        return;
    }
    // 0x1193a
    if (v97 < 1 || v98 < 1) {
        // 0x1194a
        return;
    }
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/ApplicationManagerController.cpp
// Address range: 0x11960 - 0x11983
// Line range:    518 - 523
int32_t Do_Ctrl_Cmd_Netflix(char * cmd, char * pData) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    int32_t v20; // 0x213d4
    char (*v21)[10]; // 0x213e0
    char * v22[2]; // 0x213e4
    char * (**v23)(char *); // 0x213e8
    char * v24; // 0x213ec
    int16_t * v25; // 0x213f0
    char * v26; // 0x213f2
    char * v27; // 0x213f4
    int32_t v28; // 0x213f8
    int32_t v29; // 0x21400
    int32_t v30; // 0x21404
    void (*v31)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v32)[128]; // 0x21418
    int32_t v33; // 0x2141c
    int32_t v34; // 0x21420
    char ** v35; // 0x21424
    int32_t v36; // 0x21428
    int32_t v37; // 0x21434
    int32_t v38; // 0x21438
    int32_t * v39; // 0x2143c
    int32_t v40; // 0x21440
    int32_t v41; // 0x2144c
    int32_t v42; // 0x21450
    int32_t v43; // 0x21458
    int32_t v44; // 0x21460
    char * v45; // 0x21470
    int32_t v46; // 0x21498
    int32_t v47; // 0x214a4
    char * v48; // 0x215d8
    int32_t v49; // 0x217b4
    char * v50; // 0x21ae8
    char * v51; // 0x2292e
    int32_t v52; // 0x22f95
    int32_t v53; // 0x22f9c
    int32_t v54; // 0x22fa0
    int32_t v55; // 0x22fa4
    int32_t v56; // 0x22fb0
    struct TAG_Mutex_3 * v57; // 0x22fb8
    char * v58; // 0x22fd4
    int32_t v59; // 0x22fdc
    int32_t v60; // 0x2300c
    int32_t v61; // 0x2301c
    int32_t v62; // 0x23030
    int32_t v63; // 0x23034
    int32_t v64; // 0x23038
    struct PM_OBJ_TAG * v65; // 0x2303c
    int32_t v66; // 0x23040
    int32_t v67; // 0x23044
    int32_t v68; // 0x23048
    int32_t v69; // 0x2304c
    struct TAG_Mutex_3 * v70; // 0x23058
    struct TAG_WaitCond_2 * v71; // 0x23070
    int32_t v72; // 0x230a0
    int32_t v73; // 0x230a4
    int32_t v74; // 0x230e0
    int32_t v75; // 0x230e4
    struct TAG_Mutex_3 * v76; // 0x230e8
    char * v77; // 0x23100
    int32_t v78; // 0x23104
    int32_t v79; // 0x23108
    int32_t v80; // 0x2310c
    int32_t v81; // 0x23110
    int32_t v82; // 0x23114
    int32_t v83; // 0x23118
    int32_t v84; // 0x2311c
    int32_t v85; // 0x23120
    int32_t v86; // 0x23124
    int32_t v87; // 0x23128
    int32_t v88; // 0x8946
    int32_t v89; // 0xa6f2
    int32_t v90; // 0xdba0
    int32_t v91; // 0xf00b
    int32_t v92; // 0xf053
    int32_t v93; // 0xf207
    int32_t v94; // 0xfa6d
    // 0x11960
    struct ApplicationManagerController ** v95; // 0x213d0
    int32_t v96 = *(int32_t *)&v95; // 0x1196a
    int32_t v97; // 0x21448
    _ZN28ApplicationManagerController4execEPKcS1_PvS2_(cmd, pData, (char *)v96, (char *)v97);
    return (int32_t)cmd;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/ApplicationManagerController.cpp
// Address range: 0x11984 - 0x119d3
// Line range:    532 - 547
int32_t send_waiting_status_to_amc(int32_t message) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    int32_t result;
    if (wait_eventFd < 1) {
        // 0x119ba
        printf((char *)0x1701c);
        result = -1;
        // branch -> 0x119b6
    } else {
        int32_t buf = message;
        printf((char *)0x16ff0);
        write(wait_eventFd, (char *)&buf, 8);
        result = 0;
        // branch -> 0x119b6
    }
    // 0x119b6
    return result;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/ApplicationManagerController.cpp
// Address range: 0x119d4 - 0x11ac7
// Line range:    552 - 561
int32_t wait_status_by_seconds(int32_t tm_sec, int32_t wait_msg) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    int32_t result; // R0
    if (wait_eventFd < 1) {
        // 0x11aa8
        result = -1;
        // branch -> 0x11a86
    } else {
        // 0x119e8
        int32_t v97;
        int32_t v98 = &v97; // R5
        printf((char *)0x17048);
        int32_t v99;
        int32_t v100 = (int32_t)&v99 + 4; // 0x119f68
        int32_t readfds;
        int32_t timeout;
        int32_t buf;
        if (v100 != v98) {
            while (v100 + 4 != v98) {
                // 0x119f6
                v100 += 4;
                // continue -> 0x119f6
            }
            // 0x11a02
            timeout = tm_sec;
            v99 = 1 << (wait_eventFd & 31);
            if (select(1024, (struct _TYPEDEF_fd_set *)&readfds, NULL, NULL, (struct timeval *)&timeout) >= 1) {
                // 0x11a5a
                read(wait_eventFd, (char *)&buf, 8);
                if (buf == wait_msg) {
                    // 0x11a8c
                    printf("\n [AMC] get wait msg.");
                    close(wait_eventFd);
                    // branch -> 0x11a86
                    // 0x11a86
                    return 1;
                }
            }
            // 0x11a6c
            printf("\n [AMC] timeout, get wait msg.");
            close(wait_eventFd);
            // branch -> 0x11a86
            // 0x11a86
            return 0;
        }
        // 0x11a02
        timeout = tm_sec;
        v99 = 1 << (wait_eventFd & 31);
        if (select(1024, (struct _TYPEDEF_fd_set *)&readfds, NULL, NULL, (struct timeval *)&timeout) >= 1) {
            // 0x11a5a
            read(wait_eventFd, (char *)&buf, 8);
            if (buf == wait_msg) {
                // 0x11a8c
                printf("\n [AMC] get wait msg.");
                close(wait_eventFd);
                // branch -> 0x11a86
                // 0x11a86
                return 1;
            }
        }
        // 0x11a6c
        printf("\n [AMC] timeout, get wait msg.");
        close(wait_eventFd);
        result = 0;
        // branch -> 0x11a86
    }
    // 0x11a86
    return result;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/ApplicationManagerController.cpp
// Address range: 0x11ac8 - 0x11ad7
// Line range:    698 - 700
int32_t cmd_netflix_start_foreground(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x11ac8
    return Do_Ctrl_Cmd_Netflix("start_foreground", NULL);
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/ApplicationManagerController.cpp
// Address range: 0x11ad8 - 0x11aeb
// Line range:    706 - 708
int32_t cmd_netflix_start_suspend(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x11ad8
    return Do_Ctrl_Cmd_Netflix((char *)0x16ee8, "source_type=22");
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/ApplicationManagerController.cpp
// Address range: 0x11aec - 0x11afb
// Line range:    714 - 716
int32_t cmd_netflix_suspend(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x11aec
    return Do_Ctrl_Cmd_Netflix("suspend", NULL);
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/ApplicationManagerController.cpp
// Address range: 0x11afc - 0x11b0b
// Line range:    722 - 724
int32_t cmd_netflix_background(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x11afc
    return Do_Ctrl_Cmd_Netflix("background", NULL);
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/ApplicationManagerController.cpp
// Address range: 0x11b0c - 0x11b1b
// Line range:    731 - 733
int32_t cmd_netflix_resume(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x11b0c
    return Do_Ctrl_Cmd_Netflix("resume", NULL);
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/ApplicationManagerController.cpp
// Address range: 0x11b2c - 0x11b3b
// Line range:    755 - 757
int32_t cmd_netflix_stop_resources(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x11b2c
    return Do_Ctrl_Cmd_Netflix("stop_resources", NULL);
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/ApplicationManagerController.cpp
// Address range: 0x11b3c - 0x11b4b
// Line range:    763 - 765
int32_t cmd_netflix_stop_user(char * type) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x11b3c
    return Do_Ctrl_Cmd_Netflix("stop_user", type);
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/ApplicationManagerController.cpp
// Address range: 0x11b4c - 0x11b5b
// Line range:    771 - 773
int32_t cmd_netflix_stop_dial(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x11b4c
    return Do_Ctrl_Cmd_Netflix("stop_dial", NULL);
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/ApplicationManagerController.cpp
// Address range: 0x11b5c - 0x11b6b
// Line range:    779 - 781
int32_t cmd_netflix_exit(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x11b5c
    return Do_Ctrl_Cmd_Netflix("exit", NULL);
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/ApplicationManagerController.cpp
// Address range: 0x11b6c - 0x11b7b
// Line range:    787 - 789
int32_t cmd_netflix_sigkill(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x11b6c
    return Do_Ctrl_Cmd_Netflix((char *)0x170ec, NULL);
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/ApplicationManagerController.cpp
// Address range: 0x11b7c - 0x11b8b
// Line range:    795 - 797
int32_t cmd_netflix_left(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x11b7c
    return Do_Ctrl_Cmd_Netflix((char *)0x170f4, NULL);
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/ApplicationManagerController.cpp
// Address range: 0x11b8c - 0x11b9b
// Line range:    803 - 805
int32_t cmd_netflix_right(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x11b8c
    return Do_Ctrl_Cmd_Netflix((char *)0x170fc, NULL);
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/ApplicationManagerController.cpp
// Address range: 0x11b9c - 0x11bab
// Line range:    811 - 813
int32_t cmd_netflix_up(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x11b9c
    return Do_Ctrl_Cmd_Netflix((char *)0x17104, NULL);
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/ApplicationManagerController.cpp
// Address range: 0x11bac - 0x11bbb
// Line range:    819 - 821
int32_t cmd_netflix_down(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x11bac
    return Do_Ctrl_Cmd_Netflix((char *)0x17108, NULL);
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/ApplicationManagerController.cpp
// Address range: 0x11bbc - 0x11bcb
// Line range:    827 - 829
int32_t cmd_netflix_enter(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x11bbc
    return Do_Ctrl_Cmd_Netflix((char *)0x17110, NULL);
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/ApplicationManagerController.cpp
// Address range: 0x11bcc - 0x11bdb
// Line range:    835 - 837
int32_t cmd_netflix_sleep(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x11bcc
    return Do_Ctrl_Cmd_Netflix((char *)0x17118, NULL);
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/ApplicationManagerController.cpp
// Address range: 0x11bdc - 0x11beb
// Line range:    843 - 845
int32_t cmd_netflix_wake(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x11bdc
    return Do_Ctrl_Cmd_Netflix((char *)0x17120, NULL);
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/ApplicationManagerController.cpp
// Address range: 0x11bec - 0x11bff
// Line range:    848 - 850
int32_t cmd_netflix_start_by_button(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x11bec
    return Do_Ctrl_Cmd_Netflix("start_foreground", (char *)0x17128);
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/ApplicationManagerController.cpp
// Address range: 0x11c00 - 0x11c13
// Line range:    853 - 855
int32_t cmd_netflix_start_by_icon(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x11c00
    return Do_Ctrl_Cmd_Netflix("start_foreground", (char *)0x17138);
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/ApplicationManagerController.cpp
// Address range: 0x11c14 - 0x11c23
// Line range:    858 - 862
int32_t cmd_netflix_start_by_dial(char * payload) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x11c14
    return Do_Ctrl_Cmd_Netflix("start_foreground", payload);
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/ApplicationManagerController.cpp
// Address range: 0x11c24 - 0x11c37
// Line range:    865 - 867
int32_t cmd_netflix_start_by_power_hotkey(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x11c24
    return Do_Ctrl_Cmd_Netflix("start_foreground", "source_type=19");
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/ApplicationManagerController.cpp
// Address range: 0x11c38 - 0x11cbb
// Line range:    873 - 904
int32_t cmd_netflix_clear_user_accounts(int32_t re_launch) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xfa6d
    // 0x11c38
    wait_eventFd = eventfd(0, 0);
    print_timestamp((char *)0x17158);
    cmd_netflix_stop_user(NULL);
    print_timestamp((char *)0x17164);
    if (wait_eventFd >= 1) {
        // 0x11c64
        int32_t v96; // 0xf207
        wait_status_by_seconds(5, (int32_t)&v96);
        // branch -> 0x11c6e
    }
    // 0x11c6e
    print_timestamp("clear stop");
    system("rm -rf /data/netflix_runtime/data/cache");
    system((char *)0x171a4);
    system((char *)0x171d0);
    system((char *)0x171f8);
    return 1;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/ApplicationManagerController.cpp
// Address range: 0x11cbc - 0x11cf7
// Line range:    906 - 918
int32_t cmd_netflix_reset_when_factory_default(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x11cbc
    cmd_netflix_clear_user_accounts(0);
    system((char *)0x17200);
    system((char *)0x1723c);
    system("chmod 777 /tmp/reset_doing;rm -rf /tmp/reset_doing");
    system("sync");
    return 0;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/ApplicationManagerController.cpp
// Address range: 0x11cf8 - 0x11d0f
// Line range:    923 - 925
int32_t notify_netflix_exit_from_em(int32_t pid) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x2144c
    int32_t v43; // 0x21450
    int32_t v44; // 0x21458
    int32_t v45; // 0x21460
    char * v46; // 0x21470
    int32_t v47; // 0x21498
    int32_t v48; // 0x214a4
    char * v49; // 0x215d8
    int32_t v50; // 0x217b4
    char * v51; // 0x21ae8
    char * v52; // 0x2292e
    int32_t v53; // 0x22f95
    int32_t v54; // 0x22f9c
    int32_t v55; // 0x22fa0
    int32_t v56; // 0x22fa4
    int32_t v57; // 0x22fb0
    struct TAG_Mutex_3 * v58; // 0x22fb8
    char * v59; // 0x22fd4
    int32_t v60; // 0x22fdc
    int32_t v61; // 0x2300c
    int32_t v62; // 0x2301c
    int32_t v63; // 0x23030
    int32_t v64; // 0x23034
    int32_t v65; // 0x23038
    struct PM_OBJ_TAG * v66; // 0x2303c
    int32_t v67; // 0x23040
    int32_t v68; // 0x23044
    int32_t v69; // 0x23048
    int32_t v70; // 0x2304c
    struct TAG_Mutex_3 * v71; // 0x23058
    struct TAG_WaitCond_2 * v72; // 0x23070
    int32_t v73; // 0x230a0
    int32_t v74; // 0x230a4
    int32_t v75; // 0x230e0
    int32_t v76; // 0x230e4
    struct TAG_Mutex_3 * v77; // 0x230e8
    char * v78; // 0x23100
    int32_t v79; // 0x23104
    int32_t v80; // 0x23108
    int32_t v81; // 0x2310c
    int32_t v82; // 0x23110
    int32_t v83; // 0x23114
    int32_t v84; // 0x23118
    int32_t v85; // 0x2311c
    int32_t v86; // 0x23120
    int32_t v87; // 0x23124
    int32_t v88; // 0x23128
    int32_t v89; // 0x8946
    int32_t v90; // 0xa6f2
    int32_t v91; // 0xdba0
    int32_t v92; // 0xf00b
    int32_t v93; // 0xf053
    int32_t v94; // 0xf207
    int32_t v95; // 0xfa6d
    // 0x11cf8
    int32_t result; // 0x21448
    _ZN18ApplicationManager11exit_notifyEPvi((char *)result, pid);
    return result;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/ApplicationManagerController.cpp
// Address range: 0x11d10 - 0x11d27
// Line range:    928 - 931
int32_t netflix_home_key_process(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x11d10
    printf("\n [AMC] suspend command --- home ---");
    return cmd_netflix_suspend();
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/ApplicationManagerController.cpp
// Address range: 0x11d28 - 0x11d7b
// Line range:    934 - 952
int32_t netflix_power_off_process(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xfa6d
    // 0x11d28
    printf("\n [AMC] stop command --- power off ---");
    eventfd(0, 0);
    eventfd(0, 0);
    cmd_netflix_stop_user(NULL);
    print_timestamp("off wait");
    if (wait_eventFd >= 1) {
        // 0x11d54
        int32_t v96; // 0xf207
        wait_status_by_seconds(5, (int32_t)&v96);
        // branch -> 0x11d5e
    }
    // 0x11d5e
    print_timestamp("off end");
    return 0;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/ApplicationManagerController.cpp
// Address range: 0x11d7c - 0x11da3
// Line range:    954 - 959
void amc_disable_netflix_key_event(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x11d7c
    printf("\n [amc] off netflix key !");
    appmngr_adjust_keyset_by_proc_name("vod.netflix", 3071, 3, 3);
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/ApplicationManagerController.cpp
// Address range: 0x11da4 - 0x11fff
// Line range:    962 - 967
int32_t exec_netflix_control_command(int32_t operation, char * pUrl) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x11da4
    printf("\n [AMC] nflx manager not be inited !");
    return -1;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/ApplicationManagerController.cpp
// Address range: 0x12000 - 0x12143
// Line range:    602 - 630
int32_t init_netflix_manager_module(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x12d09
    int32_t v3; // 0x13d01
    int32_t v4; // 0x14b14
    int16_t * v5; // 0x14cde
    int32_t v6; // 0x157c5
    int32_t v7; // 0x1630f
    char * v8; // 0x16b14
    int32_t v9; // 0x21098
    int32_t v10; // 0x2109c
    int32_t v11; // 0x210a0
    int32_t v12; // 0x210a4
    int32_t * v13; // 0x211dc
    int32_t v14; // 0x213b8
    char * (**v15)(char *); // 0x213bc
    int32_t * v16; // 0x213c8
    int32_t * v17; // 0x213cc
    struct ApplicationManagerController ** v18; // 0x213d0
    int32_t v19; // 0x213d4
    char (*v20)[10]; // 0x213e0
    char * v21[2]; // 0x213e4
    char * (**v22)(char *); // 0x213e8
    char * v23; // 0x213ec
    int16_t * v24; // 0x213f0
    char * v25; // 0x213f2
    char * v26; // 0x213f4
    int32_t v27; // 0x213f8
    int32_t v28; // 0x21400
    int32_t v29; // 0x21404
    void (*v30)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v31)[128]; // 0x21418
    int32_t v32; // 0x2141c
    int32_t v33; // 0x21420
    char ** v34; // 0x21424
    int32_t v35; // 0x21428
    int32_t v36; // 0x21434
    int32_t v37; // 0x21438
    int32_t * v38; // 0x2143c
    int32_t v39; // 0x21440
    int32_t v40; // 0x21448
    int32_t v41; // 0x2144c
    int32_t v42; // 0x21450
    int32_t v43; // 0x21458
    int32_t v44; // 0x21460
    char * v45; // 0x21470
    int32_t v46; // 0x214a4
    char * v47; // 0x215d8
    int32_t v48; // 0x217b4
    char * v49; // 0x21ae8
    char * v50; // 0x2292e
    int32_t v51; // 0x22f95
    int32_t v52; // 0x22f9c
    int32_t v53; // 0x22fa0
    int32_t v54; // 0x22fa4
    int32_t v55; // 0x22fb0
    struct TAG_Mutex_3 * v56; // 0x22fb8
    char * v57; // 0x22fd4
    int32_t v58; // 0x22fdc
    int32_t v59; // 0x2300c
    int32_t v60; // 0x2301c
    int32_t v61; // 0x23030
    int32_t v62; // 0x23034
    int32_t v63; // 0x23038
    struct PM_OBJ_TAG * v64; // 0x2303c
    int32_t v65; // 0x23040
    int32_t v66; // 0x23044
    int32_t v67; // 0x23048
    int32_t v68; // 0x2304c
    struct TAG_Mutex_3 * v69; // 0x23058
    struct TAG_WaitCond_2 * v70; // 0x23070
    int32_t v71; // 0x230a0
    int32_t v72; // 0x230a4
    int32_t v73; // 0x230e0
    int32_t v74; // 0x230e4
    struct TAG_Mutex_3 * v75; // 0x230e8
    char * v76; // 0x23100
    int32_t v77; // 0x23104
    int32_t v78; // 0x23108
    int32_t v79; // 0x2310c
    int32_t v80; // 0x23110
    int32_t v81; // 0x23114
    int32_t v82; // 0x23118
    int32_t v83; // 0x2311c
    int32_t v84; // 0x23120
    int32_t v85; // 0x23124
    int32_t v86; // 0x23128
    int32_t v87; // 0x8946
    int32_t v88; // 0xa6f2
    int32_t v89; // 0xdba0
    int32_t v90; // 0xf207
    int32_t v91; // 0xfa6d
    struct anon_struct_41 v92;
    struct anon_struct_41 v93;
    struct anon_struct_41 v94;
    netflix_get_system_info(&v94, 5);
    int32_t v95; // 0x12028
    printf("\n sys-info: boot[%d],", v95);
    char * v96 = _Znwj(16); // 0x12032
    int32_t v97 = (int32_t)v96; // R5
    _ZN28ApplicationManagerControllerC2Ev((struct ApplicationManagerController *)v96);
    if (v97 != 0) {
        // 0x12044
        _ZN28ApplicationManagerController4initEv((struct ApplicationManagerController *)v97);
        // branch -> 0x1204a
    }
    char * v98 = _Znwj(1144); // 0x1204e
    int32_t v99; // 0x111f1
    void (*v100)(struct parse_state *, int32_t, char **); // 0x13fed
    _ZN18ApplicationManagerC2Eii((struct ApplicationManager_1 *)v98, (int32_t)&v99, (int32_t)&v100);
    int32_t v101 = (int32_t)v98; // 0x12064
    int32_t v102; // 0x21498
    if (v101 != 0) {
        // 0x12066
        _ZN18ApplicationManager4initEPKc((struct ApplicationManager_1 *)v101, (char *)&v93);
        v102 = 0;
        // branch -> 0x12074
    }
    // 0x12074
    print_timestamp("boot_3");
    int32_t v103; // 0x12084
    switch (v103) {
        default: {
            // 0x1208c
            puts("[EM] start netflix by hotkey ! ");
            config_network_check(0, NULL);
            v102 = 17;
            int32_t v104; // 0xf053
            exec_netflix_control_command((int32_t)&v104, NULL);
            // branch -> 0x120ac
            // 0x120ac
            return 0;
        }
        case 0: {
            // 0x120b2
            if (check_network((char *)0x16df4) == 0) {
                // 0x120f0
                if (check_network((char *)0x16e18) == 0) {
                    // 0x120fc
                    config_network_check(1, (char *)&v92);
                    // branch -> 0x120ac
                    // 0x120ac
                    return 0;
                }
            }
            break;
        }
        case 2: {
            // 0x120de
            puts("\n [EM] net bad, no launch. ");
            config_network_check(0, NULL);
            // branch -> 0x120ac
            // 0x120ac
            return 0;
        }
    }
    // 0x120bc
    config_network_check(0, NULL);
    puts("[EM] start netflix with suspend mode ");
    sleep(1);
    int32_t v105; // 0xf00b
    exec_netflix_control_command((int32_t)&v105, NULL);
    // branch -> 0x120ac
    // 0x120ac
    return 0;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_event_manager.c
// Address range: 0x121d0 - 0x1221f
// Line range:    30 - 38
void print_timestamp(char * str) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    struct timeval_3 tp;
    int32_t v97 = (int32_t)str; // R4
    gettimeofday((struct timeval *)&tp, NULL);
    int32_t v98; // 0x121de
    int32_t v99 = v98 / 1000; // 0x121f4
    int32_t v100; // 0x121e8
    uint64_t v101 = (0x100000000 * (int64_t)(v99 >> 31) | (int64_t)v99) + 1000 * (int64_t)v100; // 0x121fc
    int32_t v102 = v97; // 0x12204
    if (v97 == 0) {
        // 0x12210
        v102 = (int32_t)"NULL";
        // branch -> 0x12202
    }
    // 0x12202
    printf("\n TM-[%s], tm[%lld]", (char *)v102, v101);
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_event_manager.c
// Address range: 0x12220 - 0x12273
// Line range:    115 - 154
int32_t init_input_capture(int32_t argc, char ** argv) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    DirectFBInit((int32_t)&argc, (int32_t)&argv);
    return -1;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/ApplicationManager.cpp
// Address range: 0x1257c - 0x125a3
// Line range:    73 - 76
void disable_netflix_key_event(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x1257c
    printf((char *)0x177ac);
    appmngr_adjust_keyset_by_proc_name("vod.netflix", 3071, 3, 3);
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/ApplicationManager.cpp
// Address range: 0x125cc - 0x125ff
// Line range:    85 - 93
int32_t proc_netflix_exit_cleanup(uint32_t exit_code) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x125cc
    if (exit_code > 5) {
        // 0x125e6
        appmngr_send_msg_netflix_exit_dummy();
        return 0;
    }
    int32_t v97 = 1 << exit_code; // 0x125d4
    if ((v97 & 50) != 0) {
        // 0x125de
        return system("dd if=/dev/zero of=/dev/fb0");
    }
    // 0x125ee
    if ((v97 & 12) != 0) {
        // 0x125f4
        disable_netflix_key_event();
        // branch -> 0x125e6
    }
    // 0x125e6
    appmngr_send_msg_netflix_exit_dummy();
    return 0;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/ApplicationManager.h
// Address range: 0x12654 - 0x126fb
// Line range:    152 - 173
// Demangled:     ApplicationManager::setenv_model_name()
void _ZN18ApplicationManager17setenv_model_nameEv(struct ApplicationManager_1 * this) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * v24; // 0x213f4
    int32_t v25; // 0x213f8
    int32_t v26; // 0x21400
    int32_t v27; // 0x21404
    void (*v28)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v29)[128]; // 0x21418
    int32_t v30; // 0x2141c
    int32_t v31; // 0x21420
    char ** v32; // 0x21424
    int32_t v33; // 0x21428
    int32_t v34; // 0x21434
    int32_t v35; // 0x21438
    int32_t * v36; // 0x2143c
    int32_t v37; // 0x21440
    int32_t v38; // 0x21448
    int32_t v39; // 0x2144c
    int32_t v40; // 0x21450
    int32_t v41; // 0x21458
    int32_t v42; // 0x21460
    char * v43; // 0x21470
    int32_t v44; // 0x21498
    int32_t v45; // 0x214a4
    char * v46; // 0x215d8
    int32_t v47; // 0x217b4
    char * v48; // 0x21ae8
    char * v49; // 0x2292e
    int32_t v50; // 0x22f95
    int32_t v51; // 0x22f9c
    int32_t v52; // 0x22fa0
    int32_t v53; // 0x22fa4
    int32_t v54; // 0x22fb0
    struct TAG_Mutex_3 * v55; // 0x22fb8
    char * v56; // 0x22fd4
    int32_t v57; // 0x22fdc
    int32_t v58; // 0x2300c
    int32_t v59; // 0x2301c
    int32_t v60; // 0x23030
    int32_t v61; // 0x23034
    int32_t v62; // 0x23038
    struct PM_OBJ_TAG * v63; // 0x2303c
    int32_t v64; // 0x23040
    int32_t v65; // 0x23044
    int32_t v66; // 0x23048
    int32_t v67; // 0x2304c
    struct TAG_Mutex_3 * v68; // 0x23058
    struct TAG_WaitCond_2 * v69; // 0x23070
    int32_t v70; // 0x230a0
    int32_t v71; // 0x230a4
    int32_t v72; // 0x230e0
    int32_t v73; // 0x230e4
    struct TAG_Mutex_3 * v74; // 0x230e8
    char * v75; // 0x23100
    int32_t v76; // 0x23104
    int32_t v77; // 0x23108
    int32_t v78; // 0x2310c
    int32_t v79; // 0x23110
    int32_t v80; // 0x23114
    int32_t v81; // 0x23118
    int32_t v82; // 0x2311c
    int32_t v83; // 0x23120
    int32_t v84; // 0x23124
    int32_t v85; // 0x23128
    int32_t v86; // 0x8946
    int32_t v87; // 0xa6f2
    int32_t v88; // 0xdba0
    int32_t v89; // 0xf00b
    int32_t v90; // 0xf053
    int32_t v91; // 0xf207
    int32_t v92; // 0xfa6d
    char buf[50];
    int32_t v93 = 0; // R4
    int32_t fd = open("/tmp/ntfx_model_name", O_RDONLY);
    if (fd < v93 || read(fd, buf, 50) == 0) {
        // 0x12692
        return;
    }
    char * (**v94)(char *) = (char * (**)(char *))0x4c45444f; // 0x213e8
    char * v95 = (char *)0x4d414e5f; // 0x213ec
    int16_t * v96; // 0x213f0
    *(int16_t *)&v96 = (int16_t)"[AM] model env[%d],[%s] \n";
    char * str; // 0x213f2
    strcpy((char *)&str, buf);
    int32_t v97; // 0x126bc5
    if (v97 == 0) {
        // 0x126c6
        if (v93 <= 31) {
            // 0x126ca
            printf((char *)0x17848);
            // branch -> 0x12692
        }
        // 0x12692
        return;
    }
    int32_t v98 = v93 + 1; // 0x126c09
    int32_t v99 = (int32_t)&boot_cmdline + 4; // 0x126bc8
    int32_t v100; // 0x126bc
    while (v100 != 0) {
        // 0x126ba
        v98++;
        v99 += 4;
        // continue -> 0x126ba
    }
    // 0x126c6
    if (v98 <= 31) {
        // 0x126ca
        printf((char *)0x17848);
        // branch -> 0x12692
    }
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/ApplicationManager.h
// Address range: 0x126fc - 0x12767
// Line range:    181 - 196
// Demangled:     ApplicationManager::setenv_frc_feature()
void _ZN18ApplicationManager18setenv_frc_featureEv(struct ApplicationManager_1 * this) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x126fc
    if (open((char *)0x17864, O_RDONLY) < 0) {
        // 0x1273a
        return;
    }
    int32_t v97 = 0; // R3
    int32_t v98; // 0x1271c
    *(int16_t *)&v23 = (int16_t)v98;
    int32_t v99; // 0x1272c10
    if (v99 == 0) {
        // 0x12736
        if (v97 >= 32) {
            // 0x1273a
            return;
        }
        // 0x1273c
        printf((char *)0x1787c);
        return;
    }
    int32_t v100 = v97 + 1; // 0x1273014
    int32_t v101 = (int32_t)&boot_cmdline + 4; // 0x1272c13
    int32_t v102; // 0x1272c
    while (v102 != 0) {
        // 0x1272a
        v100++;
        v101 += 4;
        // continue -> 0x1272a
    }
    // 0x12736
    if (v100 >= 32) {
        // 0x1273a
        return;
    }
    // 0x1273c
    printf((char *)0x1787c);
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/ApplicationManager.h
// Address range: 0x12770 - 0x1285b
// Line range:    201 - 219
// Demangled:     ApplicationManager::setenv_firmware_version()
void _ZN18ApplicationManager23setenv_firmware_versionEv(struct ApplicationManager_1 * this) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    int32_t v33; // 0x2141c
    int32_t v34; // 0x21420
    char ** v35; // 0x21424
    int32_t v36; // 0x21428
    int32_t v37; // 0x21434
    int32_t v38; // 0x21438
    int32_t * v39; // 0x2143c
    int32_t v40; // 0x21440
    int32_t v41; // 0x21448
    int32_t v42; // 0x2144c
    int32_t v43; // 0x21450
    int32_t v44; // 0x21458
    int32_t v45; // 0x21460
    char * v46; // 0x21470
    int32_t v47; // 0x21498
    int32_t v48; // 0x214a4
    char * v49; // 0x215d8
    int32_t v50; // 0x217b4
    char * v51; // 0x21ae8
    char * v52; // 0x2292e
    int32_t v53; // 0x22f95
    int32_t v54; // 0x22f9c
    int32_t v55; // 0x22fa0
    int32_t v56; // 0x22fa4
    int32_t v57; // 0x22fb0
    struct TAG_Mutex_3 * v58; // 0x22fb8
    char * v59; // 0x22fd4
    int32_t v60; // 0x22fdc
    int32_t v61; // 0x2300c
    int32_t v62; // 0x2301c
    int32_t v63; // 0x23030
    int32_t v64; // 0x23034
    int32_t v65; // 0x23038
    struct PM_OBJ_TAG * v66; // 0x2303c
    int32_t v67; // 0x23040
    int32_t v68; // 0x23044
    int32_t v69; // 0x23048
    int32_t v70; // 0x2304c
    struct TAG_Mutex_3 * v71; // 0x23058
    struct TAG_WaitCond_2 * v72; // 0x23070
    int32_t v73; // 0x230a0
    int32_t v74; // 0x230a4
    int32_t v75; // 0x230e0
    int32_t v76; // 0x230e4
    struct TAG_Mutex_3 * v77; // 0x230e8
    char * v78; // 0x23100
    int32_t v79; // 0x23104
    int32_t v80; // 0x23108
    int32_t v81; // 0x2310c
    int32_t v82; // 0x23110
    int32_t v83; // 0x23114
    int32_t v84; // 0x23118
    int32_t v85; // 0x2311c
    int32_t v86; // 0x23120
    int32_t v87; // 0x23124
    int32_t v88; // 0x23128
    int32_t v89; // 0x8946
    int32_t v90; // 0xa6f2
    int32_t v91; // 0xdba0
    int32_t v92; // 0xf00b
    int32_t v93; // 0xf053
    int32_t v94; // 0xf207
    int32_t v95; // 0xfa6d
    char * env_val = getenv((char *)0x178a4); // 0x1277a
    int32_t str = (int32_t)env_val; // R6
    int32_t v96; // R8
    if (env_val == NULL) {
        // 0x12820
        v96 = 40;
        str = 0x17890;
        puts("[AM] env TCL_FIRMWARE_VERSION is null ");
        // branch -> 0x1279a
    } else {
        // 0x12786
        printf((char *)0x178bc);
        v96 = strlen((char *)str) + 22;
        // branch -> 0x1279a
    }
    // 0x1279a
    char (*v97)[128]; // 0x21418
    int32_t len; // 0x127cc
    int32_t v98; // 0x127b4
    int32_t v99; // 0x127b4
    int32_t v100; // 0x127a68
    int32_t str2; // 0x127c0
    if (v100 == 0) {
        // 0x127b4
        v98 = v96;
        v99 = v98 - 128;
        if (v99 == 0 || v99 < 0 ^ ((v98 - 130 ^ v98) & v98 + 0x7fffff7e) < 0) {
            // 0x127be
            str2 = *(int32_t *)&v97;
            len = strlen((char *)str2);
            strcpy((char *)(str2 + len + 21), (char *)str);
            printf((char *)0x1787c);
            return;
        }
        // 0x127ba
        return;
    }
    int32_t v101 = 1; // 0x127aa11
    int32_t v102 = (int32_t)&boot_cmdline + 4; // 0x127a610
    int32_t v103; // 0x127a6
    while (v103 != 0) {
        // 0x127a4
        v101++;
        v102 += 4;
        // continue -> 0x127a4
    }
    // 0x127b0
    if (v101 <= 31) {
        // 0x127b4
        v98 = v96;
        v99 = v98 - 128;
        if (v99 == 0 || v99 < 0 ^ ((v98 - 130 ^ v98) & v98 + 0x7fffff7e) < 0) {
            // 0x127be
            str2 = *(int32_t *)&v97;
            len = strlen((char *)str2);
            strcpy((char *)(str2 + len + 21), (char *)str);
            printf((char *)0x1787c);
            return;
        }
    }
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/ApplicationManager.h
// Address range: 0x12904 - 0x1293f
// Line range:    415 - 421
// Demangled:     ApplicationManager::StringToControllerCommand(char const *)
void _ZN18ApplicationManager25StringToControllerCommandEPKc(char * cmd) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    int32_t v97 = 0; // R5
    int32_t v98 = 0; // 0x1291a
    // branch -> 0x12914
    while (true) {
        // 0x12914
        int32_t str; // 0x12918
        if (strcmp((char *)str, (char *)(int32_t)cmd) == 0) {
            // 0x1292e
            return;
        }
        int32_t v99 = v97 + 1; // 0x12922
        v97 = v99;
        if (v99 == 18) {
            // 0x12928
            return;
        }
        // 0x12922
        v98 += 12;
        // branch -> 0x12914
    }
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/ApplicationManager.h
// Address range: 0x12940 - 0x1297b
// Line range:    427 - 432
// Demangled:     ApplicationManager::ControllerCommandToString(ApplicationManager::ControllerCommand)
void _ZN18ApplicationManager25ControllerCommandToStringENS_17ControllerCommandE(int32_t cmd) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    int32_t v97 = 0; // 0x1294e
    // branch -> 0x1294e
    for (uint32_t i = 0; i < 18; i++) {
        // 0x1294e
        int32_t v98; // 0x1294e
        if (v98 == cmd) {
            // 0x12964
            // branch -> 0x12960
            // 0x12960
            return;
        }
        // 0x12956
        // PHI copies at the loop end
        v97 += 12;
        // loop 0x1294e end
    }
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/ApplicationManager.h
// Address range: 0x1297c - 0x129ab
// Line range:    438 - 443
// Demangled:     ApplicationManager::ListCommands()
void _ZN18ApplicationManager12ListCommandsEv(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    struct ApplicationManagerController ** v19; // 0x213d0
    int32_t v20; // 0x213d4
    char (*v21)[10]; // 0x213e0
    char * v22[2]; // 0x213e4
    char * (**v23)(char *); // 0x213e8
    char * v24; // 0x213ec
    int16_t * v25; // 0x213f0
    char * v26; // 0x213f2
    char * v27; // 0x213f4
    int32_t v28; // 0x213f8
    int32_t v29; // 0x21400
    int32_t v30; // 0x21404
    void (*v31)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v32)[128]; // 0x21418
    int32_t v33; // 0x2141c
    int32_t v34; // 0x21420
    char ** v35; // 0x21424
    int32_t v36; // 0x21428
    int32_t v37; // 0x21434
    int32_t v38; // 0x21438
    int32_t * v39; // 0x2143c
    int32_t v40; // 0x21440
    int32_t v41; // 0x21448
    int32_t v42; // 0x2144c
    int32_t v43; // 0x21450
    int32_t v44; // 0x21458
    int32_t v45; // 0x21460
    char * v46; // 0x21470
    int32_t v47; // 0x21498
    char * v48; // 0x215d8
    int32_t v49; // 0x217b4
    char * v50; // 0x21ae8
    char * v51; // 0x2292e
    int32_t v52; // 0x22f95
    int32_t v53; // 0x22f9c
    int32_t v54; // 0x22fa0
    int32_t v55; // 0x22fa4
    int32_t v56; // 0x22fb0
    struct TAG_Mutex_3 * v57; // 0x22fb8
    char * v58; // 0x22fd4
    int32_t v59; // 0x22fdc
    int32_t v60; // 0x2300c
    int32_t v61; // 0x2301c
    int32_t v62; // 0x23030
    int32_t v63; // 0x23034
    int32_t v64; // 0x23038
    struct PM_OBJ_TAG * v65; // 0x2303c
    int32_t v66; // 0x23040
    int32_t v67; // 0x23044
    int32_t v68; // 0x23048
    int32_t v69; // 0x2304c
    struct TAG_Mutex_3 * v70; // 0x23058
    struct TAG_WaitCond_2 * v71; // 0x23070
    int32_t v72; // 0x230a0
    int32_t v73; // 0x230a4
    int32_t v74; // 0x230e0
    int32_t v75; // 0x230e4
    struct TAG_Mutex_3 * v76; // 0x230e8
    char * v77; // 0x23100
    int32_t v78; // 0x23104
    int32_t v79; // 0x23108
    int32_t v80; // 0x2310c
    int32_t v81; // 0x23110
    int32_t v82; // 0x23114
    int32_t v83; // 0x23118
    int32_t v84; // 0x2311c
    int32_t v85; // 0x23120
    int32_t v86; // 0x23124
    int32_t v87; // 0x23128
    int32_t v88; // 0x8946
    int32_t v89; // 0xa6f2
    int32_t v90; // 0xdba0
    int32_t v91; // 0xf00b
    int32_t v92; // 0xf053
    int32_t v93; // 0xf207
    int32_t v94; // 0xfa6d
    // 0x1297c
    int32_t * v95; // 0x213cc
    int32_t v96 = (int32_t)&v95; // 0x12994
    int32_t v97; // 0x1298e
    int32_t v98; // 0x1298e
    printf((char *)(int32_t)"%20s  %s\n", (char *)v97, (char *)v98);
    // branch -> 0x1298e
    int32_t v99; // 0x214a4
    while (v96 + 12 != (int32_t)&v99) {
        // 0x1298e
        // 0x1298e
        v96 += 12;
        printf((char *)(int32_t)"%20s  %s\n", (char *)v97, (char *)v98);
        // branch -> 0x1298e
    }
}

// Address range: 0x13292 - 0x132bb
int32_t function_13292(int32_t a1, int32_t a2) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xfa6d
    // 0x13292
    print_timestamp("stop waitpid");
    int32_t v96; // 0xf207
    return send_waiting_status_to_amc((int32_t)&v96);
}

// Address range: 0x132bc - 0x13389
int32_t function_132bc(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x132bc
    print_timestamp("\n stop 444");
    int32_t fd; // 0x132d0
    close(fd);
    int32_t str;
    if ((char)strcmp((char *)str, "close-only") == 0) {
        // 0x132f4
        printf("\n [STOP] - close-only.");
        // branch -> 0x132fe
    } else {
      lab_0x13306:
        // 0x13306
        proc_netflix_exit_cleanup(a7);
        // branch -> 0x132fe
    }
    // 0x132fe
    int32_t v97;
    ((int32_t (*)(int32_t))v97)(a7);
    // branch -> 0x13306
    goto lab_0x13306;
}

// Address range: 0x1338a - 0x1338f
int32_t function_1338a(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x1338a
    return 0xf207;
}

// Address range: 0x13390 - 0x133fb
int32_t function_13390(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x13390
    int32_t v97;
    send_waiting_status_to_amc(v97);
    int32_t v98;
    function_132bc(printf("\n stop 222-[%d]", 0), 0, v98, 0, 0, 0, 0, 0, 0, 0);
    return 0;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/ApplicationManager.h
// Address range: 0x134ac - 0x134ff
// Line range:    929 - 958
// Demangled:     ApplicationManager::exit_notify(void *, int)
void _ZN18ApplicationManager11exit_notifyEPvi(char * p_AM, int32_t appPID) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t v40; // 0x21440
    int32_t v41; // 0x21448
    int32_t v42; // 0x2144c
    int32_t v43; // 0x21450
    int32_t v44; // 0x21458
    int32_t v45; // 0x21460
    char * v46; // 0x21470
    int32_t v47; // 0x21498
    int32_t v48; // 0x214a4
    char * v49; // 0x215d8
    int32_t v50; // 0x217b4
    char * v51; // 0x21ae8
    char * v52; // 0x2292e
    int32_t v53; // 0x22f95
    int32_t v54; // 0x22f9c
    int32_t v55; // 0x22fa0
    int32_t v56; // 0x22fa4
    int32_t v57; // 0x22fb0
    struct TAG_Mutex_3 * v58; // 0x22fb8
    char * v59; // 0x22fd4
    int32_t v60; // 0x22fdc
    int32_t v61; // 0x2300c
    int32_t v62; // 0x2301c
    int32_t v63; // 0x23030
    int32_t v64; // 0x23034
    int32_t v65; // 0x23038
    struct PM_OBJ_TAG * v66; // 0x2303c
    int32_t v67; // 0x23040
    int32_t v68; // 0x23044
    int32_t v69; // 0x23048
    int32_t v70; // 0x2304c
    struct TAG_Mutex_3 * v71; // 0x23058
    struct TAG_WaitCond_2 * v72; // 0x23070
    int32_t v73; // 0x230a0
    int32_t v74; // 0x230a4
    int32_t v75; // 0x230e0
    int32_t v76; // 0x230e4
    struct TAG_Mutex_3 * v77; // 0x230e8
    char * v78; // 0x23100
    int32_t v79; // 0x23104
    int32_t v80; // 0x23108
    int32_t v81; // 0x2310c
    int32_t v82; // 0x23110
    int32_t v83; // 0x23114
    int32_t v84; // 0x23118
    int32_t v85; // 0x2311c
    int32_t v86; // 0x23120
    int32_t v87; // 0x23124
    int32_t v88; // 0x23128
    int32_t v89; // 0x8946
    int32_t v90; // 0xa6f2
    int32_t v91; // 0xdba0
    int32_t v92; // 0xf00b
    int32_t v93; // 0xf053
    int32_t v94; // 0xf207
    int32_t v95; // 0xfa6d
    int32_t * v96; // 0x2143c
    if (*(int32_t *)&v96 == appPID) {
        // 0x134c6
        print_timestamp((char *)0x17cd8);
        int32_t buf = 129;
        int32_t fd; // 0x134d4
        write(fd, (char *)&buf, 8);
        printf("\n [em]-netflix exception");
        // branch -> 0x134c0
    }
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/ApplicationManager.h
// Address range: 0x13500 - 0x135cb
// Line range:    1342 - 1350
// Demangled:     ApplicationManager::parse_cmdline(char const *, ApplicationManager::Args_Main *)
void _ZN18ApplicationManager13parse_cmdlineEPKcPNS_9Args_MainE(struct ApplicationManager_1 * this, char * cmd, struct anon_struct_118 * pout_args) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    int32_t str = (int32_t)cmd; // 0x13500_1
    int32_t v97; // 0x13516
    if (v97 != 0) {
        // 0x1351c
        printf("\n free [0x%x]", v97);
        int32_t v98; // 0x13524
        free((char *)v98);
        // branch -> 0x13530
    }
    int32_t len = strlen((char *)str); // 0x13532
    int32_t mem = (int32_t)malloc(len + 1); // 0x13538_3
    printf("\n malloc [0x%x]", mem);
    int32_t str2; // 0x1354c
    strcpy((char *)str2, (char *)str);
    unsigned char v99; // 0x1355a
    if (v99 == 0) {
        // 0x1359a
        // branch -> 0x1359c
        // 0x1359c
        return;
    }
    int32_t v100 = 0; // R0
    int32_t v101; // 0x13554
    int32_t v102 = v101 + 1; // 0x13560
    int32_t v103 = v99; // 0x1356c
    // branch -> 0x1356c
    while (true) {
        // 0x1356c
        if (v103 == 32) {
            // 0x13570
            v100++;
            if (v100 > 199) {
                // 0x135aa
                printf((char *)0x17d20);
                return;
            }
            // 0x1357e
            unsigned char v104; // 0x13580
            if (v104 == 0) {
                // break -> 0x13588
                break;
            }
            v102++;
            v103 = v104;
            // continue -> 0x1356c
            continue;
        } else {
            // 0x13566
            unsigned char v105; // 0x13566
            if (v105 == 0) {
                // break -> 0x13588
                break;
            }
            v102++;
            v103 = v105;
            // continue -> 0x1356c
            continue;
        }
    }
    // 0x13588
    if (v100 >= 199) {
        // 0x1358e
        return;
    }
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/ApplicationManager.h
// Address range: 0x135cc - 0x13613
// Line range:    1292 - 1321
// Demangled:     ApplicationManager::makeArgs_Q(char const *, ApplicationManager *)
void _ZN18ApplicationManager10makeArgs_QEPKcPS_(struct ApplicationManager_1 * this, char * pData, struct ApplicationManager_1 * pobject) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    int32_t v97 = (int32_t)this;
    int32_t v98 = (int32_t)&test;
    sprintf(test, (char *)0x17d34);
    _ZN18ApplicationManager13parse_cmdlineEPKcPNS_9Args_MainE((struct ApplicationManager_1 *)v97, (char *)v98, (struct anon_struct_118 *)(v97 + 92));
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/ApplicationManager.h
// Address range: 0x1361c - 0x13663
// Line range:    1407 - 1425
// Demangled:     ApplicationManager::init(char const *)
void _ZN18ApplicationManager4initEPKc(struct ApplicationManager_1 * this, char * language) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x13d01
    void (*v4)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v5; // 0x14b14
    int16_t * v6; // 0x14cde
    int32_t v7; // 0x157c5
    int32_t v8; // 0x1630f
    char * v9; // 0x16b14
    int32_t v10; // 0x21098
    int32_t v11; // 0x2109c
    int32_t v12; // 0x210a0
    int32_t v13; // 0x210a4
    int32_t * v14; // 0x211dc
    int32_t v15; // 0x213b8
    char * (**v16)(char *); // 0x213bc
    int32_t * v17; // 0x213c8
    int32_t * v18; // 0x213cc
    struct ApplicationManagerController ** v19; // 0x213d0
    int32_t v20; // 0x213d4
    char (*v21)[10]; // 0x213e0
    char * v22[2]; // 0x213e4
    char * (**v23)(char *); // 0x213e8
    char * v24; // 0x213ec
    int16_t * v25; // 0x213f0
    char * v26; // 0x213f2
    char * v27; // 0x213f4
    int32_t v28; // 0x213f8
    int32_t v29; // 0x21400
    int32_t v30; // 0x21404
    void (*v31)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v32)[128]; // 0x21418
    int32_t v33; // 0x2141c
    int32_t v34; // 0x21420
    char ** v35; // 0x21424
    int32_t v36; // 0x21428
    int32_t v37; // 0x21434
    int32_t v38; // 0x21438
    int32_t * v39; // 0x2143c
    int32_t v40; // 0x21440
    int32_t v41; // 0x21448
    int32_t v42; // 0x2144c
    int32_t v43; // 0x21450
    int32_t v44; // 0x21458
    int32_t v45; // 0x21460
    char * v46; // 0x21470
    int32_t v47; // 0x21498
    int32_t v48; // 0x214a4
    char * v49; // 0x215d8
    int32_t v50; // 0x217b4
    char * v51; // 0x21ae8
    char * v52; // 0x2292e
    int32_t v53; // 0x22f95
    int32_t v54; // 0x22f9c
    int32_t v55; // 0x22fa0
    int32_t v56; // 0x22fa4
    int32_t v57; // 0x22fb0
    struct TAG_Mutex_3 * v58; // 0x22fb8
    char * v59; // 0x22fd4
    int32_t v60; // 0x22fdc
    int32_t v61; // 0x2300c
    int32_t v62; // 0x2301c
    int32_t v63; // 0x23030
    int32_t v64; // 0x23034
    int32_t v65; // 0x23038
    struct PM_OBJ_TAG * v66; // 0x2303c
    int32_t v67; // 0x23040
    int32_t v68; // 0x23044
    int32_t v69; // 0x23048
    int32_t v70; // 0x2304c
    struct TAG_Mutex_3 * v71; // 0x23058
    struct TAG_WaitCond_2 * v72; // 0x23070
    int32_t v73; // 0x230a0
    int32_t v74; // 0x230a4
    int32_t v75; // 0x230e0
    int32_t v76; // 0x230e4
    struct TAG_Mutex_3 * v77; // 0x230e8
    char * v78; // 0x23100
    int32_t v79; // 0x23104
    int32_t v80; // 0x23108
    int32_t v81; // 0x2310c
    int32_t v82; // 0x23110
    int32_t v83; // 0x23114
    int32_t v84; // 0x23118
    int32_t v85; // 0x2311c
    int32_t v86; // 0x23120
    int32_t v87; // 0x23124
    int32_t v88; // 0x23128
    int32_t v89; // 0x8946
    int32_t v90; // 0xa6f2
    int32_t v91; // 0xdba0
    int32_t v92; // 0xf00b
    int32_t v93; // 0xf053
    int32_t v94; // 0xf207
    int32_t v95; // 0xfa6d
    int32_t v96 = (int32_t)this; // 0x1361c_0
    strncpy((char *)(v96 + 24), language, 5);
    _ZN18ApplicationManager23setenv_firmware_versionEv((struct ApplicationManager_1 *)v96);
    _ZN18ApplicationManager18setenv_frc_featureEv((struct ApplicationManager_1 *)v96);
    _ZN18ApplicationManager17setenv_model_nameEv((struct ApplicationManager_1 *)v96);
    int32_t thread_func; // 0x12d09
    pthread_create((int32_t *)(v96 + 16), NULL, (char * (**)(char *))&thread_func, (char *)(v96 + 20));
}

// From module:   /novatekoss/gcc-nt667_linux/bin/../lib/gcc/arm-linux-gnueabihf/4.7.3/../../../../arm-linux-gnueabihf/include/c++/4.7.3/bits/list.tcc
// Address range: 0x13664 - 0x1367b
// Line range:    66 - 71
// Demangled:     std::_List_base<ApplicationManager::actionEntry, std::allocator<ApplicationManager::actionEntry> >::_M_clear()
void _ZNSt10_List_baseIN18ApplicationManager11actionEntryESaIS1_EE8_M_clearEv(struct _List_base_lt_ApplicationManager__actionEntry_comma_std__allocator_lt_ApplicationManager__actionEntry_gt__gt__1 * this) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    int32_t v97 = (int32_t)this; // 0x13664_0
    int32_t v98 = *(int32_t *)this; // 0x13668
    if (v98 == v97) {
        // 0x1367a
        return;
    }
    _ZdlPv((char *)v98);
    int32_t v99; // 0x1366e
    while (v99 != v97) {
        // 0x1366e
        _ZdlPv((char *)v99);
        // continue -> 0x1366e
    }
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/ApplicationManager.h
// Address range: 0x1368c - 0x1379b
// Line range:    238 - 379
// Demangled:     ApplicationManager::ApplicationManager(int, int)
void _ZN18ApplicationManagerC2Eii(struct ApplicationManager_1 * this, int32_t efd, int32_t echo_efd) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    int32_t v47; // 0x21498
    int32_t v48; // 0x214a4
    int32_t v49; // 0x217b4
    char * v50; // 0x21ae8
    char * v51; // 0x2292e
    int32_t v52; // 0x22f95
    int32_t v53; // 0x22f9c
    int32_t v54; // 0x22fa0
    int32_t v55; // 0x22fa4
    int32_t v56; // 0x22fb0
    struct TAG_Mutex_3 * v57; // 0x22fb8
    char * v58; // 0x22fd4
    int32_t v59; // 0x22fdc
    int32_t v60; // 0x2300c
    int32_t v61; // 0x2301c
    int32_t v62; // 0x23030
    int32_t v63; // 0x23034
    int32_t v64; // 0x23038
    struct PM_OBJ_TAG * v65; // 0x2303c
    int32_t v66; // 0x23040
    int32_t v67; // 0x23044
    int32_t v68; // 0x23048
    int32_t v69; // 0x2304c
    struct TAG_Mutex_3 * v70; // 0x23058
    struct TAG_WaitCond_2 * v71; // 0x23070
    int32_t v72; // 0x230a0
    int32_t v73; // 0x230a4
    int32_t v74; // 0x230e0
    int32_t v75; // 0x230e4
    struct TAG_Mutex_3 * v76; // 0x230e8
    char * v77; // 0x23100
    int32_t v78; // 0x23104
    int32_t v79; // 0x23108
    int32_t v80; // 0x2310c
    int32_t v81; // 0x23110
    int32_t v82; // 0x23114
    int32_t v83; // 0x23118
    int32_t v84; // 0x2311c
    int32_t v85; // 0x23120
    int32_t v86; // 0x23124
    int32_t v87; // 0x23128
    int32_t v88; // 0x8946
    int32_t v89; // 0xa6f2
    int32_t v90; // 0xdba0
    int32_t v91; // 0xf00b
    int32_t v92; // 0xf053
    int32_t v93; // 0xf207
    int32_t v94; // 0xfa6d
    int32_t v95 = (int32_t)this + 1132; // R7
    if (getenv("NF_ONLY_SUSPEND") == NULL) {
        // 0x13774
        puts((char *)0x17db8);
        // branch -> 0x136d8
    } else {
        // 0x136cc
        puts("NF_ONLY_SUSPEND is set.  Background state is not supported by the application manager.");
        // branch -> 0x136d8
    }
    // 0x136d8
    int32_t v96; // R10
    int32_t v97;
    unsigned char v98; // 0x136d8
    if (v98 == 0) {
        // 0x1372c
        v96 = v98;
        char * v99; // 0x215d8
        memcpy((char *)&v97, (char *)&v99, 340);
        int32_t v100 = (int32_t)_Znwj(28); // 0x13744_3
        v96 += 20;
        int32_t v101; // 0x1375a
        int32_t v102; // 0x1375a
        _ZNSt8__detail15_List_node_base7_M_hookEPS0___GLIBCXX_3_4_15(v100, v95, v101, v102);
        // branch -> 0x13742
        while (v96 != 340) {
            // 0x13742
            v100 = (int32_t)_Znwj(28);
            v96 += 20;
            _ZNSt8__detail15_List_node_base7_M_hookEPS0___GLIBCXX_3_4_15(v100, v95, v101, v102);
            // continue -> 0x13742
        }
        // 0x13724
        return;
    }
    // 0x136e0
    v96 = 0;
    char * v103; // 0x21470
    memcpy((char *)&v97, (char *)&v103, 360);
    int32_t v104 = (int32_t)_Znwj(28); // 0x136f6_3
    v96 += 20;
    int32_t v105; // 0x1370c
    int32_t v106; // 0x1370c
    _ZNSt8__detail15_List_node_base7_M_hookEPS0___GLIBCXX_3_4_15(v104, v95, v105, v106);
    // branch -> 0x136f4
    while (v96 != 360) {
        // 0x136f4
        v104 = (int32_t)_Znwj(28);
        v96 += 20;
        _ZNSt8__detail15_List_node_base7_M_hookEPS0___GLIBCXX_3_4_15(v104, v95, v105, v106);
        // continue -> 0x136f4
    }
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/adlist.c
// Address range: 0x1379c - 0x137b7
// Line range:    41 - 53
struct list_1 * listCreate(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    char * mem = malloc(24); // 0x137a0
    if (mem != NULL) {
        // 0x137a6
        *(int32_t *)mem = 0;
        // branch -> 0x137b4
    }
    // 0x137b4
    return (struct list_1 *)mem;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/adlist.c
// Address range: 0x137b8 - 0x137e3
// Line range:    58 - 71
void listRelease(struct list_1 * list) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x137b8
    int32_t v97; // 0x137bc
    if (v97 == 0) {
        // 0x137d8
        free((char *)list);
        return;
    }
    // 0x137c2
    int32_t v98; // 0x137c2
    if (v98 != 0) {
        // 0x137c8
        int32_t v99; // 0x137c8
        ((int32_t (*)(int32_t))(v98 & -2))(v99);
        // branch -> 0x137cc
    }
    // 0x137cc
    free((char *)*(int32_t *)list);
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/adlist.c
// Address range: 0x138a4 - 0x138d7
// Line range:    159 - 168
void listDelNode(struct list_1 * list, struct listNode_1 * node) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    int32_t v97 = (int32_t)node; // 0x138a4_1
    int32_t v98 = (int32_t)list;
    int32_t * v99 = (int32_t *)(v97 + 4); // 0x138ac_0
    int32_t v100 = *v99; // 0x138ac
    int32_t * v101; // 0x138c6_0
    int32_t v102; // 0x138b8
    int32_t v103; // 0x138bc
    if (*(int32_t *)node != 0) {
        // 0x138b0
        if (*v99 != 0) {
            // 0x138b6
            // branch -> 0x138b8
            // 0x138b8
            if (v102 != 0) {
                // 0x138bc
                ((int32_t (*)(int32_t))(v102 & -2))(v103);
                // branch -> 0x138c0
            }
            // 0x138c0
            free((char *)v97);
            v101 = (int32_t *)(v98 + 20);
            *v101 = *v101 - 1;
            return;
        }
        // 0x138d4
        // branch -> 0x138b8
        // 0x138b8
        if (v102 != 0) {
            // 0x138bc
            ((int32_t (*)(int32_t))(v102 & -2))(v103);
            // branch -> 0x138c0
        }
        // 0x138c0
        free((char *)v97);
        v101 = (int32_t *)(v98 + 20);
        *v101 = *v101 - 1;
        return;
    }
    // 0x138ce
    *(int32_t *)list = v100;
    if (v100 != 0) {
        // 0x138b6
        // branch -> 0x138b8
        // 0x138b8
        if (v102 != 0) {
            // 0x138bc
            ((int32_t (*)(int32_t))(v102 & -2))(v103);
            // branch -> 0x138c0
        }
        // 0x138c0
        free((char *)v97);
        v101 = (int32_t *)(v98 + 20);
        *v101 = *v101 - 1;
        return;
    }
    // 0x138d4
    // branch -> 0x138b8
    // 0x138b8
    if (v102 != 0) {
        // 0x138bc
        ((int32_t (*)(int32_t))(v102 & -2))(v103);
        // branch -> 0x138c0
    }
    // 0x138c0
    free((char *)v97);
    v101 = (int32_t *)(v98 + 20);
    *v101 = *v101 - 1;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/adlist.c
// Address range: 0x138d8 - 0x138f7
// Line range:    178 - 184
struct listIter_1 * listGetIterator(struct list_1 * list, int32_t direction) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    char * mem = malloc(8); // 0x138e0
    if (mem == NULL) {
        // 0x138ee
        return (struct listIter_1 *)mem;
    }
    // 0x138e6
    if (direction == 0) {
        // 0x138f0
        int32_t v97; // 0x138f0
        *(int32_t *)mem = v97;
        // branch -> 0x138ec
    } else {
        // 0x138e8
        int32_t v98; // 0x138e8
        *(int32_t *)mem = v98;
        // branch -> 0x138ec
    }
    // 0x138ec
    // branch -> 0x138ee
    // 0x138ee
    return (struct listIter_1 *)mem;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/adlist.c
// Address range: 0x138f8 - 0x138fb
// Line range:    192 - 193
void listReleaseIterator(struct listIter_1 * iter) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x138f8
    free((char *)iter);
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/adlist.c
// Address range: 0x13914 - 0x1392b
// Line range:    221 - 232
struct listNode_1 * listNext(struct listIter_1 * iter) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    int32_t v97 = *(int32_t *)iter; // 0x13914
    if (v97 == 0) {
        // 0x13920
        return (struct listNode_1 *)0;
    }
    // 0x13918
    int32_t v98; // 0x13918
    if (v98 == 0) {
        // 0x13924
        int32_t v99; // 0x13924
        *(int32_t *)iter = v99;
        return (struct listNode_1 *)v97;
    }
    // 0x1391c
    int32_t v100; // 0x1391c
    *(int32_t *)iter = v100;
    // branch -> 0x13920
    // 0x13920
    return (struct listNode_1 *)v97;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/adlist.c
// Address range: 0x139b0 - 0x139e7
// Line range:    285 - 298
struct listNode_1 * listSearchKey(struct list_1 * list, char * key) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    struct listIter_1 * v97 = listGetIterator(list, 0); // 0x139b8
    int32_t v98 = (int32_t)v97;
    struct listNode_1 * v99 = listNext(v97); // 0x139c02
    int32_t v100 = (int32_t)v99;
    if (v99 == NULL) {
        // 0x139d6
        listReleaseIterator((struct listIter_1 *)v98);
        return (struct listNode_1 *)v100;
    }
    while (true) {
        // 0x139ca
        struct listNode_1 * v101; // 0x139c0
        int32_t v102; // 0x139ca
        int32_t v103; // 0x139e0
        if (v102 == 0) {
            // 0x139e0
            if (v103 == (int32_t)key) {
                // 0x139d6
                listReleaseIterator((struct listIter_1 *)v98);
                return (struct listNode_1 *)v100;
            }
        } else {
            // 0x139ce
            ((int32_t (*)(int32_t))(v102 & -2))(v103);
            if (v103 != 0) {
                // 0x139d6
                listReleaseIterator((struct listIter_1 *)v98);
                return (struct listNode_1 *)v100;
            }
            // 0x139be
            v101 = listNext((struct listIter_1 *)v98);
            v100 = (int32_t)v101;
            if (v101 == NULL) {
                // break -> 0x139d6
                break;
            }
            // continue -> 0x139ca
            continue;
        }
        // 0x139be
        v101 = listNext((struct listIter_1 *)v98);
        v100 = (int32_t)v101;
        if (v101 == NULL) {
            // break -> 0x139d6
            break;
        }
        // continue -> 0x139ca
    }
    // 0x139d6
    listReleaseIterator((struct listIter_1 *)v98);
    return (struct listNode_1 *)v100;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_queue_comm.c
// Address range: 0x13a28 - 0x13a67
// Line range:    13 - 31
int32_t init_queue_mem(struct anon_struct_129 * pmanObj, int32_t sizeUnit) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x13a28
    if (pmanObj == NULL) {
        // 0x13a54
        return -1;
    }
    // 0x13a36
    memset((char *)pmanObj, 0, 32);
    char * mem = malloc(128 * sizeUnit); // 0x13a46
    if (mem != NULL) {
        // 0x13a50
        return 0;
    }
    // 0x13a5a
    memset((char *)(int32_t)pmanObj, (int32_t)mem, 32);
    return -1;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_queue_comm.c
// Address range: 0x13a68 - 0x13a8b
// Line range:    43 - 57
int32_t deinit_queue_mem(struct anon_struct_129 * pmanObj) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x13a68
    if (pmanObj == NULL) {
        // 0x13a84
        return -1;
    }
    // 0x13a6e
    int32_t v97; // 0x13a6e
    if (v97 != 0) {
        // 0x13a72
        free((char *)v97);
        // branch -> 0x13a76
    }
    // 0x13a76
    memset((char *)(int32_t)pmanObj, 0, 32);
    return 0;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_queue_comm.c
// Address range: 0x13b54 - 0x13b57
// Line range:    146 - 187
int32_t errno_switch(int32_t erno) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x13b54
    return 1;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_queue_comm.c
// Address range: 0x13b58 - 0x13b6f
// Line range:    189 - 192
int32_t appmngr_mutex_lock(struct TAG_Mutex_3 * mutex) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x13b58
    if (pthread_mutex_lock(&mutex->e0.e0.e0) == 0) {
        // 0x13b60
        return 0;
    }
    int32_t v97 = *__errno_location(); // 0x13b66
    errno_switch(v97);
    return 1;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_queue_comm.c
// Address range: 0x13b88 - 0x13b9f
// Line range:    205 - 208
int32_t appmngr_mutex_unlock(struct TAG_Mutex_3 * mutex) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x13b88
    if (pthread_mutex_unlock(&mutex->e0.e0.e0) == 0) {
        // 0x13b90
        return 0;
    }
    int32_t v97 = *__errno_location(); // 0x13b96
    errno_switch(v97);
    return 1;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_queue_comm.c
// Address range: 0x13ba0 - 0x13bbb
// Line range:    213 - 217
int32_t appmngr_mutex_init(struct TAG_Mutex_3 * mutex) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x13ba0
    if (pthread_mutex_init(&mutex->e0.e0.e0, NULL) == 0) {
        // 0x13baa
        return 0;
    }
    int32_t v97 = *__errno_location(); // 0x13bb0
    errno_switch(v97);
    return 1;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_queue_comm.c
// Address range: 0x13c04 - 0x13c1f
// Line range:    254 - 257
int32_t appmngr_waitcond_init(struct TAG_WaitCond_2 * waitcond) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x13c04
    if (pthread_cond_init(&waitcond->e0.e0.e0, NULL) == 0) {
        // 0x13c0e
        return 0;
    }
    int32_t v97 = *__errno_location(); // 0x13c14
    errno_switch(v97);
    return 1;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_queue_comm.c
// Address range: 0x13cd0 - 0x13ce7
// Line range:    300 - 303
int32_t appmngr_waitcond_signal(struct TAG_WaitCond_2 * waitcond) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x13cd0
    if (pthread_cond_signal(&waitcond->e0.e0.e0) == 0) {
        // 0x13cd8
        return 0;
    }
    int32_t v97 = *__errno_location(); // 0x13cde
    errno_switch(v97);
    return 1;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_main.c
// Address range: 0x13d44 - 0x13d73
// Line range:    115 - 123
void start_event_loop_thread(struct anon_struct_139 * param) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    void (*v4)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v5; // 0x14b14
    int16_t * v6; // 0x14cde
    int32_t v7; // 0x157c5
    int32_t v8; // 0x1630f
    char * v9; // 0x16b14
    int32_t v10; // 0x21098
    int32_t v11; // 0x2109c
    int32_t v12; // 0x210a0
    int32_t v13; // 0x210a4
    int32_t * v14; // 0x211dc
    int32_t v15; // 0x213b8
    char * (**v16)(char *); // 0x213bc
    int32_t * v17; // 0x213c8
    int32_t * v18; // 0x213cc
    struct ApplicationManagerController ** v19; // 0x213d0
    int32_t v20; // 0x213d4
    char (*v21)[10]; // 0x213e0
    char * v22[2]; // 0x213e4
    char * (**v23)(char *); // 0x213e8
    char * v24; // 0x213ec
    int16_t * v25; // 0x213f0
    char * v26; // 0x213f2
    char * v27; // 0x213f4
    int32_t v28; // 0x213f8
    int32_t v29; // 0x21400
    int32_t v30; // 0x21404
    void (*v31)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v32)[128]; // 0x21418
    int32_t v33; // 0x2141c
    int32_t v34; // 0x21420
    char ** v35; // 0x21424
    int32_t v36; // 0x21428
    int32_t v37; // 0x21434
    int32_t v38; // 0x21438
    int32_t * v39; // 0x2143c
    int32_t v40; // 0x21440
    int32_t v41; // 0x21448
    int32_t v42; // 0x2144c
    int32_t v43; // 0x21450
    int32_t v44; // 0x21458
    int32_t v45; // 0x21460
    char * v46; // 0x21470
    int32_t v47; // 0x21498
    int32_t v48; // 0x214a4
    char * v49; // 0x215d8
    int32_t v50; // 0x217b4
    char * v51; // 0x21ae8
    char * v52; // 0x2292e
    int32_t v53; // 0x22f95
    int32_t v54; // 0x22f9c
    int32_t v55; // 0x22fa0
    int32_t v56; // 0x22fa4
    int32_t v57; // 0x22fb0
    struct TAG_Mutex_3 * v58; // 0x22fb8
    char * v59; // 0x22fd4
    int32_t v60; // 0x22fdc
    int32_t v61; // 0x2300c
    int32_t v62; // 0x2301c
    int32_t v63; // 0x23030
    int32_t v64; // 0x23034
    int32_t v65; // 0x23038
    struct PM_OBJ_TAG * v66; // 0x2303c
    int32_t v67; // 0x23040
    int32_t v68; // 0x23044
    int32_t v69; // 0x23048
    int32_t v70; // 0x2304c
    struct TAG_Mutex_3 * v71; // 0x23058
    struct TAG_WaitCond_2 * v72; // 0x23070
    int32_t v73; // 0x230a0
    int32_t v74; // 0x230a4
    int32_t v75; // 0x230e0
    int32_t v76; // 0x230e4
    struct TAG_Mutex_3 * v77; // 0x230e8
    char * v78; // 0x23100
    int32_t v79; // 0x23104
    int32_t v80; // 0x23108
    int32_t v81; // 0x2310c
    int32_t v82; // 0x23110
    int32_t v83; // 0x23114
    int32_t v84; // 0x23118
    int32_t v85; // 0x2311c
    int32_t v86; // 0x23120
    int32_t v87; // 0x23124
    int32_t v88; // 0x23128
    int32_t v89; // 0x8946
    int32_t v90; // 0xa6f2
    int32_t v91; // 0xdba0
    int32_t v92; // 0xf00b
    int32_t v93; // 0xf053
    int32_t v94; // 0xf207
    int32_t v95; // 0xfa6d
    // 0x13d44
    int32_t v96;
    int32_t evtloopThreadId = v96; // bp-12
    int32_t thread_func; // 0x13d01
    int32_t v97 = pthread_create(&evtloopThreadId, NULL, (char * (**)(char *))&thread_func, (char *)param); // 0x13d56
    if (v97 != 0) {
        // 0x13d5c
        printf((char *)0x16c6c);
        // branch -> 0x13d64
    }
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_main.c
// Address range: 0x13d74 - 0x13dfb
// Line range:    139 - 151
int32_t check_network(char * dev_name) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0xa6f2
    int32_t v91; // 0xdba0
    int32_t v92; // 0xf00b
    int32_t v93; // 0xf053
    int32_t v94; // 0xf207
    int32_t v95; // 0xfa6d
    struct ifreq v96;
    // 0x13d74
    strcpy(&v96.e0.e0[0], dev_name);
    int32_t sock_fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_IP); // 0x13d98
    if (sock_fd < 0) {
        // 0x13de6
        perror("\n [net] Cannot get control socket");
        // branch -> 0x13dc4
        // 0x13dc4
        return -1;
    }
    // 0x13da0
    int32_t request; // 0x8946
    int32_t result; // 0x13dc6_4
    if (ioctl(sock_fd, (int32_t)&request) == 0) {
        // 0x13db6
        close(sock_fd);
        result = 1;
        // branch -> 0x13dc4
    } else {
        // 0x13dc8
        if (*__errno_location() != 95) {
            // 0x13dd2
            perror("\n [net] Cannot get link status");
            // branch -> 0x13dda
        }
        // 0x13dda
        close(sock_fd);
        result = -1;
        // branch -> 0x13dc4
    }
    // 0x13dc4
    return result;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_main.c
// Address range: 0x13dfc - 0x13e33
// Line range:    179 - 187
void config_network_check(int32_t value, char * dev) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x13dfc
    enable_network_checking = value;
    if (dev == NULL) {
        // 0x13e24
        return;
    }
    // 0x13e06
    strncpy(dev_network_checking, dev, 10);
    printf("\n [netflix] checking %s.", (char *)(int32_t)&dev_network_checking);
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_main.c
// Address range: 0x13e34 - 0x13f7b
// Line range:    194 - 248
int32_t appmngr_monitor_process_status(int32_t block) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22fb0
    struct TAG_Mutex_3 * v56; // 0x22fb8
    char * v57; // 0x22fd4
    int32_t v58; // 0x22fdc
    int32_t v59; // 0x2300c
    int32_t v60; // 0x2301c
    int32_t v61; // 0x23030
    int32_t v62; // 0x23034
    int32_t v63; // 0x23038
    struct PM_OBJ_TAG * v64; // 0x2303c
    int32_t v65; // 0x23040
    int32_t v66; // 0x23044
    int32_t v67; // 0x23048
    int32_t v68; // 0x2304c
    struct TAG_Mutex_3 * v69; // 0x23058
    struct TAG_WaitCond_2 * v70; // 0x23070
    int32_t v71; // 0x230a0
    int32_t v72; // 0x230a4
    int32_t v73; // 0x230e0
    int32_t v74; // 0x230e4
    struct TAG_Mutex_3 * v75; // 0x230e8
    char * v76; // 0x23100
    int32_t v77; // 0x23104
    int32_t v78; // 0x23108
    int32_t v79; // 0x2310c
    int32_t v80; // 0x23110
    int32_t v81; // 0x23114
    int32_t v82; // 0x23118
    int32_t v83; // 0x2311c
    int32_t v84; // 0x23120
    int32_t v85; // 0x23124
    int32_t v86; // 0x23128
    int32_t v87; // 0x8946
    int32_t v88; // 0xa6f2
    int32_t v89; // 0xdba0
    int32_t v90; // 0xf053
    int32_t v91; // 0xf207
    int32_t v92; // 0xfa6d
    int32_t v93; // 0x13e78
    int32_t v94; // 0x13e7814
    int32_t v95;
    int32_t stat_loc;
    if (enable_network_checking != 0) {
        // 0x13e42
        int32_t v96; // 0x22f9c
        int32_t v97; // 0x22fa0
        int32_t v98; // 0x22fa4
        if (v96 == 0) {
            // 0x13e4c
            v96 = 1;
            v98 = 0;
            v97 = 1;
            // branch -> 0x13e5c
        } else {
            int32_t v99 = v97 + 1; // 0x13ed6
            int32_t v100 = v99 % 2; // 0x13ed8
            v97 = v99;
            if (v100 == 0) {
                // 0x13f0c
                if (check_network(dev_network_checking) >= 1) {
                    // 0x13f18
                    puts("[SYS] start netflix with suspend mode ");
                    int32_t v101; // 0xf00b
                    exec_netflix_control_command((int32_t)&v101, (char *)v100);
                    // branch -> 0x13f2e
                }
                // 0x13f2e
                v98++;
                // branch -> 0x13ee6
            }
            // 0x13ee6
            enable_network_checking = 0;
            v96 = 0;
            printf((char *)0x1854c);
            appmngr_send_msg_to_ui_by_transpond();
            // branch -> 0x13e5c
        }
        // 0x13e5c
        v94 = waitpid(-1, &stat_loc, 0);
        v95 = v94;
        if (v94 == -1) {
            while (true) {
                // 0x13e66
                if (*__errno_location() == 4) {
                  lab_0x13e66:
                    // 0x13e66
                    v93 = waitpid(-1, &stat_loc, 0);
                    v95 = v93;
                    if (v93 != -1) {
                        // break -> 0x13e82
                        break;
                    }
                    // continue -> 0x13e66
                    continue;
                }
            }
            // 0x13e82
            if (v93 >= 1) {
                // 0x13e86
                printf("\n waitpid returned pid %d, status = %08x\n", v93, stat_loc);
                print_timestamp("waitpid");
                notify_netflix_exit_from_em(v95);
                appmngr_pm_clear_terminative_process(v95, 0, 0, NULL);
                // branch -> 0x13eae
                // 0x13eae
                appmngr_pm_monitor_detached_process();
                if (access("/tmp/reset_doing", F_OK) == 0) {
                    // 0x13ebe
                    printf("\n [reset]doing !");
                    cmd_netflix_reset_when_factory_default();
                    // branch -> 0x13eca
                }
                // 0x13eca
                return 2;
            }
        } else {
            v93 = v94;
            // 0x13e82
            if (v93 >= 1) {
                // 0x13e86
                printf("\n waitpid returned pid %d, status = %08x\n", v93, stat_loc);
                print_timestamp("waitpid");
                notify_netflix_exit_from_em(v95);
                appmngr_pm_clear_terminative_process(v95, 0, 0, NULL);
                // branch -> 0x13eae
                // 0x13eae
                appmngr_pm_monitor_detached_process();
                if (access("/tmp/reset_doing", F_OK) == 0) {
                    // 0x13ebe
                    printf("\n [reset]doing !");
                    cmd_netflix_reset_when_factory_default();
                    // branch -> 0x13eca
                }
                // 0x13eca
                return 2;
            }
        }
        // 0x13f08
        // branch -> 0x13eae
        // 0x13eae
        appmngr_pm_monitor_detached_process();
        if (access("/tmp/reset_doing", F_OK) == 0) {
            // 0x13ebe
            printf("\n [reset]doing !");
            cmd_netflix_reset_when_factory_default();
            // branch -> 0x13eca
        }
        // 0x13eca
        return 1;
    }
    // 0x13e5c
    v94 = waitpid(-1, &stat_loc, 0);
    v95 = v94;
    if (v94 != -1) {
        v93 = v94;
        // 0x13e82
        if (v93 < 1) {
            // 0x13f08
            // branch -> 0x13eae
            // 0x13eae
            appmngr_pm_monitor_detached_process();
            if (access("/tmp/reset_doing", F_OK) == 0) {
                // 0x13ebe
                printf("\n [reset]doing !");
                cmd_netflix_reset_when_factory_default();
                // branch -> 0x13eca
            }
            // 0x13eca
            return 1;
        }
        // 0x13e86
        printf("\n waitpid returned pid %d, status = %08x\n", v93, stat_loc);
        print_timestamp("waitpid");
        notify_netflix_exit_from_em(v95);
        appmngr_pm_clear_terminative_process(v95, 0, 0, NULL);
        // branch -> 0x13eae
        // 0x13eae
        appmngr_pm_monitor_detached_process();
        if (access("/tmp/reset_doing", F_OK) == 0) {
            // 0x13ebe
            printf("\n [reset]doing !");
            cmd_netflix_reset_when_factory_default();
            // branch -> 0x13eca
        }
        // 0x13eca
        return 2;
    }
    while (true) {
        // 0x13e66
        if (*__errno_location() == 4) {
            goto lab_0x13e66;
        }
        int32_t result = 1;
        // branch -> 0x13eae
        // 0x13eae
        appmngr_pm_monitor_detached_process();
        if (access("/tmp/reset_doing", F_OK) != 0) {
            // 0x13eca
            return result;
        }
        // 0x13ebe
        printf("\n [reset]doing !");
        cmd_netflix_reset_when_factory_default();
        // branch -> 0x13eca
        // 0x13eca
        return result;
    }
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_process_manager.c
// Address range: 0x141d8 - 0x1420f
// Line range:    893 - 906
void valid_name(char * name) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    unsigned char v97 = *name; // 0x141dc
    if (v97 == 0) {
        // 0x14208
        return;
    }
    // 0x141e0
    __ctype_b_loc();
    __ctype_b_loc();
    int32_t v98 = (int32_t)name; // 0x14200
    int32_t v99 = v97; // 0x141fc
    // branch -> 0x141e8
    while (true) {
        // 0x141e8
        uint16_t v100; // 0x141e8
        if (((int32_t)v100 & 8) == 0) {
            // switch.early.test
            unsigned char v101; // 0x14200
            switch (v99) {
                default: {
                    // 0x1420c
                    return;
                }
                case 95: {
                    // 0x14200
                    if (v101 == 0) {
                        // break (via goto) -> 0x14208
                        goto lab_0x14208_25;
                    }
                    v98++;
                    v99 = v101;
                    // continue -> 0x141e8
                    continue;
                }
                case 46: {
                    // 0x14200
                    if (v101 == 0) {
                        // break (via goto) -> 0x14208
                        goto lab_0x14208_25;
                    }
                    v98++;
                    v99 = v101;
                    // continue -> 0x141e8
                    continue;
                }
                case 45: {
                  lab_0x14200:
                    // 0x14200
                    if (v101 == 0) {
                        // break (via goto) -> 0x14208
                        goto lab_0x14208_25;
                    }
                    v98++;
                    v99 = v101;
                    // continue -> 0x141e8
                    continue;
                }
            }
            while (true) {
                if (((int32_t)v100 & 8) != 0) {
                    goto lab_0x14200;
                }
                // switch.early.test
                int32_t v102; // 0x14200
                int32_t v103; // 0x14200
                switch (v99) {
                    default: {
                        // 0x1420c
                        return;
                    }
                    case 95: {
                        // 0x14200
                        v103 = v98 + 1;
                    }
                    case 46: {
                        // 0x14200
                        v103 = v98 + 1;
                    }
                    case 45: {
                      lab_0x14200_2:
                        // 0x14200
                        v103 = v98 + 1;
                        v102 = v101;
                        if (v101 == 0) {
                            // break (via goto) -> 0x14208
                            goto lab_0x14208_25;
                        }
                        v98 = v103;
                        v99 = v102;
                        // continue -> 0x141e8
                        continue;
                    }
                }
                while (true) {
                    if (((int32_t)v100 & 8) != 0) {
                        goto lab_0x14200_2;
                    }
                    // switch.early.test
                    switch (v99) {
                        default: {
                            // 0x1420c
                            return;
                        }
                        case 95: {
                            // 0x14200
                            v103 = v98 + 1;
                        }
                        case 46: {
                            // 0x14200
                            v103 = v98 + 1;
                        }
                        case 45: {
                          lab_0x14200_3:
                            // 0x14200
                            v103 = v98 + 1;
                            v102 = v101;
                            if (v101 == 0) {
                                // break (via goto) -> 0x14208
                                goto lab_0x14208_25;
                            }
                            v98 = v103;
                            v99 = v102;
                            // continue -> 0x141e8
                            continue;
                        }
                    }
                    while (true) {
                        if (((int32_t)v100 & 8) != 0) {
                            goto lab_0x14200_3;
                        }
                        // switch.early.test
                        switch (v99) {
                            default: {
                                // 0x1420c
                                return;
                            }
                            case 95: {
                                // 0x14200
                                v103 = v98 + 1;
                            }
                            case 46: {
                                // 0x14200
                                v103 = v98 + 1;
                            }
                            case 45: {
                              lab_0x14200_4:
                                // 0x14200
                                v103 = v98 + 1;
                                v102 = v101;
                                if (v101 == 0) {
                                    // break (via goto) -> 0x14208
                                    goto lab_0x14208_25;
                                }
                                v98 = v103;
                                v99 = v102;
                                // continue -> 0x141e8
                                continue;
                            }
                        }
                        while (true) {
                            if (((int32_t)v100 & 8) != 0) {
                                goto lab_0x14200_4;
                            }
                            // switch.early.test
                            switch (v99) {
                                default: {
                                    // 0x1420c
                                    return;
                                }
                                case 95: {
                                    // 0x14200
                                    v103 = v98 + 1;
                                }
                                case 46: {
                                    // 0x14200
                                    v103 = v98 + 1;
                                }
                                case 45: {
                                  lab_0x14200_5:
                                    // 0x14200
                                    v103 = v98 + 1;
                                    v102 = v101;
                                    if (v101 == 0) {
                                        // break (via goto) -> 0x14208
                                        goto lab_0x14208_25;
                                    }
                                    v98 = v103;
                                    v99 = v102;
                                    // continue -> 0x141e8
                                    continue;
                                }
                            }
                            while (true) {
                                if (((int32_t)v100 & 8) != 0) {
                                    goto lab_0x14200_5;
                                }
                                // switch.early.test
                                switch (v99) {
                                    default: {
                                        // 0x1420c
                                        return;
                                    }
                                    case 95: {
                                        // 0x14200
                                        v103 = v98 + 1;
                                    }
                                    case 46: {
                                        // 0x14200
                                        v103 = v98 + 1;
                                    }
                                    case 45: {
                                      lab_0x14200_6:
                                        // 0x14200
                                        v103 = v98 + 1;
                                        v102 = v101;
                                        if (v101 == 0) {
                                            // break (via goto) -> 0x14208
                                            goto lab_0x14208_25;
                                        }
                                        v98 = v103;
                                        v99 = v102;
                                        // continue -> 0x141e8
                                        continue;
                                    }
                                }
                                while (true) {
                                    if (((int32_t)v100 & 8) != 0) {
                                        goto lab_0x14200_6;
                                    }
                                    // switch.early.test
                                    switch (v99) {
                                        default: {
                                            // 0x1420c
                                            return;
                                        }
                                        case 95: {
                                            // 0x14200
                                            v103 = v98 + 1;
                                        }
                                        case 46: {
                                            // 0x14200
                                            v103 = v98 + 1;
                                        }
                                        case 45: {
                                          lab_0x14200_7:
                                            // 0x14200
                                            v103 = v98 + 1;
                                            v102 = v101;
                                            if (v101 == 0) {
                                                // break (via goto) -> 0x14208
                                                goto lab_0x14208_25;
                                            }
                                            v98 = v103;
                                            v99 = v102;
                                            // continue -> 0x141e8
                                            continue;
                                        }
                                    }
                                    while (true) {
                                        if (((int32_t)v100 & 8) != 0) {
                                            goto lab_0x14200_7;
                                        }
                                        // switch.early.test
                                        switch (v99) {
                                            default: {
                                                // 0x1420c
                                                return;
                                            }
                                            case 95: {
                                                // 0x14200
                                                v103 = v98 + 1;
                                            }
                                            case 46: {
                                                // 0x14200
                                                v103 = v98 + 1;
                                            }
                                            case 45: {
                                              lab_0x14200_8:
                                                // 0x14200
                                                v103 = v98 + 1;
                                                v102 = v101;
                                                if (v101 == 0) {
                                                    // break (via goto) -> 0x14208
                                                    goto lab_0x14208_25;
                                                }
                                                v98 = v103;
                                                v99 = v102;
                                                // continue -> 0x141e8
                                                continue;
                                            }
                                        }
                                        while (true) {
                                            if (((int32_t)v100 & 8) != 0) {
                                                goto lab_0x14200_8;
                                            }
                                            // switch.early.test
                                            switch (v99) {
                                                default: {
                                                    // 0x1420c
                                                    return;
                                                }
                                                case 95: {
                                                  lab_0x14200_24:
                                                    // 0x14200
                                                    v103 = v98 + 1;
                                                    v102 = v101;
                                                    if (v101 == 0) {
                                                        // break (via goto) -> 0x14208
                                                        goto lab_0x14208_25;
                                                    }
                                                    v98 = v103;
                                                    v99 = v102;
                                                    // continue -> 0x141e8
                                                    continue;
                                                }
                                                case 46: {
                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                }
                                                case 45: {
                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                }
                                            }
                                            while (true) {
                                                if (((int32_t)v100 & 8) != 0) {
                                                    goto lab_0x14200_24;
                                                }
                                                // switch.early.test
                                                switch (v99) {
                                                    default: {
                                                        // 0x1420c
                                                        return;
                                                    }
                                                    case 95: {
                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                    }
                                                    case 46: {
                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                    }
                                                    case 45: {
                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                    }
                                                }
                                                while (true) {
                                                    if (((int32_t)v100 & 8) != 0) {
                                                        goto lab_0x14200_24;
                                                    }
                                                    // switch.early.test
                                                    switch (v99) {
                                                        default: {
                                                            // 0x1420c
                                                            return;
                                                        }
                                                        case 95: {
                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                        }
                                                        case 46: {
                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                        }
                                                        case 45: {
                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                        }
                                                    }
                                                    while (true) {
                                                        if (((int32_t)v100 & 8) != 0) {
                                                            goto lab_0x14200_24;
                                                        }
                                                        // switch.early.test
                                                        switch (v99) {
                                                            default: {
                                                                // 0x1420c
                                                                return;
                                                            }
                                                            case 95: {
                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                            }
                                                            case 46: {
                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                            }
                                                            case 45: {
                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                            }
                                                        }
                                                        while (true) {
                                                            if (((int32_t)v100 & 8) != 0) {
                                                                goto lab_0x14200_24;
                                                            }
                                                            // switch.early.test
                                                            switch (v99) {
                                                                default: {
                                                                    // 0x1420c
                                                                    return;
                                                                }
                                                                case 95: {
                                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                                }
                                                                case 46: {
                                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                                }
                                                                case 45: {
                                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                                }
                                                            }
                                                            while (true) {
                                                                if (((int32_t)v100 & 8) != 0) {
                                                                    goto lab_0x14200_24;
                                                                }
                                                                // switch.early.test
                                                                switch (v99) {
                                                                    default: {
                                                                        // 0x1420c
                                                                        return;
                                                                    }
                                                                    case 95: {
                                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                                    }
                                                                    case 46: {
                                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                                    }
                                                                    case 45: {
                                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                                    }
                                                                }
                                                                while (true) {
                                                                    if (((int32_t)v100 & 8) != 0) {
                                                                        goto lab_0x14200_24;
                                                                    }
                                                                    // switch.early.test
                                                                    switch (v99) {
                                                                        default: {
                                                                            // 0x1420c
                                                                            return;
                                                                        }
                                                                        case 95: {
                                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                                        }
                                                                        case 46: {
                                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                                        }
                                                                        case 45: {
                                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                                        }
                                                                    }
                                                                    while (true) {
                                                                        if (((int32_t)v100 & 8) != 0) {
                                                                            goto lab_0x14200_24;
                                                                        }
                                                                        // switch.early.test
                                                                        switch (v99) {
                                                                            default: {
                                                                                // 0x1420c
                                                                                return;
                                                                            }
                                                                            case 95: {
                                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                                            }
                                                                            case 46: {
                                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                                            }
                                                                            case 45: {
                                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                                            }
                                                                        }
                                                                        while (true) {
                                                                            if (((int32_t)v100 & 8) != 0) {
                                                                                goto lab_0x14200_24;
                                                                            }
                                                                            // switch.early.test
                                                                            switch (v99) {
                                                                                default: {
                                                                                    // 0x1420c
                                                                                    return;
                                                                                }
                                                                                case 95: {
                                                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                }
                                                                                case 46: {
                                                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                }
                                                                                case 45: {
                                                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                }
                                                                            }
                                                                            while (true) {
                                                                                if (((int32_t)v100 & 8) != 0) {
                                                                                    goto lab_0x14200_24;
                                                                                }
                                                                                // switch.early.test
                                                                                switch (v99) {
                                                                                    default: {
                                                                                        // 0x1420c
                                                                                        return;
                                                                                    }
                                                                                    case 95: {
                                                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                    }
                                                                                    case 46: {
                                                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                    }
                                                                                    case 45: {
                                                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                    }
                                                                                }
                                                                                while (true) {
                                                                                    if (((int32_t)v100 & 8) != 0) {
                                                                                        goto lab_0x14200_24;
                                                                                    }
                                                                                    // switch.early.test
                                                                                    switch (v99) {
                                                                                        default: {
                                                                                            // 0x1420c
                                                                                            return;
                                                                                        }
                                                                                        case 95: {
                                                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                        }
                                                                                        case 46: {
                                                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                        }
                                                                                        case 45: {
                                                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                        }
                                                                                    }
                                                                                    while (true) {
                                                                                        if (((int32_t)v100 & 8) != 0) {
                                                                                            goto lab_0x14200_24;
                                                                                        }
                                                                                        // switch.early.test
                                                                                        switch (v99) {
                                                                                            default: {
                                                                                                // 0x1420c
                                                                                                return;
                                                                                            }
                                                                                            case 95: {
                                                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                            }
                                                                                            case 46: {
                                                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                            }
                                                                                            case 45: {
                                                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                            }
                                                                                        }
                                                                                        while (true) {
                                                                                            if (((int32_t)v100 & 8) != 0) {
                                                                                                goto lab_0x14200_24;
                                                                                            }
                                                                                            // switch.early.test
                                                                                            switch (v99) {
                                                                                                default: {
                                                                                                    // 0x1420c
                                                                                                    return;
                                                                                                }
                                                                                                case 95: {
                                                                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                }
                                                                                                case 46: {
                                                                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                }
                                                                                                case 45: {
                                                                                                    // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                }
                                                                                            }
                                                                                            while (true) {
                                                                                                if (((int32_t)v100 & 8) != 0) {
                                                                                                    goto lab_0x14200_24;
                                                                                                }
                                                                                                // switch.early.test
                                                                                                switch (v99) {
                                                                                                    default: {
                                                                                                        // 0x1420c
                                                                                                        return;
                                                                                                    }
                                                                                                    case 95: {
                                                                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                    }
                                                                                                    case 46: {
                                                                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                    }
                                                                                                    case 45: {
                                                                                                        // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                    }
                                                                                                }
                                                                                                while (true) {
                                                                                                    if (((int32_t)v100 & 8) != 0) {
                                                                                                        goto lab_0x14200_24;
                                                                                                    }
                                                                                                    // switch.early.test
                                                                                                    switch (v99) {
                                                                                                        default: {
                                                                                                            // 0x1420c
                                                                                                            return;
                                                                                                        }
                                                                                                        case 95: {
                                                                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                        }
                                                                                                        case 46: {
                                                                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                        }
                                                                                                        case 45: {
                                                                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                        }
                                                                                                    }
                                                                                                    while (true) {
                                                                                                        if (((int32_t)v100 & 8) != 0) {
                                                                                                            goto lab_0x14200_24;
                                                                                                        }
                                                                                                        // switch.early.test
                                                                                                        switch (v99) {
                                                                                                            default: {
                                                                                                                // 0x1420c
                                                                                                                return;
                                                                                                            }
                                                                                                            case 95: {
                                                                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                            }
                                                                                                            case 46: {
                                                                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                            }
                                                                                                            case 45: {
                                                                                                                // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                            }
                                                                                                        }
                                                                                                        while (true) {
                                                                                                            // Detected a possible infinite recursion (goto support failed); quitting...
                                                                                                        }
                                                                                                      lab_0x14208_25:
                                                                                                        // 0x14208
                                                                                                        return;
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

// Address range: 0x14220 - 0x1423d
int32_t function_14220(int32_t a1, int32_t a2) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x14220
    function_144d6(a1);
    return 0;
}

// Address range: 0x1423e - 0x144d5
int32_t function_1423e(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x1423e
    int32_t v97;
    ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t))v97)(1, a2, a3, a4, a5, a6, a7, a8, a9);
    function_1423e(1, a2, a3, a4, a5, a6, a7, a8, a9);
    return 0;
}

// Address range: 0x144d6 - 0x144e3
int32_t function_144d6(int32_t a1) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x23110
    int32_t v83; // 0x23114
    int32_t v84; // 0x23118
    int32_t v85; // 0x2311c
    int32_t v86; // 0x23120
    int32_t v87; // 0x23124
    int32_t v88; // 0x23128
    int32_t v89; // 0x8946
    int32_t v90; // 0xa6f2
    int32_t v91; // 0xdba0
    int32_t v92; // 0xf00b
    int32_t v93; // 0xf053
    int32_t v94; // 0xf207
    int32_t v95; // 0xfa6d
    // 0x144d6
    int32_t v96; // 0x2310c
    int32_t v97;
    ((int32_t (*)(int32_t, int32_t))(v96 & -2))(v97, v96);
    int32_t v98;
    int32_t v99;
    function_1423e(v97, v98, v99, v96, 0, 0, 0, 0, 0);
    return 0;
}

// Address range: 0x144e4 - 0x144fb
int32_t function_144e4(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x2310c
    int32_t v82; // 0x23110
    int32_t v83; // 0x23114
    int32_t v84; // 0x23118
    int32_t v85; // 0x2311c
    int32_t v86; // 0x23120
    int32_t v87; // 0x23124
    int32_t v88; // 0x23128
    int32_t v89; // 0x8946
    int32_t v90; // 0xa6f2
    int32_t v91; // 0xdba0
    int32_t v92; // 0xf00b
    int32_t v93; // 0xf053
    int32_t v94; // 0xf207
    int32_t v95; // 0xfa6d
    // 0x144e4
    int32_t result; // 0x23108
    ((int32_t (*)(int32_t))(result & -2))(result);
    int32_t v96;
    int32_t v97;
    int32_t v98;
    function_1423e(v96, v97, v98, result, 0, 0, 0, 0, 0);
    return result;
}

// Address range: 0x14592 - 0x145db
int32_t function_14592(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t str, int32_t a11) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    memset((char *)&a7, 0, 104);
    a7 = 18;
    int32_t v97; // 0x145a4
    if (v97 != 0) {
        // 0x145b2
        // branch -> 0x145bc
    }
    // 0x145bc
    printf("\n [EM]send UI");
    int32_t v98;
    return (int32_t)strncpy((char *)&str, (char *)(v98 + 12), 63);
}

// Address range: 0x145dc - 0x1469b
void function_145dc(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x145dc
    int32_t v97; // 0x145dc
    int32_t v98; // 0x145e0
    ((int32_t (*)(int32_t, int32_t))(v97 & -2))(v98, v97);
    int32_t v99;
    int32_t v100;
    int32_t v101;
    function_1423e(v98, v99, v97, v100, 0, 0, v101, 0, 0);
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_process_manager.c
// Address range: 0x146b0 - 0x146bb
// Line range:    90 - 93
struct PM_OBJ_TAG * get_process_mngr_obj(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x146b0
    return (struct PM_OBJ_TAG *)&mProcMngrObj;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_process_manager.c
// Address range: 0x14978 - 0x14987
// Line range:    95 - 98
int32_t get_pm_focus_fd(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    struct PM_OBJ_TAG * v66; // 0x2303c
    int32_t v67; // 0x23040
    int32_t v68; // 0x23044
    int32_t v69; // 0x23048
    int32_t v70; // 0x2304c
    struct TAG_Mutex_3 * v71; // 0x23058
    struct TAG_WaitCond_2 * v72; // 0x23070
    int32_t v73; // 0x230a0
    int32_t v74; // 0x230a4
    int32_t v75; // 0x230e0
    int32_t v76; // 0x230e4
    struct TAG_Mutex_3 * v77; // 0x230e8
    char * v78; // 0x23100
    int32_t v79; // 0x23104
    int32_t v80; // 0x23108
    int32_t v81; // 0x2310c
    int32_t v82; // 0x23110
    int32_t v83; // 0x23114
    int32_t v84; // 0x23118
    int32_t v85; // 0x2311c
    int32_t v86; // 0x23120
    int32_t v87; // 0x23124
    int32_t v88; // 0x23128
    int32_t v89; // 0x8946
    int32_t v90; // 0xa6f2
    int32_t v91; // 0xdba0
    int32_t v92; // 0xf00b
    int32_t v93; // 0xf053
    int32_t v94; // 0xf207
    int32_t v95; // 0xfa6d
    // 0x14978
    int32_t result; // 0x23038
    return result;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_process_manager.c
// Address range: 0x149ec - 0x14a4b
// Line range:    299 - 314
void parse_error(struct parse_state * state, char * fmt, ...) {
    struct __va_list_1 v1;
    char str[128];
    int32_t v2; // 0x101c1
    int32_t v3; // 0x111f1
    int32_t v4; // 0x12d09
    int32_t v5; // 0x13d01
    void (*v6)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v7; // 0x14b14
    int16_t * v8; // 0x14cde
    int32_t v9; // 0x157c5
    int32_t v10; // 0x1630f
    char * v11; // 0x16b14
    int32_t v12; // 0x21098
    int32_t v13; // 0x2109c
    int32_t v14; // 0x210a0
    int32_t v15; // 0x210a4
    int32_t * v16; // 0x211dc
    int32_t v17; // 0x213b8
    char * (**v18)(char *); // 0x213bc
    int32_t * v19; // 0x213c8
    int32_t * v20; // 0x213cc
    struct ApplicationManagerController ** v21; // 0x213d0
    int32_t v22; // 0x213d4
    char (*v23)[10]; // 0x213e0
    char * v24[2]; // 0x213e4
    char * (**v25)(char *); // 0x213e8
    char * v26; // 0x213ec
    int16_t * v27; // 0x213f0
    char * v28; // 0x213f2
    char * v29; // 0x213f4
    int32_t v30; // 0x213f8
    int32_t v31; // 0x21400
    int32_t v32; // 0x21404
    void (*v33)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v34)[128]; // 0x21418
    int32_t v35; // 0x2141c
    int32_t v36; // 0x21420
    char ** v37; // 0x21424
    int32_t v38; // 0x21428
    int32_t v39; // 0x21434
    int32_t v40; // 0x21438
    int32_t * v41; // 0x2143c
    int32_t v42; // 0x21440
    int32_t v43; // 0x21448
    int32_t v44; // 0x2144c
    int32_t v45; // 0x21450
    int32_t v46; // 0x21458
    int32_t v47; // 0x21460
    char * v48; // 0x21470
    int32_t v49; // 0x21498
    int32_t v50; // 0x214a4
    char * v51; // 0x215d8
    int32_t v52; // 0x217b4
    char * v53; // 0x21ae8
    char * v54; // 0x2292e
    int32_t v55; // 0x22f95
    int32_t v56; // 0x22f9c
    int32_t v57; // 0x22fa0
    int32_t v58; // 0x22fa4
    int32_t v59; // 0x22fb0
    struct TAG_Mutex_3 * v60; // 0x22fb8
    char * v61; // 0x22fd4
    int32_t v62; // 0x22fdc
    int32_t v63; // 0x2300c
    int32_t v64; // 0x2301c
    int32_t v65; // 0x23030
    int32_t v66; // 0x23034
    int32_t v67; // 0x23038
    struct PM_OBJ_TAG * v68; // 0x2303c
    int32_t v69; // 0x23040
    int32_t v70; // 0x23044
    int32_t v71; // 0x23048
    int32_t v72; // 0x2304c
    struct TAG_Mutex_3 * v73; // 0x23058
    struct TAG_WaitCond_2 * v74; // 0x23070
    int32_t v75; // 0x230a0
    int32_t v76; // 0x230a4
    int32_t v77; // 0x230e0
    int32_t v78; // 0x230e4
    struct TAG_Mutex_3 * v79; // 0x230e8
    char * v80; // 0x23100
    int32_t v81; // 0x23104
    int32_t v82; // 0x23108
    int32_t v83; // 0x2310c
    int32_t v84; // 0x23110
    int32_t v85; // 0x23114
    int32_t v86; // 0x23118
    int32_t v87; // 0x2311c
    int32_t v88; // 0x23120
    int32_t v89; // 0x23124
    int32_t v90; // 0x23128
    int32_t v91; // 0x8946
    int32_t v92; // 0xa6f2
    int32_t v93; // 0xdba0
    int32_t v94; // 0xf00b
    int32_t v95; // 0xf053
    int32_t v96; // 0xf207
    int32_t v97; // 0xfa6d
    int32_t v98;
    int32_t v99 = &v98; // 0x149fa_0
    int32_t v100; // 0x149f6
    int32_t v101; // 0x149fe
    snprintf(str, 128, "%s: %d: ", (char *)v101, v100);
    int32_t len = strlen(str); // 0x14a12
    v1.e0 = (char *)v99;
    vsnprintf((char *)(len + (int32_t)&str), 128 - len, fmt, v99);
    printf("%s", str);
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_process_manager.c
// Address range: 0x14a4c - 0x14a67
// Line range:    316 - 1101
void DUMP_service(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x14a4c
    get_process_mngr_obj();
    int32_t v97; // 0x14a58
    if ((int32_t)&mProcMngrObj == -88 || v97 == (int32_t)&mProcMngrObj + 88) {
        // 0x14a64
        return;
    }
    int32_t v98; // 0x14a5e
    while (v98 != (int32_t)&mProcMngrObj + 88) {
        // 0x14a5e
        // continue -> 0x14a5e
    }
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_process_manager.c
// Address range: 0x14a68 - 0x14aef
// Line range:    361 - 383
char * read_file(char * fn, int32_t * _sz) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    int32_t fd = open(fn, O_RDONLY);
    if (fd < 0) {
        // 0x14ad0
        // branch -> 0x14a9a
    } else {
        int32_t nbyte = lseek(fd, 0, SEEK_END); // 0x14a7c
        if (nbyte >= 0) {
            int32_t v97 = lseek(fd, 0, SEEK_SET); // 0x14a8a
            if ((char)v97 == 0) {
                char * mem = malloc(nbyte + 2); // 0x14aa2
                int32_t v98 = (int32_t)mem; // R4
                if (mem != NULL) {
                    int32_t v99 = read(fd, mem, nbyte); // 0x14ab2
                    close(fd);
                    if (v99 != nbyte) {
                        // 0x14abe
                        free((char *)v98);
                        return (char *)v97;
                    }
                    // 0x14ad4
                    if ((int32_t)_sz != 0) {
                        // 0x14aea
                        // branch -> 0x14a9a
                    }
                    // 0x14a9a
                    return (char *)v98;
                }
            }
        }
        // 0x14a92
        close(fd);
        // branch -> 0x14a9a
    }
    // 0x14a9a
    return (char *)0;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_process_manager.c
// Address range: 0x14af0 - 0x14ccb
// Line range:    393 - 491
int32_t next_token(struct parse_state * state) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int16_t * v6; // 0x14cde
    int32_t v7; // 0x157c5
    int32_t v8; // 0x1630f
    char * v9; // 0x16b14
    int32_t v10; // 0x21098
    int32_t v11; // 0x2109c
    int32_t v12; // 0x210a0
    int32_t v13; // 0x210a4
    int32_t * v14; // 0x211dc
    int32_t v15; // 0x213b8
    char * (**v16)(char *); // 0x213bc
    int32_t * v17; // 0x213c8
    int32_t * v18; // 0x213cc
    struct ApplicationManagerController ** v19; // 0x213d0
    int32_t v20; // 0x213d4
    char (*v21)[10]; // 0x213e0
    char * v22[2]; // 0x213e4
    char * (**v23)(char *); // 0x213e8
    char * v24; // 0x213ec
    int16_t * v25; // 0x213f0
    char * v26; // 0x213f2
    char * v27; // 0x213f4
    int32_t v28; // 0x213f8
    int32_t v29; // 0x21400
    int32_t v30; // 0x21404
    void (*v31)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v32)[128]; // 0x21418
    int32_t v33; // 0x2141c
    int32_t v34; // 0x21420
    char ** v35; // 0x21424
    int32_t v36; // 0x21428
    int32_t v37; // 0x21434
    int32_t v38; // 0x21438
    int32_t * v39; // 0x2143c
    int32_t v40; // 0x21440
    int32_t v41; // 0x21448
    int32_t v42; // 0x2144c
    int32_t v43; // 0x21450
    int32_t v44; // 0x21458
    int32_t v45; // 0x21460
    char * v46; // 0x21470
    int32_t v47; // 0x21498
    int32_t v48; // 0x214a4
    char * v49; // 0x215d8
    int32_t v50; // 0x217b4
    char * v51; // 0x21ae8
    char * v52; // 0x2292e
    int32_t v53; // 0x22f95
    int32_t v54; // 0x22f9c
    int32_t v55; // 0x22fa0
    int32_t v56; // 0x22fa4
    int32_t v57; // 0x22fb0
    struct TAG_Mutex_3 * v58; // 0x22fb8
    char * v59; // 0x22fd4
    int32_t v60; // 0x22fdc
    int32_t v61; // 0x2300c
    int32_t v62; // 0x2301c
    int32_t v63; // 0x23030
    int32_t v64; // 0x23034
    int32_t v65; // 0x23038
    struct PM_OBJ_TAG * v66; // 0x2303c
    int32_t v67; // 0x23040
    int32_t v68; // 0x23044
    int32_t v69; // 0x23048
    int32_t v70; // 0x2304c
    struct TAG_Mutex_3 * v71; // 0x23058
    struct TAG_WaitCond_2 * v72; // 0x23070
    int32_t v73; // 0x230a0
    int32_t v74; // 0x230a4
    int32_t v75; // 0x230e0
    int32_t v76; // 0x230e4
    struct TAG_Mutex_3 * v77; // 0x230e8
    char * v78; // 0x23100
    int32_t v79; // 0x23104
    int32_t v80; // 0x23108
    int32_t v81; // 0x2310c
    int32_t v82; // 0x23110
    int32_t v83; // 0x23114
    int32_t v84; // 0x23118
    int32_t v85; // 0x2311c
    int32_t v86; // 0x23120
    int32_t v87; // 0x23124
    int32_t v88; // 0x23128
    int32_t v89; // 0x8946
    int32_t v90; // 0xa6f2
    int32_t v91; // 0xdba0
    int32_t v92; // 0xf00b
    int32_t v93; // 0xf053
    int32_t v94; // 0xf207
    int32_t v95; // 0xfa6d
    // 0x14af0
    int32_t result; // 0x14af2
    if (result != 0) {
        // 0x14ba4
        // branch -> 0x14ba8
        // 0x14ba8
        return result;
    }
    // 0x14afe
    unsigned char v96; // 0x14b02
    if (v96 > 35) {
        int32_t v97 = *(int32_t *)state; // 0x14bcc
        int32_t v98 = v97; // R4
        unsigned char v99; // 0x14bce
        if (v99 == 13) {
            // 0x14c4a
            // branch -> 0x14be8
            // 0x14be8
            // branch -> 0x14ba8
            // 0x14ba8
            return 1;
        }
        int32_t v100 = v99; // 0x14cbc
        // branch -> 0x14bdc
        while (true) {
            // 0x14bdc
            if (v99 > 14) {
                // 0x14c04
                int32_t v101;
                switch (v100) {
                    case 34: {
                        int32_t v102 = v97 + 2;
                        unsigned char v103; // 0x14c4010
                        if (v103 != 0) {
                            int32_t v104 = v103; // 0x14c52
                            while (true) {
                                // 0x14c4e
                                if (v104 == 34) {
                                    // 0x14c58
                                    unsigned char v105; // 0x14c5a
                                    v101 = v105;
                                    // branch -> 0x14bd8
                                  lab_0x14bd8:
                                    // 0x14bd8
                                    if (v101 == 13) {
                                        // 0x14c4a
                                        // branch -> 0x14be8
                                        // 0x14be8
                                        // branch -> 0x14ba8
                                        // 0x14ba8
                                        return 1;
                                    }
                                  lab_0x14bdc:
                                    // 0x14bdc
                                    // branch -> 0x14bdc
                                    break;
                                } else {
                                    // 0x14c52
                                    v98++;
                                    v102++;
                                    unsigned char v106; // 0x14c40
                                    if (v106 == 0) {
                                        // break (via goto) -> 0x14c46
                                        goto lab_0x14c46;
                                    }
                                    v104 = v106;
                                    // continue -> 0x14c4e
                                    continue;
                                }
                            }
                            // 0x14c46
                            // branch -> 0x14ba8
                            // 0x14ba8
                            return result;
                        }
                      lab_0x14c46:
                        // 0x14c46
                        // branch -> 0x14ba8
                        // 0x14ba8
                        return result;
                    }
                    case 92: {
                        // 0x14c1a
                        char v107; // 0x14c1a
                        if (v107 == 92) {
                            // 0x14cbc
                            unsigned char v108; // 0x14cc0
                            v101 = v108;
                            // branch -> 0x14bd8
                            goto lab_0x14bd8;
                        }
                        break;
                    }
                    case 32: {
                        // 0x14c4a
                        // branch -> 0x14be8
                        // 0x14be8
                        // branch -> 0x14ba8
                        // 0x14ba8
                        return 1;
                    }
                }
                // 0x14c10
                // branch -> 0x14bd8
              lab_0x14bd8_2:;
                // 0x14bd8
                unsigned char v109; // 0x14c14
                if ((int32_t)v109 != 13) {
                    goto lab_0x14bdc;
                }
                // 0x14c4a
                // branch -> 0x14be8
                // 0x14be8
                // branch -> 0x14ba8
                // 0x14ba8
                return 1;
            }
            // 0x14bde
            switch (v100) {
                case 9: {
                    // 0x14c4a
                    // branch -> 0x14be8
                    // 0x14be8
                    // branch -> 0x14ba8
                    // 0x14ba8
                    return 1;
                }
                case 10: {
                    // 0x14c34
                    // branch -> 0x14be8
                }
                case 0: {
                    // 0x14be8
                    // branch -> 0x14ba8
                    // 0x14ba8
                    return 1;
                }
            }
            // 0x14c10
            // branch -> 0x14bd8
            goto lab_0x14bd8_2;
        }
    } else {
        // 0x14b08
        int32_t v110; // 0x14b14
        int32_t v111; // 0x14b0a
        ((int32_t (*)())(v111 + (int32_t)&v110 & -2))();
        // branch -> 0x14ba4
        // 0x14ba4
        // branch -> 0x14ba8
    }
    // 0x14ba8
    return result;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_process_manager.c
// Address range: 0x14ccc - 0x1511f
// Line range:    538 - 611
int32_t lookup_keyword(char * s) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x14ccc
    if ((int32_t)*s <= 119) {
        // 0x14cda
        uint16_t v97; // 0x14cda
        ((int32_t (*)())(2 * (int32_t)v97 + 0x14cde))();
        // branch -> 0x14d10
    }
    // 0x14d10
    return 0;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_process_manager.c
// Address range: 0x15300 - 0x15337
// Line range:    1114 - 1130
struct service_1 * service_find_by_name(char * name) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x15300
    get_process_mngr_obj();
    if ((int32_t)&mProcMngrObj == -88) {
        // 0x15332
        // branch -> 0x15328
        // 0x15328
        return (struct service_1 *)((int32_t)&mProcMngrObj + 88);
    }
    // 0x1530e
    int32_t v97; // 0x1530e
    if (v97 == (int32_t)&mProcMngrObj + 88) {
        // 0x1532c
        return NULL;
    }
    int32_t v98 = v97; // R4
    while (true) {
        int32_t v99 = v98;
        int32_t str; // 0x1531c
        if (strcmp((char *)str, (char *)(int32_t)name) != 0) {
            // 0x15316
            int32_t v100; // 0x15316
            v98 = v100;
            if ((int32_t)&mProcMngrObj + 88 == v100) {
                // break -> 0x1532c
                break;
            }
            // continue -> 0x1531c
            continue;
        }
        // 0x15328
        return (struct service_1 *)v99;
    }
    // 0x1532c
    return NULL;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_process_manager.c
// Address range: 0x15338 - 0x15463
// Line range:    511 - 1035
void parse_new_section(struct parse_state * state, int32_t kw, int32_t nargs, char ** args) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    int32_t v10; // 0x21098
    int32_t v11; // 0x2109c
    int32_t v12; // 0x210a0
    int32_t v13; // 0x210a4
    int32_t * v14; // 0x211dc
    int32_t v15; // 0x213b8
    char * (**v16)(char *); // 0x213bc
    int32_t * v17; // 0x213c8
    int32_t * v18; // 0x213cc
    struct ApplicationManagerController ** v19; // 0x213d0
    int32_t v20; // 0x213d4
    char (*v21)[10]; // 0x213e0
    char * v22[2]; // 0x213e4
    char * (**v23)(char *); // 0x213e8
    char * v24; // 0x213ec
    int16_t * v25; // 0x213f0
    char * v26; // 0x213f2
    char * v27; // 0x213f4
    int32_t v28; // 0x213f8
    int32_t v29; // 0x21400
    int32_t v30; // 0x21404
    void (*v31)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v32)[128]; // 0x21418
    int32_t v33; // 0x2141c
    int32_t v34; // 0x21420
    char ** v35; // 0x21424
    int32_t v36; // 0x21428
    int32_t v37; // 0x21434
    int32_t v38; // 0x21438
    int32_t * v39; // 0x2143c
    int32_t v40; // 0x21440
    int32_t v41; // 0x21448
    int32_t v42; // 0x2144c
    int32_t v43; // 0x21450
    int32_t v44; // 0x21458
    int32_t v45; // 0x21460
    char * v46; // 0x21470
    int32_t v47; // 0x21498
    int32_t v48; // 0x214a4
    char * v49; // 0x215d8
    int32_t v50; // 0x217b4
    char * v51; // 0x21ae8
    char * v52; // 0x2292e
    int32_t v53; // 0x22f95
    int32_t v54; // 0x22f9c
    int32_t v55; // 0x22fa0
    int32_t v56; // 0x22fa4
    int32_t v57; // 0x22fb0
    struct TAG_Mutex_3 * v58; // 0x22fb8
    char * v59; // 0x22fd4
    int32_t v60; // 0x22fdc
    int32_t v61; // 0x2300c
    int32_t v62; // 0x2301c
    int32_t v63; // 0x23030
    int32_t v64; // 0x23034
    int32_t v65; // 0x23038
    struct PM_OBJ_TAG * v66; // 0x2303c
    int32_t v67; // 0x23040
    int32_t v68; // 0x23044
    int32_t v69; // 0x23048
    int32_t v70; // 0x2304c
    struct TAG_Mutex_3 * v71; // 0x23058
    struct TAG_WaitCond_2 * v72; // 0x23070
    int32_t v73; // 0x230a0
    int32_t v74; // 0x230a4
    int32_t v75; // 0x230e0
    int32_t v76; // 0x230e4
    struct TAG_Mutex_3 * v77; // 0x230e8
    char * v78; // 0x23100
    int32_t v79; // 0x23104
    int32_t v80; // 0x23108
    int32_t v81; // 0x2310c
    int32_t v82; // 0x23110
    int32_t v83; // 0x23114
    int32_t v84; // 0x23118
    int32_t v85; // 0x2311c
    int32_t v86; // 0x23120
    int32_t v87; // 0x23124
    int32_t v88; // 0x23128
    int32_t v89; // 0x8946
    int32_t v90; // 0xa6f2
    int32_t v91; // 0xdba0
    int32_t v92; // 0xf00b
    int32_t v93; // 0xf053
    int32_t v94; // 0xf207
    int32_t v95; // 0xfa6d
    int32_t v96 = (int32_t)args;
    int32_t v97 = nargs;
    int32_t v98 = (int32_t)state;
    int32_t v99 = *(int32_t *)args; // 0x15348
    int32_t v100;
    int32_t v101;
    int32_t v102;
    if (nargs < 2) {
        v100 = v99;
      lab_0x15402:
        // 0x15402
        v102 = v100;
        char * v103; // 0x16b14
        v101 = (int32_t)&v103;
        // branch -> 0x15350
    } else {
        // 0x1534e
        v102 = v99;
        int32_t v104; // 0x1534e
        v101 = v104;
        // branch -> 0x15350
    }
    // 0x15350
    printf("[ %s %s ]\n", (char *)v102, (char *)v101);
    if (kw == 28) {
        // 0x15368
        if (v97 < 3) {
            // 0x15428
            parse_error((struct parse_state *)v98, (char *)0x18960);
            // branch -> 0x15414
        } else {
            // 0x1536c
            int32_t str; // 0x1536c
            if (strlen((char *)str) <= 16) {
                // 0x1537a
                valid_name((char *)str);
                if (str != 0) {
                    struct service_1 * v105 = service_find_by_name((char *)str); // 0x15386
                    if (v105 != NULL) {
                        // 0x15408
                        parse_error((struct parse_state *)v98, "ignored duplicate definition of service '%s'\n");
                        // branch -> 0x15414
                        // 0x15414
                        // branch -> 0x1535e
                        // 0x1535e
                        return;
                    }
                    int32_t v106 = v97; // 0x15390
                    int32_t size = 4 * v106 + 148; // 0x15396
                    char * mem = calloc(1, size); // 0x153a0
                    kw = (int32_t)mem;
                    if (mem == NULL) {
                        // 0x15434
                        parse_error((struct parse_state *)v98, "out of memory\n");
                        // branch -> 0x15414
                        // 0x15414
                        // branch -> 0x1535e
                    } else {
                        // 0x153aa
                        memset(mem, (int32_t)v105, size);
                        memcpy((char *)(kw + 152), (char *)(v96 + 8), 4 * (v106 - 2));
                        get_process_mngr_obj();
                        int32_t v107 = kw; // 0x153ee
                        int32_t v108; // 0x153f0
                        ((int32_t (*)(int32_t, int32_t, int32_t))(v108 & -2))((int32_t)&mProcMngrObj, v107, v108);
                        int32_t v109;
                        v96 = v109;
                        int32_t v110;
                        v97 = v110;
                        int32_t v111;
                        v98 = v111;
                        int32_t v112;
                        kw = v112;
                        int32_t v113;
                        int32_t v114;
                        ((int32_t (*)(int32_t))v114)(v113);
                        v100 = v107;
                        // branch -> 0x15402
                        goto lab_0x15402;
                    }
                    // 0x1535e
                    return;
                }
            }
            // 0x1541a
            parse_error((struct parse_state *)v98, (char *)0x1898c);
            // branch -> 0x15414
        }
        // 0x15414
        // branch -> 0x1535e
    }
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_process_manager.c
// Address range: 0x15464 - 0x15503
// Line range:    626 - 651
void parse_config(char * fn, char * s) {
    char * v1[64];
    int32_t v2; // 0x101c1
    int32_t v3; // 0x111f1
    int32_t v4; // 0x12d09
    int32_t v5; // 0x13d01
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    struct parse_state v97;
    int32_t v98 = 0;
    v97.e6 = fn;
    v97.e0 = s;
    void (*v99)(struct parse_state *, int32_t, char **); // 0x13fed
    v97.e5 = (void (*)(struct parse_state *, int32_t, char **))&v99;
    int32_t v100 = (int32_t)&v97; // 0x15480_0
    // branch -> 0x15480
  lab_0x15480_5:;
    int32_t v101; // 0x15496_0
    int32_t v102;
    int32_t v103; // 0x154a0
    while (true) {
      lab_0x15480_4:
        // 0x15480
        switch (next_token(&v97)) {
            case 1: {
              lab_0x154a0:
                // 0x154a0
                v103 = v98;
                if (v103 == 63 || v103 < 63 ^ ((v103 - 65 ^ v103) & v103 + 0x7fffffbf) < 0) {
                    // break (via goto) -> 0x154a4
                    goto lab_0x154a4_2;
                }
                // continue -> 0x15480
                continue;
            }
            case 2: {
                // 0x154b0
                if (v98 != 0) {
                    // break (via goto) -> 0x154b4
                    goto lab_0x154b4_2;
                }
                // continue -> 0x15480
                continue;
            }
            case 0: {
                // 0x15492
                v101 = (int32_t)v97.e5;
                ((int32_t (*)(int32_t, int32_t, int32_t, int32_t))(v101 & -2))(v100, 0, 0, v101);
                v98 = v102;
                int32_t v104;
                ((int32_t (*)())v104)();
                // branch -> 0x154a0
                goto lab_0x154a0;
                break;
            }
            default: {
                goto lab_0x15480_4;
            }
        }
    }
  lab_0x154b4_2:
    // 0x154b4
    lookup_keyword(v1[0]);
    unsigned char v105; // 0x154ce
    if (v105 % 2 == 0) {
      lab_0x154ea:;
        int32_t v106 = v98; // 0x154ea
        int32_t v107 = (int32_t)v97.e5; // 0x154ec_0
        v98 = 0;
        ((int32_t (*)(int32_t, int32_t, int32_t))(v107 & -2))(v100, v106, (int32_t)&v1);
        // branch -> 0x15480
        goto lab_0x15480_4;
    } else {
      lab_0x154d6:;
        int32_t v108 = (int32_t)v97.e5; // 0x154d6_0
        ((int32_t (*)(int32_t))(v108 & -2))(v108);
        int32_t v109;
        int32_t v110;
        parse_new_section((struct parse_state *)&v110, 0, v98, (char **)&v109);
        v98 = 0;
        // branch -> 0x15480
        goto lab_0x15480_4;
    }
    while (true) {
        int32_t v111 = next_token(&v97); // 0x15482
        switch (v111) {
            case 1: {
              lab_0x154a0_2:
                // 0x154a0
                v103 = v98;
                if (v103 == 63 || v103 < 63 ^ ((v103 - 65 ^ v103) & v103 + 0x7fffffbf) < 0) {
                    // break (via goto) -> 0x154a4
                    goto lab_0x154a4_2;
                }
                // continue -> 0x15480
                continue;
            }
            case 2: {
                int32_t v112 = v98; // 0x154b0
                if (v112 != 0) {
                    // break (via goto) -> 0x154b4
                    goto lab_0x154b4_2;
                }
                // continue -> 0x15480
                continue;
            }
            case 0: {
                void (*v113)(struct parse_state *, int32_t, char **) = v97.e5; // 0x15496
                v101 = (int32_t)v113;
                ((int32_t (*)(int32_t, int32_t, int32_t, int32_t))(v101 & -2))(v100, 0, 0, v101);
                v98 = v102;
                int32_t (*v114)();
                v114();
                // branch -> 0x154a0
                goto lab_0x154a0_2;
                break;
            }
            default: {
                goto lab_0x15480_4;
            }
        }
    }
    char * v115 = v1[0]; // 0x154b4
    lookup_keyword(v115);
    unsigned char v116 = v105 % 2;
    if (v116 == 0) {
        goto lab_0x154ea;
    }
    goto lab_0x154d6;
  lab_0x154a4_2:
    // 0x154a4
    v98++;
    // branch -> 0x15480
    goto lab_0x15480_5;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_process_manager.c
// Address range: 0x15504 - 0x15513
// Line range:    288 - 297
int32_t parse_config_file(char * fn) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x15504
    read_file(fn, NULL);
    read_file(fn, NULL);
    return (int32_t)fn;
}

// Address range: 0x15514 - 0x15527
void function_15514(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x15514
    int32_t v97;
    int32_t (*v98)(int32_t) = (int32_t (*)(int32_t))v97;
    int32_t v99;
    int32_t v100;
    parse_config((char *)v99, (char *)v100);
    DUMP_service();
    v98(0);
    v98(-1);
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_process_manager.c
// Address range: 0x15528 - 0x1555b
// Line range:    1133 - 1149
struct service_1 * service_find_by_pid(int32_t pid) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    get_process_mngr_obj();
    if ((int32_t)&mProcMngrObj == -88) {
        // 0x15556
        return (struct service_1 *)((int32_t)&mProcMngrObj + 88);
    }
    // 0x15536
    int32_t v97; // 0x15536
    if (v97 == (int32_t)&mProcMngrObj + 88) {
        // 0x15550
        // branch -> 0x15552
        // 0x15552
        return NULL;
    }
    // 0x1553c
    int32_t v98; // 0x1553c
    if (v98 == pid) {
        // 0x15554
        return (struct service_1 *)v97;
    }
    int32_t v99; // 0x1554a
    while (true) {
        // 0x1554a
        if (v99 != (int32_t)&mProcMngrObj + 88) {
            // 0x15544
            int32_t v100; // 0x15544
            if (v100 == pid) {
                // break -> 0x15552
                break;
            }
            // continue -> 0x1554a
            continue;
        }
        // 0x15550
        // branch -> 0x15552
        // 0x15552
        return NULL;
    }
    // 0x15552
    // branch -> 0x15552
    // 0x15552
    return (struct service_1 *)v99;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_process_manager.c
// Address range: 0x1555c - 0x1557b
// Line range:    1155 - 1163
void service_for_each(void (*func)(struct service_1 *)) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x1555c
    get_process_mngr_obj();
    int32_t v97; // 0x1556a
    if ((int32_t)&mProcMngrObj == -88 || v97 == (int32_t)&mProcMngrObj + 88) {
        // 0x1557a
        return;
    }
    ((int32_t (*)(int32_t))((int32_t)func & -2))(v97);
    int32_t v98; // 0x15574
    while ((int32_t)&mProcMngrObj + 88 != v98) {
        // 0x15570
        ((int32_t (*)(int32_t))((int32_t)func & -2))(v98);
        // continue -> 0x15570
    }
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_process_manager.c
// Address range: 0x155ac - 0x155c7
// Line range:    1217 - 1231
void service_stop(struct service_1 * svc) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    int32_t * v97 = (int32_t *)((int32_t)svc + 48); // 0x155ac_1
    *v97 = *v97 & -14 | 1;
    int32_t v98; // 0x155ae
    if (v98 == 0) {
        // 0x155bc
        return;
    }
    // 0x155be
    kill(-v98, SIGTERM);
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_process_manager.c
// Address range: 0x15624 - 0x15663
// Line range:    952 - 966
int32_t release_process_by_pid(int32_t pid) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    struct service_1 * v97 = service_find_by_pid(pid); // 0x15628
    int32_t result = (int32_t)v97; // R6
    if (v97 != NULL) {
        // 0x15630
        int32_t v98; // 0x15630
        result = v98;
        service_stop(v97);
        // branch -> 0x15636
    }
    struct service_1 * v99 = service_find_by_pid(pid); // 0x15638
    if (v99 != NULL) {
        // 0x1563e
        *(int32_t *)((int32_t)v99 + 4) = 0x200200;
        *(int32_t *)v99 = 0x100100;
        free((char *)v99);
        // branch -> 0x1565e
    }
    // 0x1565e
    return result;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_process_manager.c
// Address range: 0x15664 - 0x15667
// Line range:    2466 - 2468
int32_t appmngr_pm_process_rm_pid(int32_t pid) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x15664
    return release_process_by_pid(pid);
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_process_manager.c
// Address range: 0x15ac4 - 0x15af7
// Line range:    1682 - 1692
int32_t appmngr_pm_init_rc(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x1630f
    char * v9; // 0x16b14
    int32_t v10; // 0x21098
    int32_t v11; // 0x2109c
    int32_t v12; // 0x210a0
    int32_t v13; // 0x210a4
    int32_t * v14; // 0x211dc
    int32_t v15; // 0x213b8
    char * (**v16)(char *); // 0x213bc
    int32_t * v17; // 0x213c8
    int32_t * v18; // 0x213cc
    struct ApplicationManagerController ** v19; // 0x213d0
    int32_t v20; // 0x213d4
    char (*v21)[10]; // 0x213e0
    char * v22[2]; // 0x213e4
    char * (**v23)(char *); // 0x213e8
    char * v24; // 0x213ec
    int16_t * v25; // 0x213f0
    char * v26; // 0x213f2
    char * v27; // 0x213f4
    int32_t v28; // 0x213f8
    int32_t v29; // 0x21400
    int32_t v30; // 0x21404
    void (*v31)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v32)[128]; // 0x21418
    int32_t v33; // 0x2141c
    int32_t v34; // 0x21420
    char ** v35; // 0x21424
    int32_t v36; // 0x21428
    int32_t v37; // 0x21434
    int32_t v38; // 0x21438
    int32_t * v39; // 0x2143c
    int32_t v40; // 0x21440
    int32_t v41; // 0x21448
    int32_t v42; // 0x2144c
    int32_t v43; // 0x21450
    int32_t v44; // 0x21458
    int32_t v45; // 0x21460
    char * v46; // 0x21470
    int32_t v47; // 0x21498
    int32_t v48; // 0x214a4
    char * v49; // 0x215d8
    int32_t v50; // 0x217b4
    char * v51; // 0x21ae8
    char * v52; // 0x2292e
    int32_t v53; // 0x22f95
    int32_t v54; // 0x22f9c
    int32_t v55; // 0x22fa0
    int32_t v56; // 0x22fa4
    int32_t v57; // 0x22fb0
    struct TAG_Mutex_3 * v58; // 0x22fb8
    char * v59; // 0x22fd4
    int32_t v60; // 0x22fdc
    int32_t v61; // 0x2300c
    int32_t v62; // 0x2301c
    int32_t v63; // 0x23030
    int32_t v64; // 0x23034
    int32_t v65; // 0x23038
    struct PM_OBJ_TAG * v66; // 0x2303c
    int32_t v67; // 0x23040
    int32_t v68; // 0x23044
    int32_t v69; // 0x23048
    int32_t v70; // 0x2304c
    struct TAG_Mutex_3 * v71; // 0x23058
    struct TAG_WaitCond_2 * v72; // 0x23070
    int32_t v73; // 0x230a0
    int32_t v74; // 0x230a4
    int32_t v75; // 0x230e0
    int32_t v76; // 0x230e4
    struct TAG_Mutex_3 * v77; // 0x230e8
    char * v78; // 0x23100
    int32_t v79; // 0x23104
    int32_t v80; // 0x23108
    int32_t v81; // 0x2310c
    int32_t v82; // 0x23110
    int32_t v83; // 0x23114
    int32_t v84; // 0x23118
    int32_t v85; // 0x2311c
    int32_t v86; // 0x23120
    int32_t v87; // 0x23124
    int32_t v88; // 0x23128
    int32_t v89; // 0x8946
    int32_t v90; // 0xa6f2
    int32_t v91; // 0xdba0
    int32_t v92; // 0xf00b
    int32_t v93; // 0xf053
    int32_t v94; // 0xf207
    int32_t v95; // 0xfa6d
    int32_t result = parse_config_file((char *)0x18a0c); // 0x15aca
    if (result == -1) {
        // 0x15ae0
        printf((char *)0x18a20);
        return result;
    }
    // 0x15ad4
    int32_t v96; // 0x157c5
    service_for_each((void (*)(struct service_1 *))&v96);
    return 0;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_process_manager.c
// Address range: 0x15af8 - 0x15b0b
// Line range:    1700 - 1708
int32_t appmngr_pm_init_ini(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x15af8
    ini_parser_create((char *)0x18a34);
    return 0;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_process_manager.c
// Address range: 0x15b0c - 0x15bdf
// Line range:    1710 - 1802
int32_t appmngr_pm_install_focus(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x15b0c
    get_process_mngr_obj();
    int32_t v97; // 0x15b1a
    if (v97 == 0) {
        // 0x15bd8
        return -1;
    }
    int32_t v98 = (int32_t)&mProcMngrObj + 88; // R7
    int32_t v99 = 0; // R6
    int32_t v100; // 0x15b22
    if (v98 == v100) {
        // 0x15bd8
        return -1;
    }
    int32_t v101 = v99;
    // branch -> 0x15b5c
    while (true) {
        // 0x15b5c
        int32_t v102; // 0x15b5c
        if (0x2000000 * v102 < 0) {
            // 0x15b3a
            if (v99 == 0) {
                // 0x15b3e
                v99 = 1;
                v101++;
                // branch -> 0x15b56
            } else {
                // 0x15bd4
                v99 = 1;
                // branch -> 0x15b56
            }
          lab_0x15b56_2:;
            // 0x15b56
            int32_t v103; // 0x15b56
            if (v98 == v103) {
                // break -> 0x15b56
                break;
            }
            // continue -> 0x15b5c
            continue;
        } else {
            // 0x15b62
            if (0x1000000 * v102 > 0) {
                goto lab_0x15b56_2;
            }
            // 0x15b66
            v101++;
            if (0x20000000 * v102 >= 0) {
                goto lab_0x15b56_2;
            }
            char * mem = malloc(16); // 0x15b74
            if (mem != NULL) {
                // 0x15b7e
                int32_t v104; // 0x15b7e
                *(int32_t *)mem = v104;
                // branch -> 0x15b90
            }
            // 0x15b90
            int32_t v105; // 0x15b92
            v101 = v105;
            int32_t v106; // 0x15b90
            if (v98 == v106) {
                // break -> 0x15b9a
                break;
            }
            // continue -> 0x15b5c
            continue;
        }
    }
    // 0x15b56
    // branch -> 0x15b9a
    // 0x15b9a
    if (v101 == 1 || v101 < 1 ^ ((v101 - 3 ^ v101) & v101 + 0x7ffffffd) < 0) {
        // 0x15bc6
        return 0;
    }
    char * mem2 = malloc(16); // 0x15ba0
    if (mem2 != NULL) {
        // 0x15ba6
        int32_t v107; // 0x15ba8
        *(int32_t *)mem2 = v107;
        // branch -> 0x15bc6
    }
    // 0x15bc6
    return 0;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_process_manager.c
// Address range: 0x15be0 - 0x15bf7
// Line range:    1807 - 1827
int32_t appmngr_dynamic_adjust_interactive_list(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x15be0
    get_process_mngr_obj();
    return 0;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_process_manager.c
// Address range: 0x15bf8 - 0x15c37
// Line range:    1830 - 1856
int32_t appmngr_pm_check_focus_process(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23038
    int32_t v66; // 0x23040
    int32_t v67; // 0x23044
    int32_t v68; // 0x23048
    int32_t v69; // 0x2304c
    struct TAG_Mutex_3 * v70; // 0x23058
    struct TAG_WaitCond_2 * v71; // 0x23070
    int32_t v72; // 0x230a0
    int32_t v73; // 0x230a4
    int32_t v74; // 0x230e0
    int32_t v75; // 0x230e4
    struct TAG_Mutex_3 * v76; // 0x230e8
    char * v77; // 0x23100
    int32_t v78; // 0x23104
    int32_t v79; // 0x23108
    int32_t v80; // 0x2310c
    int32_t v81; // 0x23110
    int32_t v82; // 0x23114
    int32_t v83; // 0x23118
    int32_t v84; // 0x2311c
    int32_t v85; // 0x23120
    int32_t v86; // 0x23124
    int32_t v87; // 0x23128
    int32_t v88; // 0x8946
    int32_t v89; // 0xa6f2
    int32_t v90; // 0xdba0
    int32_t v91; // 0xf00b
    int32_t v92; // 0xf053
    int32_t v93; // 0xf207
    int32_t v94; // 0xfa6d
    int32_t v95 = 5; // R4
    int32_t v96 = 5; // 0x15c0c
    int32_t v97; // 0x23034
    if (v97 == 0) {
        // 0x15c0c
        v95 = v96 - 1;
        if (v96 != 1) {
            goto lab_0x15c14;
        }
        // 0x15c28
        return -1;
    }
  lab_0x15c06:;
    // 0x15c06
    struct PM_OBJ_TAG * v98; // 0x2303c
    if (v98 != NULL) {
        // 0x15c2e
        return 0;
    }
    // 0x15c06
    v96 = v95;
    // branch -> 0x15c0c
    // 0x15c0c
    v95 = v96 - 1;
    if (v96 == 1) {
        // 0x15c28
        return -1;
    }
  lab_0x15c14:
    while (true) {
        // 0x15c14
        sleep(1);
        if (v97 != 0) {
            goto lab_0x15c06;
        }
        int32_t v99 = v95; // 0x15c20
        v95 = v99 - 1;
        if (v99 == 1) {
            // break -> 0x15c28
            break;
        }
        // continue -> 0x15c14
    }
    // 0x15c28
    return -1;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_process_manager.c
// Address range: 0x15c38 - 0x15d2b
// Line range:    1863 - 1996
int32_t main_process_manager(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    char * v46; // 0x21470
    int32_t v47; // 0x21498
    int32_t v48; // 0x214a4
    char * v49; // 0x215d8
    int32_t v50; // 0x217b4
    char * v51; // 0x21ae8
    char * v52; // 0x2292e
    int32_t v53; // 0x22f95
    int32_t v54; // 0x22f9c
    int32_t v55; // 0x22fa0
    int32_t v56; // 0x22fa4
    int32_t v57; // 0x22fb0
    struct TAG_Mutex_3 * v58; // 0x22fb8
    char * v59; // 0x22fd4
    int32_t v60; // 0x22fdc
    int32_t v61; // 0x2300c
    int32_t v62; // 0x2301c
    int32_t v63; // 0x23034
    int32_t v64; // 0x23038
    struct PM_OBJ_TAG * v65; // 0x2303c
    int32_t v66; // 0x8946
    int32_t v67; // 0xa6f2
    int32_t v68; // 0xdba0
    int32_t v69; // 0xf00b
    int32_t v70; // 0xf053
    int32_t v71; // 0xf207
    int32_t v72; // 0xfa6d
    // 0x15c38
    memset((char *)&mProcMngrObj, 0, 136);
    if (init_task_queue_mem() == 0) {
        int32_t v73 = init_taskQ_ctrl_obj((struct TAG_TaskStack *)(int32_t)&mProcMngrObj); // 0x15c5c
        if (v73 == 0) {
            // 0x15c66
            int32_t v74; // 0x23040
            v74 = &v74;
            int32_t v75 = &v74; // 0x23044
            int32_t v76; // 0x23048
            v76 = &v76;
            int32_t v77 = &v76; // 0x2304c
            int32_t v78; // 0x230e0
            v78 = &v78;
            int32_t v79 = &v78; // 0x230e4
            struct TAG_Mutex_3 * v80; // 0x230e8
            appmngr_mutex_init((struct TAG_Mutex_3 *)&v80);
            struct TAG_Mutex_3 * v81; // 0x23058
            appmngr_mutex_init((struct TAG_Mutex_3 *)&v81);
            struct TAG_WaitCond_2 * v82; // 0x23070
            appmngr_waitcond_init((struct TAG_WaitCond_2 *)&v82);
            int32_t v83 = v73; // 0x230a4
            int32_t v84 = v73; // 0x23118
            int32_t v85 = v73; // 0x2311c
            int32_t v86 = v73; // 0x23120
            int32_t v87 = 0x15971; // 0x23104
            int32_t v88 = 2; // 0x230a0
            int32_t v89 = 0x1469d; // 0x23124
            int32_t v90 = 0x15f1d; // 0x23128
            char * v91 = (char *)0x140b9; // 0x23100
            int32_t v92 = 0x15615; // 0x23114
            int32_t v93 = 0x163bd; // 0x2310c
            int32_t v94; // 0x21460
            int32_t v95 = v94; // 0x23110
            int32_t v96 = 0x166b5; // 0x23108
            int32_t v97 = 1; // 0x23030
            // branch -> 0x15c54
        }
    }
    // 0x15c54
    return 0;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_process_manager.c
// Address range: 0x15d64 - 0x15dab
// Line range:    2819 - 2848
int32_t appmngr_pm_get_key_feedback(int32_t result) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x15d64
    get_process_mngr_obj();
    int32_t v97 = &mProcMngrObj; // R4
    if ((int32_t)&mProcMngrObj == -176) {
        // 0x15da6
        return -1;
    }
    // 0x15d74
    appmngr_mutex_lock((struct TAG_Mutex_3 *)((int32_t)&mProcMngrObj + 176));
    int32_t * v98 = (int32_t *)(v97 + 256); // 0x15d7a_0
    if (*v98 == 2) {
        // 0x15d8c
        *v98 = result == 0 ? 3 : 4;
        appmngr_waitcond_signal((struct TAG_WaitCond_2 *)(v97 + 200));
        // branch -> 0x15d82
    }
    // 0x15d82
    appmngr_mutex_unlock((struct TAG_Mutex_3 *)((int32_t)&mProcMngrObj + 176));
    return 0;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_process_manager.c
// Address range: 0x15f74 - 0x15f77
// Line range:    3757 - 3758
void appmngr_dump_keySetArr(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_process_manager.c
// Address range: 0x16130 - 0x16267
// Line range:    3969 - 3984
int32_t appmngr_adjust_keyset_by_proc_name(char * name, int32_t nMask, int32_t level1, int32_t level0) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    // 0x16130
    printf((char *)0x18a9c);
    get_process_mngr_obj();
    int32_t v97 = &mProcMngrObj; // R6
    int32_t v98 = 1; // R8
    int32_t v99 = 1; // 0x162342
    // branch -> 0x16168
  lab_0x16168_2:
    while (true) {
        // 0x16168
        int32_t v100; // 0x16168
        int32_t v101 = v100; // R7
        int32_t v102; // 0x161a6_3
        char * mem; // 0x161a6
        if (v100 == 0) {
            // 0x161a4
            mem = malloc(20);
            v102 = (int32_t)mem;
            if (mem != NULL) {
                goto lab_0x161ae_2;
            }
          lab_0x16220_2:
            // 0x16220
            appmngr_dump_keySetArr();
            // branch -> 0x16226
            // 0x16226
            return 1;
        }
        while (true) {
            // 0x16176
            int32_t str; // 0x16176
            if (strcmp((char *)str, (char *)(int32_t)name) == 0) {
                // 0x16184
                int32_t v103; // 0x16184
                if (v103 != 0) {
                    // 0x16190
                    int32_t v104; // 0x16192
                    if (v104 != 0) {
                        goto lab_0x16196;
                    }
                    // 0x16198
                    free((char *)v101);
                    // branch -> 0x161a4
                  lab_0x161a4:
                    // 0x161a4
                    mem = malloc(20);
                    v102 = (int32_t)mem;
                    if (mem != NULL) {
                      lab_0x161ae_2:;
                        int32_t * v105 = (int32_t *)(v102 + 12); // 0x161b4_0
                        *v105 = v98;
                        int32_t * v106 = (int32_t *)(v102 + 16); // 0x161b8_0
                        *v106 = v98;
                        *(int32_t *)mem = level1;
                        int32_t * v107 = (int32_t *)(v97 + 264); // 0x161da_0
                        int32_t v108 = *v107; // 0x161da
                        int32_t v109 = v108; // R4
                        int32_t v110 = v108; // R3
                        int32_t v111; // 0x16218
                        if (v108 == 0) {
                            // 0x16242
                            *v107 = v102;
                            // branch -> 0x16210
                          lab_0x16210_2:
                            // 0x16210
                            v97 += 4;
                            v111 = v99 + 1;
                            if (v111 == 12) {
                                // break (via goto) -> 0x16220
                                goto lab_0x16220_2;
                            }
                            v99 = v111;
                            // continue (via goto) -> 0x16168
                            goto lab_0x16168_2;
                        }
                        int32_t v112; // 0x161e4
                        if (v112 < level1) {
                            while (true) {
                                // 0x161ea
                                int32_t v113; // 0x161ea
                                if (v113 == 0) {
                                    // 0x16206
                                    int32_t v114; // 0x16206
                                    if (v114 != 0) {
                                        while (v114 != 0) {
                                            // 0x16204
                                            // continue -> 0x16204
                                        }
                                        // 0x1620c
                                        *v106 = v114;
                                        // branch -> 0x16210
                                        goto lab_0x16210_2;
                                    }
                                    // 0x1620c
                                    *v106 = v109;
                                    // branch -> 0x16210
                                    goto lab_0x16210_2;
                                } else {
                                    // 0x161ee
                                    uint32_t v115; // 0x161ee
                                    if (v115 >= level1) {
                                        // break -> 0x161f4
                                        break;
                                    }
                                    // continue -> 0x161ea
                                    continue;
                                }
                              lab_0x16210_3:
                                // 0x16210
                                v97 += 4;
                                v111 = v99 + 1;
                                if (v111 == 12) {
                                    // break (via goto) -> 0x16220
                                    goto lab_0x16220_2;
                                }
                                v99 = v111;
                                // continue (via goto) -> 0x16168
                                goto lab_0x16168_2;
                            }
                            // 0x16220
                            appmngr_dump_keySetArr();
                            // branch -> 0x16226
                            // 0x16226
                            return 1;
                        }
                        // 0x161f4
                        int32_t v116; // 0x161f4
                        if (v116 == 0) {
                            // 0x16248
                            *v107 = v102;
                            // branch -> 0x161fe
                        } else {
                            // 0x161fa
                            *v106 = v116;
                            // branch -> 0x161fe
                        }
                        // 0x161fe
                        *v105 = v110;
                        // branch -> 0x16210
                        goto lab_0x16210_3;
                    }
                    // 0x16220
                    appmngr_dump_keySetArr();
                    // branch -> 0x16226
                    // 0x16226
                    return 1;
                }
                // 0x1624e
                int32_t v117; // 0x1618a
                if (v117 != 0) {
                  lab_0x16196:;
                    // 0x16196
                    // branch -> 0x16198
                }
                // 0x16198
                free((char *)v101);
                // branch -> 0x161a4
                goto lab_0x161a4;
            } else {
                // 0x16170
                int32_t v118; // 0x16170
                v101 = v118;
                if (v118 == 0) {
                    // break -> 0x1622c
                    break;
                }
                // continue -> 0x16176
                continue;
            }
          lab_0x161a4_2:
            // 0x161a4
            mem = malloc(20);
            v102 = (int32_t)mem;
            if (mem != NULL) {
                goto lab_0x161ae_2;
            }
            // 0x16220
            appmngr_dump_keySetArr();
            // branch -> 0x16226
            // 0x16226
            return 1;
        }
        goto lab_0x161a4_2;
        // 0x16232
        printf("\n [em]-not found keyset, array[%d] ", v99);
        // branch -> 0x16226
        // 0x16226
        return -2;
    }
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_process_manager.c
// Address range: 0x16268 - 0x162c7
// Line range:    4120 - 4144
int32_t appmngr_pm_key_set_delete(int32_t sockfd) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    int32_t v97 = 12; // R7
    get_process_mngr_obj();
    int32_t v98 = &mProcMngrObj; // R6
    int32_t v99 = &mProcMngrObj; // 0x162bc
    // branch -> 0x1627a
  lab_0x1627a_2:
    while (true) {
        int32_t * v100 = (int32_t *)(v99 + 264); // 0x1627a_0
        int32_t v101 = *v100; // 0x1627a
        int32_t v102 = v101; // R4
        int32_t v103 = v99; // 0x162ac
        int32_t v104; // 0x162ac
        int32_t v105; // 0x162aa
        if (v101 != 0) {
            while (true) {
                // 0x16286
                int32_t v106; // 0x16286
                if (v106 == sockfd) {
                    // 0x1628c
                    int32_t v107;
                    int32_t v108; // 0x1628c
                    int32_t v109; // 0x1629a
                    if (v108 == 0) {
                        // 0x162bc
                        int32_t v110; // 0x1628e
                        *v100 = v110;
                        if (v110 != 0) {
                          lab_0x16298:;
                            // 0x16298
                            // branch -> 0x1629a
                        }
                    } else {
                        // 0x16292
                        int32_t v111; // 0x16294
                        if (v111 != 0) {
                            goto lab_0x16298;
                        }
                        // 0x1629a
                        free((char *)v109);
                        free((char *)v102);
                        // branch -> 0x162aa
                      lab_0x162aa:
                        // 0x162aa
                        v105 = v97;
                        v97 = v105 - 1;
                        v104 = v107 + 4;
                        v98 = v104;
                        if (v105 == 1) {
                            // break (via goto) -> 0x162b2
                            goto lab_0x162b2_2;
                        }
                        v99 = v104;
                        // continue (via goto) -> 0x1627a
                        goto lab_0x1627a_2;
                    }
                    // 0x1629a
                    free((char *)v109);
                    free((char *)v102);
                    v107 = v98;
                    // branch -> 0x162aa
                    goto lab_0x162aa;
                } else {
                    // 0x16282
                    int32_t v112; // 0x16282
                    v102 = v112;
                    if (v112 == 0) {
                        // break -> 0x162aa
                        break;
                    }
                    // continue -> 0x16286
                    continue;
                }
                // 0x162aa
                v105 = v97;
                v97 = v105 - 1;
                v104 = v103 + 4;
                v98 = v104;
                if (v105 == 1) {
                    // break (via goto) -> 0x162b2
                    goto lab_0x162b2_2;
                }
                v99 = v104;
                // continue (via goto) -> 0x1627a
                goto lab_0x1627a_2;
            }
            // 0x162b2
            appmngr_dump_keySetArr();
            return 1;
        }
        // 0x162aa
        v105 = v97;
        v97 = v105 - 1;
        v104 = v103 + 4;
        v98 = v104;
        if (v105 == 1) {
            // break -> 0x162b2
            break;
        }
        v99 = v104;
        // continue -> 0x1627a
    }
  lab_0x162b2_2:
    // 0x162b2
    appmngr_dump_keySetArr();
    return 1;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_process_manager.c
// Address range: 0x162c8 - 0x163bb
// Line range:    3295 - 3338
int32_t appmngr_pm_clear_terminative_process(int32_t pid_child, int32_t kill_flag, int32_t type, char * param) {
    struct anon_struct_150 v1;
    int32_t v2; // 0x101c1
    int32_t v3; // 0x111f1
    int32_t v4; // 0x12d09
    int32_t v5; // 0x13d01
    void (*v6)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v7; // 0x14b14
    int16_t * v8; // 0x14cde
    int32_t v9; // 0x157c5
    int32_t v10; // 0x1630f
    char * v11; // 0x16b14
    int32_t v12; // 0x21098
    int32_t v13; // 0x2109c
    int32_t v14; // 0x210a0
    int32_t v15; // 0x210a4
    int32_t * v16; // 0x211dc
    int32_t v17; // 0x213b8
    char * (**v18)(char *); // 0x213bc
    int32_t * v19; // 0x213c8
    int32_t * v20; // 0x213cc
    struct ApplicationManagerController ** v21; // 0x213d0
    int32_t v22; // 0x213d4
    char (*v23)[10]; // 0x213e0
    char * v24[2]; // 0x213e4
    char * (**v25)(char *); // 0x213e8
    char * v26; // 0x213ec
    int16_t * v27; // 0x213f0
    char * v28; // 0x213f2
    char * v29; // 0x213f4
    int32_t v30; // 0x213f8
    int32_t v31; // 0x21400
    int32_t v32; // 0x21404
    void (*v33)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v34)[128]; // 0x21418
    int32_t v35; // 0x2141c
    int32_t v36; // 0x21420
    char ** v37; // 0x21424
    int32_t v38; // 0x21428
    int32_t v39; // 0x21434
    int32_t v40; // 0x21438
    int32_t * v41; // 0x2143c
    int32_t v42; // 0x21440
    int32_t v43; // 0x21448
    int32_t v44; // 0x2144c
    int32_t v45; // 0x21450
    int32_t v46; // 0x21458
    int32_t v47; // 0x21460
    char * v48; // 0x21470
    int32_t v49; // 0x21498
    int32_t v50; // 0x214a4
    char * v51; // 0x215d8
    int32_t v52; // 0x217b4
    char * v53; // 0x21ae8
    char * v54; // 0x2292e
    int32_t v55; // 0x22f95
    int32_t v56; // 0x22f9c
    int32_t v57; // 0x22fa0
    int32_t v58; // 0x22fa4
    int32_t v59; // 0x23030
    int32_t v60; // 0x23034
    int32_t v61; // 0x23038
    struct PM_OBJ_TAG * v62; // 0x2303c
    int32_t v63; // 0x23040
    int32_t v64; // 0x23044
    int32_t v65; // 0x23048
    int32_t v66; // 0x2304c
    struct TAG_Mutex_3 * v67; // 0x23058
    struct TAG_WaitCond_2 * v68; // 0x23070
    int32_t v69; // 0x230a0
    int32_t v70; // 0x230a4
    int32_t v71; // 0x230e0
    int32_t v72; // 0x230e4
    struct TAG_Mutex_3 * v73; // 0x230e8
    char * v74; // 0x23100
    int32_t v75; // 0x23104
    int32_t v76; // 0x23108
    int32_t v77; // 0x2310c
    int32_t v78; // 0x23110
    int32_t v79; // 0x23114
    int32_t v80; // 0x23118
    int32_t v81; // 0x2311c
    int32_t v82; // 0x23120
    int32_t v83; // 0x23124
    int32_t v84; // 0x8946
    int32_t v85; // 0xa6f2
    int32_t v86; // 0xdba0
    int32_t v87; // 0xf00b
    int32_t v88; // 0xf053
    int32_t v89; // 0xf207
    int32_t v90; // 0xfa6d
    int32_t v91;
    int32_t (*v92)() = (int32_t (*)())v91;
    memset((char *)&v1, 0, 104);
    int32_t v93; // 0x22fb0
    struct TAG_Mutex_3 * v94; // 0x22fb8
    char * str2; // 0x22fd4
    int32_t v95; // 0x22fdc
    int32_t v96; // 0x2300c
    int32_t v97; // 0x2301c
    int32_t v98; // 0x23128
    int32_t v99;
    int32_t v100;
    int32_t v101;
    int32_t str;
    int32_t v102;
    int32_t v103; // 0x16306
    int32_t v104; // 0x1630e
    int32_t v105; // 0x16364
    int32_t v106; // 0x16356
    int32_t v107; // 0x16304
    int32_t v108; // 0x16328
    int32_t v109; // 0x16340
    if ((int32_t)param != 0) {
        // 0x162e4
        int32_t v110; // 0x162e4
        if (v110 != 3) {
            // 0x162ee
            // branch -> 0x162f6
        }
        // 0x162f6
        appmngr_mutex_lock((struct TAG_Mutex_3 *)&v94);
        v107 = v96;
        v103 = &mProcMngrObj;
        ((int32_t (*)(int32_t, int32_t, int32_t, int32_t))(v107 & -2))(v103, 0, (int32_t)&pid_child, v107);
        v104 = v103;
        v99 = v104;
        if (v104 == 0) {
            // 0x163a0
            appmngr_mutex_unlock((struct TAG_Mutex_3 *)(int32_t)&v94);
            // branch -> 0x16360
          lab_0x16360:
            // 0x16360
            v99 = v100;
            v92();
            v105 = v101;
            // branch -> 0x16364
        } else {
            // 0x16314
            strncpy((char *)&str, str2, 63);
            v108 = v93;
            if (v108 == 0) {
                // 0x1632c
                if (0x80000000 * v95 == 0) {
                    // 0x16332
                    appmngr_mutex_unlock((struct TAG_Mutex_3 *)&v94);
                    v109 = v97;
                    ((int32_t (*)(int32_t, int32_t, int32_t))(v109 & -2))((int32_t)&mProcMngrObj, v99, v109);
                    // branch -> 0x16346
                } else {
                    // 0x1632c
                    // branch -> 0x16370
                  lab_0x16370:
                    // 0x16370
                    memset((char *)(v99 + 88), 0, 48);
                    appmngr_mutex_unlock((struct TAG_Mutex_3 *)&v94);
                    // branch -> 0x16346
                }
              lab_0x16346:
                // 0x16346
                v106 = v98;
                ((int32_t (*)(int32_t, int32_t))(v106 & -2))((int32_t)&v102, v106);
                // branch -> 0x16360
                goto lab_0x16360;
            } else {
                v105 = v108;
            }
        }
      lab_0x16364:
        // 0x16364
        appmngr_pm_key_set_delete(v105);
        // branch -> 0x16370
        goto lab_0x16370;
    }
    // 0x162f6
    appmngr_mutex_lock((struct TAG_Mutex_3 *)&v94);
    v107 = v96;
    v103 = &mProcMngrObj;
    ((int32_t (*)(int32_t, int32_t, int32_t, int32_t))(v107 & -2))(v103, 0, (int32_t)&pid_child, v107);
    v104 = v103;
    v99 = v104;
    if (v104 == 0) {
        // 0x163a0
        appmngr_mutex_unlock((struct TAG_Mutex_3 *)(int32_t)&v94);
        // branch -> 0x16360
      lab_0x16360_2:
        // 0x16360
        v99 = v100;
        v92();
        v105 = v101;
        // branch -> 0x16364
        goto lab_0x16364;
    } else {
        // 0x16314
        strncpy((char *)&str, str2, 63);
        v108 = v93;
        if (v108 == 0) {
            // 0x1632c
            if (0x80000000 * v95 == 0) {
                // 0x16332
                appmngr_mutex_unlock((struct TAG_Mutex_3 *)&v94);
                v109 = v97;
                ((int32_t (*)(int32_t, int32_t, int32_t))(v109 & -2))((int32_t)&mProcMngrObj, v99, v109);
                // branch -> 0x16346
            } else {
                // 0x1632c
                // branch -> 0x16370
              lab_0x16370_2:
                // 0x16370
                memset((char *)(v99 + 88), 0, 48);
                appmngr_mutex_unlock((struct TAG_Mutex_3 *)&v94);
                // branch -> 0x16346
                goto lab_0x16346;
            }
            // 0x16346
            v106 = v98;
            ((int32_t (*)(int32_t, int32_t))(v106 & -2))((int32_t)&v102, v106);
            // branch -> 0x16360
            goto lab_0x16360_2;
        }
    }
    // 0x16364
    appmngr_pm_key_set_delete(v108);
    // branch -> 0x16370
    goto lab_0x16370_2;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_process_manager.c
// Address range: 0x1643c - 0x1653b
// Line range:    4208 - 4241
int32_t appmngr_pm_monitor_detached_process(void) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x21098
    int32_t v12; // 0x2109c
    int32_t v13; // 0x210a0
    int32_t v14; // 0x210a4
    int32_t * v15; // 0x211dc
    int32_t v16; // 0x213b8
    char * (**v17)(char *); // 0x213bc
    int32_t * v18; // 0x213c8
    int32_t * v19; // 0x213cc
    struct ApplicationManagerController ** v20; // 0x213d0
    int32_t v21; // 0x213d4
    char (*v22)[10]; // 0x213e0
    char * v23[2]; // 0x213e4
    char * (**v24)(char *); // 0x213e8
    char * v25; // 0x213ec
    int16_t * v26; // 0x213f0
    char * v27; // 0x213f2
    char * v28; // 0x213f4
    int32_t v29; // 0x213f8
    int32_t v30; // 0x21400
    int32_t v31; // 0x21404
    void (*v32)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v33)[128]; // 0x21418
    int32_t v34; // 0x2141c
    int32_t v35; // 0x21420
    char ** v36; // 0x21424
    int32_t v37; // 0x21428
    int32_t v38; // 0x21434
    int32_t v39; // 0x21438
    int32_t * v40; // 0x2143c
    int32_t v41; // 0x21440
    int32_t v42; // 0x21448
    int32_t v43; // 0x2144c
    int32_t v44; // 0x21450
    int32_t v45; // 0x21458
    int32_t v46; // 0x21460
    char * v47; // 0x21470
    int32_t v48; // 0x21498
    int32_t v49; // 0x214a4
    char * v50; // 0x215d8
    int32_t v51; // 0x217b4
    char * v52; // 0x21ae8
    char * v53; // 0x2292e
    int32_t v54; // 0x22f95
    int32_t v55; // 0x22f9c
    int32_t v56; // 0x22fa0
    int32_t v57; // 0x22fa4
    int32_t v58; // 0x22fb0
    struct TAG_Mutex_3 * v59; // 0x22fb8
    char * v60; // 0x22fd4
    int32_t v61; // 0x22fdc
    int32_t v62; // 0x2300c
    int32_t v63; // 0x2301c
    int32_t v64; // 0x23030
    int32_t v65; // 0x23034
    int32_t v66; // 0x23038
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x23128
    int32_t v90; // 0x8946
    int32_t v91; // 0xa6f2
    int32_t v92; // 0xdba0
    int32_t v93; // 0xf00b
    int32_t v94; // 0xf053
    int32_t v95; // 0xf207
    int32_t v96; // 0xfa6d
    get_process_mngr_obj();
    int32_t path = 0; // bp-92
    int32_t v97; // 0x16464
    if ((int32_t)&mProcMngrObj == -312 || v97 == (int32_t)&mProcMngrObj + 312) {
        // 0x164d4
        return 0;
    }
    // 0x1646c
    int32_t v98; // 0x16484
    path = v98;
    uint32_t v99; // 0x16484
    int32_t str = 0x1000000 * v99 / 0x10000 / 0x1000000;
    // branch -> 0x164a4
    while (true) {
        // 0x164a4
        if (v97 != 8) {
            // 0x164b4
            snprintf((char *)&str, 20, (char *)0x18afc);
            if (access((char *)&path, F_OK) < 0) {
                // 0x164dc
                printf((char *)0x18b00);
                print_timestamp("proc exit");
                int32_t v100; // 0x164ee
                appmngr_pm_clear_terminative_process(v100, 0, 0, NULL);
                get_process_mngr_obj();
                appmngr_mutex_lock((struct TAG_Mutex_3 *)((int32_t)&mProcMngrObj + 320));
                int32_t v101;
                free((char *)v101);
                get_process_mngr_obj();
                appmngr_mutex_unlock((struct TAG_Mutex_3 *)((int32_t)&mProcMngrObj + 320));
                // branch -> 0x164c8
            }
        }
        // 0x164c8
        int32_t v102; // 0x164c8
        if ((int32_t)&mProcMngrObj + 312 == v102) {
            // 0x164d4
            return 0;
        }
        // 0x164c8
        v97 = v102;
        // branch -> 0x164a4
    }
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_process_manager.c
// Address range: 0x168c4 - 0x16907
// Line range:    4379 - 4395
int32_t appmngr_send_msg_netflix_exit_dummy(void) {
    struct anon_struct_150 v1;
    int32_t v2; // 0x101c1
    int32_t v3; // 0x111f1
    int32_t v4; // 0x12d09
    int32_t v5; // 0x13d01
    void (*v6)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v7; // 0x14b14
    int16_t * v8; // 0x14cde
    int32_t v9; // 0x157c5
    int32_t v10; // 0x1630f
    char * v11; // 0x16b14
    int32_t v12; // 0x21098
    int32_t v13; // 0x2109c
    int32_t v14; // 0x210a0
    int32_t v15; // 0x210a4
    int32_t * v16; // 0x211dc
    int32_t v17; // 0x213b8
    char * (**v18)(char *); // 0x213bc
    int32_t * v19; // 0x213c8
    int32_t * v20; // 0x213cc
    struct ApplicationManagerController ** v21; // 0x213d0
    int32_t v22; // 0x213d4
    char (*v23)[10]; // 0x213e0
    char * v24[2]; // 0x213e4
    char * (**v25)(char *); // 0x213e8
    char * v26; // 0x213ec
    int16_t * v27; // 0x213f0
    char * v28; // 0x213f2
    char * v29; // 0x213f4
    int32_t v30; // 0x213f8
    int32_t v31; // 0x21400
    int32_t v32; // 0x21404
    void (*v33)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v34)[128]; // 0x21418
    int32_t v35; // 0x2141c
    int32_t v36; // 0x21420
    char ** v37; // 0x21424
    int32_t v38; // 0x21428
    int32_t v39; // 0x21434
    int32_t v40; // 0x21438
    int32_t * v41; // 0x2143c
    int32_t v42; // 0x21440
    int32_t v43; // 0x21448
    int32_t v44; // 0x2144c
    int32_t v45; // 0x21450
    int32_t v46; // 0x21458
    int32_t v47; // 0x21460
    char * v48; // 0x21470
    int32_t v49; // 0x21498
    int32_t v50; // 0x214a4
    char * v51; // 0x215d8
    int32_t v52; // 0x217b4
    char * v53; // 0x21ae8
    char * v54; // 0x2292e
    int32_t v55; // 0x22f95
    int32_t v56; // 0x22f9c
    int32_t v57; // 0x22fa0
    int32_t v58; // 0x22fa4
    int32_t v59; // 0x22fb0
    struct TAG_Mutex_3 * v60; // 0x22fb8
    char * v61; // 0x22fd4
    int32_t v62; // 0x22fdc
    int32_t v63; // 0x2300c
    int32_t v64; // 0x2301c
    int32_t v65; // 0x23030
    int32_t v66; // 0x23034
    int32_t v67; // 0x23038
    struct PM_OBJ_TAG * v68; // 0x2303c
    int32_t v69; // 0x23040
    int32_t v70; // 0x23044
    int32_t v71; // 0x23048
    int32_t v72; // 0x2304c
    struct TAG_Mutex_3 * v73; // 0x23058
    struct TAG_WaitCond_2 * v74; // 0x23070
    int32_t v75; // 0x230a0
    int32_t v76; // 0x230a4
    int32_t v77; // 0x230e0
    int32_t v78; // 0x230e4
    struct TAG_Mutex_3 * v79; // 0x230e8
    char * v80; // 0x23100
    int32_t v81; // 0x23104
    int32_t v82; // 0x23108
    int32_t v83; // 0x2310c
    int32_t v84; // 0x23110
    int32_t v85; // 0x23114
    int32_t v86; // 0x23118
    int32_t v87; // 0x2311c
    int32_t v88; // 0x23120
    int32_t v89; // 0x23124
    int32_t v90; // 0x23128
    int32_t v91; // 0x8946
    int32_t v92; // 0xa6f2
    int32_t v93; // 0xdba0
    int32_t v94; // 0xf00b
    int32_t v95; // 0xf053
    int32_t v96; // 0xf207
    int32_t v97; // 0xfa6d
    struct anon_struct_150 str;
    memset((char *)&v1, 0, 104);
    strncpy((char *)&str, (char *)0x17328, 63);
    appmngr_push_process_manage_event(0, (struct anon_struct_31 *)&v1);
    printf("\n [EM] send summy exit!");
    return 0;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_process_manager.c
// Address range: 0x16908 - 0x1694b
// Line range:    4397 - 4413
int32_t appmngr_send_msg_netflix_start_dummy(void) {
    struct anon_struct_150 v1;
    int32_t v2; // 0x101c1
    int32_t v3; // 0x111f1
    int32_t v4; // 0x12d09
    int32_t v5; // 0x13d01
    void (*v6)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v7; // 0x14b14
    int16_t * v8; // 0x14cde
    int32_t v9; // 0x157c5
    int32_t v10; // 0x1630f
    char * v11; // 0x16b14
    int32_t v12; // 0x21098
    int32_t v13; // 0x2109c
    int32_t v14; // 0x210a0
    int32_t v15; // 0x210a4
    int32_t * v16; // 0x211dc
    int32_t v17; // 0x213b8
    char * (**v18)(char *); // 0x213bc
    int32_t * v19; // 0x213c8
    int32_t * v20; // 0x213cc
    struct ApplicationManagerController ** v21; // 0x213d0
    int32_t v22; // 0x213d4
    char (*v23)[10]; // 0x213e0
    char * v24[2]; // 0x213e4
    char * (**v25)(char *); // 0x213e8
    char * v26; // 0x213ec
    int16_t * v27; // 0x213f0
    char * v28; // 0x213f2
    char * v29; // 0x213f4
    int32_t v30; // 0x213f8
    int32_t v31; // 0x21400
    int32_t v32; // 0x21404
    void (*v33)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v34)[128]; // 0x21418
    int32_t v35; // 0x2141c
    int32_t v36; // 0x21420
    char ** v37; // 0x21424
    int32_t v38; // 0x21428
    int32_t v39; // 0x21434
    int32_t v40; // 0x21438
    int32_t * v41; // 0x2143c
    int32_t v42; // 0x21440
    int32_t v43; // 0x21448
    int32_t v44; // 0x2144c
    int32_t v45; // 0x21450
    int32_t v46; // 0x21458
    int32_t v47; // 0x21460
    char * v48; // 0x21470
    int32_t v49; // 0x21498
    int32_t v50; // 0x214a4
    char * v51; // 0x215d8
    int32_t v52; // 0x217b4
    char * v53; // 0x21ae8
    char * v54; // 0x2292e
    int32_t v55; // 0x22f95
    int32_t v56; // 0x22f9c
    int32_t v57; // 0x22fa0
    int32_t v58; // 0x22fa4
    int32_t v59; // 0x22fb0
    struct TAG_Mutex_3 * v60; // 0x22fb8
    char * v61; // 0x22fd4
    int32_t v62; // 0x22fdc
    int32_t v63; // 0x2300c
    int32_t v64; // 0x2301c
    int32_t v65; // 0x23030
    int32_t v66; // 0x23034
    int32_t v67; // 0x23038
    struct PM_OBJ_TAG * v68; // 0x2303c
    int32_t v69; // 0x23040
    int32_t v70; // 0x23044
    int32_t v71; // 0x23048
    int32_t v72; // 0x2304c
    struct TAG_Mutex_3 * v73; // 0x23058
    struct TAG_WaitCond_2 * v74; // 0x23070
    int32_t v75; // 0x230a0
    int32_t v76; // 0x230a4
    int32_t v77; // 0x230e0
    int32_t v78; // 0x230e4
    struct TAG_Mutex_3 * v79; // 0x230e8
    char * v80; // 0x23100
    int32_t v81; // 0x23104
    int32_t v82; // 0x23108
    int32_t v83; // 0x2310c
    int32_t v84; // 0x23110
    int32_t v85; // 0x23114
    int32_t v86; // 0x23118
    int32_t v87; // 0x2311c
    int32_t v88; // 0x23120
    int32_t v89; // 0x23124
    int32_t v90; // 0x23128
    int32_t v91; // 0x8946
    int32_t v92; // 0xa6f2
    int32_t v93; // 0xdba0
    int32_t v94; // 0xf00b
    int32_t v95; // 0xf053
    int32_t v96; // 0xf207
    int32_t v97; // 0xfa6d
    struct anon_struct_150 str;
    memset((char *)&v1, 0, 104);
    strncpy((char *)&str, "vod.netflix", 63);
    appmngr_push_process_manage_event(0, (struct anon_struct_31 *)&v1);
    printf("\n [EM] send summy exit!");
    return 0;
}

// From module:   /home/liuxiaofeng/samba/svn_mw/TMER/core/eventmanager/appmngr_process_manager.c
// Address range: 0x1694c - 0x1698f
// Line range:    4415 - 4431
int32_t appmngr_send_msg_to_ui_by_transpond(void) {
    struct anon_struct_150 v1;
    int32_t v2; // 0x101c1
    int32_t v3; // 0x111f1
    int32_t v4; // 0x12d09
    int32_t v5; // 0x13d01
    void (*v6)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v7; // 0x14b14
    int16_t * v8; // 0x14cde
    int32_t v9; // 0x157c5
    int32_t v10; // 0x1630f
    char * v11; // 0x16b14
    int32_t v12; // 0x21098
    int32_t v13; // 0x2109c
    int32_t v14; // 0x210a0
    int32_t v15; // 0x210a4
    int32_t * v16; // 0x211dc
    int32_t v17; // 0x213b8
    char * (**v18)(char *); // 0x213bc
    int32_t * v19; // 0x213c8
    int32_t * v20; // 0x213cc
    struct ApplicationManagerController ** v21; // 0x213d0
    int32_t v22; // 0x213d4
    char (*v23)[10]; // 0x213e0
    char * v24[2]; // 0x213e4
    char * (**v25)(char *); // 0x213e8
    char * v26; // 0x213ec
    int16_t * v27; // 0x213f0
    char * v28; // 0x213f2
    char * v29; // 0x213f4
    int32_t v30; // 0x213f8
    int32_t v31; // 0x21400
    int32_t v32; // 0x21404
    void (*v33)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v34)[128]; // 0x21418
    int32_t v35; // 0x2141c
    int32_t v36; // 0x21420
    char ** v37; // 0x21424
    int32_t v38; // 0x21428
    int32_t v39; // 0x21434
    int32_t v40; // 0x21438
    int32_t * v41; // 0x2143c
    int32_t v42; // 0x21440
    int32_t v43; // 0x21448
    int32_t v44; // 0x2144c
    int32_t v45; // 0x21450
    int32_t v46; // 0x21458
    int32_t v47; // 0x21460
    char * v48; // 0x21470
    int32_t v49; // 0x21498
    int32_t v50; // 0x214a4
    char * v51; // 0x215d8
    int32_t v52; // 0x217b4
    char * v53; // 0x21ae8
    char * v54; // 0x2292e
    int32_t v55; // 0x22f95
    int32_t v56; // 0x22f9c
    int32_t v57; // 0x22fa0
    int32_t v58; // 0x22fa4
    int32_t v59; // 0x22fb0
    struct TAG_Mutex_3 * v60; // 0x22fb8
    char * v61; // 0x22fd4
    int32_t v62; // 0x22fdc
    int32_t v63; // 0x2300c
    int32_t v64; // 0x2301c
    int32_t v65; // 0x23030
    int32_t v66; // 0x23034
    struct PM_OBJ_TAG * v67; // 0x2303c
    int32_t v68; // 0x23040
    int32_t v69; // 0x23044
    int32_t v70; // 0x23048
    int32_t v71; // 0x2304c
    struct TAG_Mutex_3 * v72; // 0x23058
    struct TAG_WaitCond_2 * v73; // 0x23070
    int32_t v74; // 0x230a0
    int32_t v75; // 0x230a4
    int32_t v76; // 0x230e0
    int32_t v77; // 0x230e4
    struct TAG_Mutex_3 * v78; // 0x230e8
    char * v79; // 0x23100
    int32_t v80; // 0x23104
    int32_t v81; // 0x23108
    int32_t v82; // 0x2310c
    int32_t v83; // 0x23110
    int32_t v84; // 0x23114
    int32_t v85; // 0x23118
    int32_t v86; // 0x2311c
    int32_t v87; // 0x23120
    int32_t v88; // 0x23124
    int32_t v89; // 0x8946
    int32_t v90; // 0xa6f2
    int32_t v91; // 0xdba0
    int32_t v92; // 0xf00b
    int32_t v93; // 0xf053
    int32_t v94; // 0xf207
    int32_t v95; // 0xfa6d
    int32_t v96 = (int32_t)&v1; // 0x1694e_0
    memset((char *)&v1, 0, 104);
    puts("\n [EM] appmngr_send_msg_to_ui_by_transpond ");
    int32_t v97; // 0x23038
    int32_t v98; // 0x23128
    ((int32_t (*)(int32_t, int32_t, int32_t, int32_t))(v98 & -2))(v97, v96, v98, (int32_t)&mProcMngrObj);
    int32_t v99;
    ((int32_t (*)(int32_t))v99)(0);
    return 0;
}

// Address range: 0x16990 - 0x169d3
int32_t __libc_csu_init(int32_t result, int32_t a2, int32_t a3) {
    int32_t v1; // 0x101c1
    int32_t v2; // 0x111f1
    int32_t v3; // 0x12d09
    int32_t v4; // 0x13d01
    void (*v5)(struct parse_state *, int32_t, char **); // 0x13fed
    int32_t v6; // 0x14b14
    int16_t * v7; // 0x14cde
    int32_t v8; // 0x157c5
    int32_t v9; // 0x1630f
    char * v10; // 0x16b14
    int32_t v11; // 0x210a0
    int32_t v12; // 0x210a4
    int32_t * v13; // 0x211dc
    int32_t v14; // 0x213b8
    char * (**v15)(char *); // 0x213bc
    int32_t * v16; // 0x213c8
    int32_t * v17; // 0x213cc
    struct ApplicationManagerController ** v18; // 0x213d0
    int32_t v19; // 0x213d4
    char (*v20)[10]; // 0x213e0
    char * v21[2]; // 0x213e4
    char * (**v22)(char *); // 0x213e8
    char * v23; // 0x213ec
    int16_t * v24; // 0x213f0
    char * v25; // 0x213f2
    char * v26; // 0x213f4
    int32_t v27; // 0x213f8
    int32_t v28; // 0x21400
    int32_t v29; // 0x21404
    void (*v30)(struct aeEventLoop *, int32_t, char *, int32_t); // 0x21408
    char (*v31)[128]; // 0x21418
    int32_t v32; // 0x2141c
    int32_t v33; // 0x21420
    char ** v34; // 0x21424
    int32_t v35; // 0x21428
    int32_t v36; // 0x21434
    int32_t v37; // 0x21438
    int32_t * v38; // 0x2143c
    int32_t v39; // 0x21440
    int32_t v40; // 0x21448
    int32_t v41; // 0x2144c
    int32_t v42; // 0x21450
    int32_t v43; // 0x21458
    int32_t v44; // 0x21460
    char * v45; // 0x21470
    int32_t v46; // 0x21498
    int32_t v47; // 0x214a4
    char * v48; // 0x215d8
    int32_t v49; // 0x217b4
    char * v50; // 0x2292e
    int32_t v51; // 0x22f95
    int32_t v52; // 0x22f9c
    int32_t v53; // 0x22fa0
    int32_t v54; // 0x22fa4
    int32_t v55; // 0x22fb0
    struct TAG_Mutex_3 * v56; // 0x22fb8
    char * v57; // 0x22fd4
    int32_t v58; // 0x22fdc
    int32_t v59; // 0x2300c
    int32_t v60; // 0x2301c
    int32_t v61; // 0x23030
    int32_t v62; // 0x23034
    int32_t v63; // 0x23038
    struct PM_OBJ_TAG * v64; // 0x2303c
    int32_t v65; // 0x23040
    int32_t v66; // 0x23044
    int32_t v67; // 0x23048
    int32_t v68; // 0x2304c
    struct TAG_Mutex_3 * v69; // 0x23058
    struct TAG_WaitCond_2 * v70; // 0x23070
    int32_t v71; // 0x230a0
    int32_t v72; // 0x230a4
    int32_t v73; // 0x230e0
    int32_t v74; // 0x230e4
    struct TAG_Mutex_3 * v75; // 0x230e8
    char * v76; // 0x23100
    int32_t v77; // 0x23104
    int32_t v78; // 0x23108
    int32_t v79; // 0x2310c
    int32_t v80; // 0x23110
    int32_t v81; // 0x23114
    int32_t v82; // 0x23118
    int32_t v83; // 0x2311c
    int32_t v84; // 0x23120
    int32_t v85; // 0x23124
    int32_t v86; // 0x23128
    int32_t v87; // 0x8946
    int32_t v88; // 0xa6f2
    int32_t v89; // 0xdba0
    int32_t v90; // 0xf00b
    int32_t v91; // 0xf053
    int32_t v92; // 0xf207
    int32_t v93; // 0xfa6d
    // 0x16990
    _init();
    int32_t v94; // 0x21098
    int32_t v95 = &v94; // 0x169a8
    int32_t v96; // 0x2109c
    int32_t v97 = (int32_t)&v96 - v95; // 0x169a8
    if ((v97 & 2) == 0) {
        // 0x16990
        // branch -> 0x169c8
    } else {
        int32_t v98 = 0; // 0x169c0
        int32_t v99 = v95 - 4; // 0x169b6
        // branch -> 0x169b6
        while (true) {
            // 0x169b6
            frame_dummy(result, a2);
            int32_t v100 = v98 + 1; // 0x169c4
            if (v100 != v97 / 4) {
                // 0x169b6
                v98 = v100;
                v99 += 4;
                // branch -> 0x169b6
                continue;
            }
            // 0x169c8
            char * v101; // 0x21ae8
            return (int32_t)&v101;
        }
    }
    // 0x169c8
    return result;
}

// --------------- Dynamically Linked Functions ---------------

// const unsigned short int ** __ctype_b_loc(void);
// int * __errno_location(void);
// char * __strdup(const char * string);
// void _ZdlPv(void * ptr);
// void _ZNSt8__detail15_List_node_base7_M_hookEPS0___GLIBCXX_3_4_15(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
// void * _Znwj(unsigned int size);
// int accept(int fd, __SOCKADDR_ARG addr, socklen_t * restrict addr_len);
// int access(const char * name, int type);
// int bind(int fd, __CONST_SOCKADDR_ARG addr, socklen_t len);
// void * calloc(size_t nmemb, size_t size);
// int chmod(const char * file, __mode_t mode);
// int close(int fd);
// void DirectFBInit(int32_t a1, int32_t a2);
// int epoll_create(int size);
// int epoll_ctl(int epfd, int op, int fd, struct epollevent * __event);
// int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);
// int eventfd(int count, int flags);
// void exit(int status);
// int fcntl(int fd, int cmd, ...);
// FILE * fopen(const char * restrict filename, const char * restrict modes);
// void free(void * ptr);
// __gid_t getegid(void);
// char * getenv(const char * name);
// __uid_t geteuid(void);
// __pid_t getpid(void);
// int getsockopt(int fd, int level, int optname, void * restrict optval, socklen_t * restrict optlen);
// int gettimeofday(struct timeval * restrict tv, __timezone_ptr_t tz);
// int ioctl(int fd, unsigned long int request, ...);
// int kill(__pid_t pid, int sig);
// int listen(int fd, int n);
// __off_t lseek(int fd, __off_t offset, int whence);
// void * malloc(size_t size);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// void * memset(void * s, int c, size_t n);
// int mkdir(const char * path, __mode_t mode);
// int open(const char * file, int oflag, ...);
// void perror(const char * s);
// int printf(const char * restrict format, ...);
// int pthread_cond_init(pthread_cond_t * restrict cond, const pthread_condattr_t * restrict cond_attr);
// int pthread_cond_signal(pthread_cond_t * cond);
// int pthread_create(pthread_t * restrict newthread, const pthread_attr_t * restrict attr, void *(* start_routine)(void *), void * restrict arg);
// int pthread_mutex_init(pthread_mutex_t * mutex, const pthread_mutexattr_t * mutexattr);
// int pthread_mutex_lock(pthread_mutex_t * mutex);
// int pthread_mutex_unlock(pthread_mutex_t * mutex);
// int puts(const char * s);
// ssize_t read(int fd, void * buf, size_t nbytes);
// ssize_t recvmsg(int fd, struct msghdr * message, int flags);
// int select(int nfds, fd_set * restrict readfds, fd_set * restrict writefds, fd_set * restrict exceptfds, struct timeval * restrict timeout);
// ssize_t sendmsg(int fd, const struct msghdr * message, int flags);
// int setsockopt(int fd, int level, int optname, const void * optval, socklen_t optlen);
// unsigned int sleep(unsigned int seconds);
// int snprintf(char * restrict s, size_t maxlen, const char * restrict format, ...);
// int socket(int domain, int type, int protocol);
// int sprintf(char * restrict s, const char * restrict format, ...);
// int strcmp(const char * s1, const char * s2);
// char * strcpy(char * restrict dest, const char * restrict src);
// char * strerror(int errnum);
// size_t strlen(const char * s);
// char * strncpy(char * restrict dest, const char * restrict src, size_t n);
// int system(const char * command);
// int unlink(const char * name);
// int vsnprintf(char * restrict s, size_t maxlen, const char * restrict format, _G_va_list arg);
// __pid_t waitpid(__pid_t pid, int * stat_loc, int options);
// ssize_t write(int fd, const void * buf, size_t n);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.7.3)
// Detected language: C++
// Detected functions: 189
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2018-02-15 16:22:28
